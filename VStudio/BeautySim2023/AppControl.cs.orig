using BlockSim.Common;
using BlockSim2020.DataModel;
using Device.BlockSim;
using Device.Motion;
using Device.Polhemus;
using HelixToolkit.Wpf.SharpDX;
using LiteDB;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Diagnostics;
using System.Drawing.Imaging;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Windows;
using System.Windows.Automation;
using System.Windows.Controls;
using System.Windows.Controls.Primitives;
using System.Windows.Interop;
using System.Windows.Media;
using System.Windows.Media.Effects;
using System.Windows.Media.Imaging;
using System.Windows.Media.Media3D;
using System.Windows.Threading;
using VectorMath;

namespace BlockSim2020
{
    public class AppControl : IDisposable, INotifyPropertyChanged
    {
        public const string CadsFolder = "C:\\BlockSim\\Models3D\\";

        public const string CasesFolder = "C:\\BlockSim\\Cases\\";

        public const string Orthographic = "Orthographic Camera";

        public const string Perspective = "Perspective Camera";

        public Brush ActiveEllipse = new SolidColorBrush(System.Windows.Media.Color.FromArgb(255, 0, 150, 136));

        public ObservableCollection<CaseStructure> Cases;

        public ObservableCollection<string> Modules;

        public ObservableCollection<string> ModulesNames;

        public CaseStructure CurrentCase = null;

        public string CurrentModule = null;

        public Events CurrentEvent = null;

        public Users CurrentStudent = null;

        public Users CurrentTeacher = null;

        public VectorMath.Vector3 D_PCenter_PEdge = new VectorMath.Vector3(-13f, 0, 0);

        public VectorMath.Vector3 D_PEdge_CollisionEdge = new VectorMath.Vector3(-13f, 0, 0);

        internal void AddNewDeformation(Point point)
        {
            deformationsForNerveContinuousInjections.Add(new Deformation(Enum_DeformationMode.ONESHOT, sizeEffect / 2.0, maximumDisplacement / 2.0, point, AppControl.Instance, offsetWidEco, offsetHeiEco, deformationTotalTimeSeconds, intervalMsTimer, deformationsForNerveContinuousInjections));
            EffectNerveHitActivated = true;
            WorkingFrameTeacher wft = (WorkingFrameTeacher)WindowTeacher.PageContainer.Content;
            StudentFrame sf = (StudentFrame)WindowStudent.PageContainer.Content;
            wft.bStopTheCase.IsEnabled = true;
            sf.bStopTheCase.IsEnabled = true;
        }

        public VectorMath.Vector3 D_COLLISION = new VectorMath.Vector3(-140f, 0, 0);

        public VectorMath.Vector3 D_ANTICOLLISION = new VectorMath.Vector3(140f, 0, 0);

        public VectorMath.Vector3 D_COLLISION_NEEDLE = new VectorMath.Vector3(-100f, 0, 0);

        public VectorMath.Vector3 D_ANTICOLLISION_NEEDLE = new VectorMath.Vector3(-140f, 0, 0);

        public VectorMath.Vector3 D_NEdge_CollisionEdge = new VectorMath.Vector3(13f, 0, 0);

        public VectorMath.Vector3 D_S01Center_PCenter;

        public VectorMath.Vector3 D_S01Center_S01Edge = new VectorMath.Vector3(7.65f, 0, .33f);

        public VectorMath.Vector3 D_S01Edge_PEdge;

        public Vector3D DisalignmentModelSkinBlock = new Vector3D(0, 0, 27);

        public List<Stream> ImagesBackGround;

        public double LimitAngleDeg = 10;

        public float LimitZ = 11;

        public BlurEffect myBlurEffect = new BlurEffect();

        public BlurEffect myBlurEffectTeacher;

        public List<VectorMath.Vector3> needlePoints_NRS;

        public List<VectorMath.Vector3> needlePoints_PRS;

        public List<VectorMath.Vector3> needlePoints_WRS;

        public int numPointsNeedle;

        public VectorMath.Vector3 originalPositionSkinBlockCenter_WRS;
        public SharpDX.Vector3 NedleAreaEnd = new SharpDX.Vector3(0, 0, 0);
        public float PhysicalLengthNeedle = 131;

        public VectorMath.Quaternion rotationFromSensor01ToProbe;

        public Vector3D sizePad = new Vector3D(110, 165, 54);

        public string StringCurrentCase = BlockSim.Globalization.Language.str_curr_case;

        public string StringLoadCase = BlockSim.Globalization.Language.str_sel_load_case;

        public string StringNeedleInjCorrectTarget = BlockSim.Globalization.Language.str_great;

        public string StringNeedleInjFindFrame = BlockSim.Globalization.Language.str_find_correct_view;

        public string StringNeedleInjInsertAnesthetic = BlockSim.Globalization.Language.str_cont_ins;

        public string StringNeedleInjTakeAim = BlockSim.Globalization.Language.str_go_ahead;

        public string StringNeedleInjWrongTarget = BlockSim.Globalization.Language.str_oh_no;

        public Point3D TraslationFromSensor02ToNeedleStart = new Point3D(10, 0, 0);

        public double xmax = 0;

        public double xmin = 0;

        public double ymax = 0;

        public double ymin = 0;

        public double zmax = 0;

        public double zmin = 0;

        private static AppControl instance = null;

        private float additionalLengthZForPunctureOnCurve;

        private double alpha;

        private bool alreadyConnectedPolhemus;

        private double angleDeg;

        internal void StopTimerEffectNeedle()
        {
            timerReadMouse.Stop();
        }

        private HelixToolkit.Wpf.SharpDX.Camera camera;

        private string cameraModel;

        private float centerMirrorEcoImage;

        public VectorMath.Vector3 CenterOfWRS_inHRS;

        private int counter = 0;

        private decimal CurrentCaseScore = 0;

        public Phase CurrentPhase;

        private HelixToolkit.Wpf.SharpDX.OrthographicCamera defaultOrthographicCamera = new HelixToolkit.Wpf.SharpDX.OrthographicCamera { Position = new System.Windows.Media.Media3D.Point3D(0, 0, 5), LookDirection = new System.Windows.Media.Media3D.Vector3D(-0, -0, -5), UpDirection = new System.Windows.Media.Media3D.Vector3D(0, 1, 0), NearPlaneDistance = 1, FarPlaneDistance = 100 };

        private HelixToolkit.Wpf.SharpDX.PerspectiveCamera defaultPerspectiveCamera = new HelixToolkit.Wpf.SharpDX.PerspectiveCamera { Position = new System.Windows.Media.Media3D.Point3D(0, 0, 5), LookDirection = new System.Windows.Media.Media3D.Vector3D(-0, -0, -5), UpDirection = new System.Windows.Media.Media3D.Vector3D(0, 1, 0), NearPlaneDistance = 0.5, FarPlaneDistance = 150 };

        private DeformableArea deformableArea;

        private float deltaViewFar = 1500;

        private float deltaViewNear = 600;

        private double depthImage;

        private DispatcherTimer dispatcherTimerAnimation = new DispatcherTimer();

        private bool disposedValue = false;

        private IEffectsManager effectsManager;

        private Point3D endPath;

        private FRAME f1;

        private FRAME f2;

        private InfoFrames framesDefinition;

        public float Height = 100;

        private float hOrigin;

        private float hScaled;

        private BitmapSource imEcoSource;

        private BitmapSource imEcoSourceTeacher;

        private List<int> index_points_to_move = new List<int>();

        private int insertionNeedle;

        private string insertionNeedleText;

        private DateTime lastArrivedInput;

        private float lengthNeedle;

        //private double length;
        private System.Windows.Media.Brush lineColor;

        private System.Windows.Media.Brush lineColorEco;

        private Brush lineColorNegative;

        private Brush lineColorPositive;

        private float lineX1EcoStudent;

        private float lineX1EcoTeacher;

        private float lineX1EcoTeacherNegative;

        private float lineX1EcoTeacherPositive;

        private float lineX1IndicationEcoStudent;

        private float lineX1IndicationEcoTeacher;

        private float lineX2EcoStudent;

        private float lineX2EcoTeacher;

        private float lineX2EcoTeacherNegative;

        private float lineX2EcoTeacherPositive;

        private float lineX2IndicationEcoStudent;

        private float lineX2IndicationEcoTeacher;

        private float lineY1EcoStudent;

        private float lineY1EcoTeacher;

        private float lineY1EcoTeacherNegative;

        private float lineY1EcoTeacherPositive;

        private float lineY1IndicationEcoStudent;

        private float lineY1IndicationEcoTeacher;

        private float lineY2EcoStudent;

        private float lineY2EcoTeacher;

        private float lineY2EcoTeacherNegative;

        private float lineY2EcoTeacherPositive;

        private float lineY2IndicationEcoStudent;

        private float lineY2IndicationEcoTeacher;

        private bool loadedCase;

        private float minValueAlpha = 0.35f;

        private float mirrorImage;

        private HelixToolkit.Wpf.SharpDX.MeshGeometry3D model;

        private HelixToolkit.Wpf.SharpDX.MeshGeometry3D modelDeformableArea;

        private HelixToolkit.Wpf.SharpDX.DiffuseMaterial modelMaterial;

        private HelixToolkit.Wpf.SharpDX.DiffuseMaterial modelMaterialDeformableArea;

        private ColorStripeMaterial modelMaterialNeedleNegative;

        private ColorStripeMaterial modelMaterialNeedlePositive;

        private HelixToolkit.Wpf.SharpDX.MeshGeometry3D modelNeedleNegative;

        private HelixToolkit.Wpf.SharpDX.MeshGeometry3D modelNeedlePositive;

        private HelixToolkit.Wpf.SharpDX.MeshGeometry3D modelQuad;

        private HelixToolkit.Wpf.SharpDX.DiffuseMaterial modelQuadMaterial;

        private string nameFileDefinitionSave;

        private bool needleAlignedCorrectly;

        private bool needleAngleOk;

        private LineGeometry3D needleArea;

        private LineGeometry3D needleAreaIndication;

        private LineGeometry3D targetMuscularIndication;

        private LineGeometry3D needleAreaLine1;

        private LineGeometry3D needleAreaLine2;

        private System.Windows.Media.Color needleColor;

        private System.Windows.Media.Color needleIndicationColor;

        private System.Windows.Media.Color targetMuscularIndicationColor;

        private bool needleInSkin;

        //private bool needleOnSkin = false;

        private VectorMath.Vector3 needlePointFinish_HRS;

        private VectorMath.Vector3 needlePointFinish_WRS_real;

        private VectorMath.Vector3 needlePointFinish_WRS_realHalf;

        private VectorMath.Vector3 needlePointFinish_WRS_toBeUsed;

        private VectorMath.Vector3 needlePointStart_WRS_real;

        private VectorMath.Vector3 needlePointStart_WRS_toBeUsed;

        internal void StartTimerEffectNeedle()
        {
            timerReadMouse.Start();
        }

        private System.Windows.Media.Color needleTipIndicationColor;

        private bool needleTipOnPlane;

        private YPR needleYPR_HRS_real;

        private YPR needleYPR_WRS_real;

        public int NumPointsX = 100;

        public int NumPointsY = 100;

        private List<SharpDX.Vector3> originalEffectPOints;

        private Point3D originPlaneImage;

        private PDIClass pDIClass;

        private double pitchSensor01, pitchSensor02;

        private bool plottedCircles;

        private VectorMath.Vector3 pointEnd_WRS;

        private SharpDX.Vector3[] pointsDX;

        private SharpDX.Vector3[] pointsDXMask;

        private VectorMath.Vector3 pointStart_WRS;

        private VectorMath.Vector3 positionProbeCenter_WRS;

        private VectorMath.Vector3 positionProbeEdge_HRS;
        private Vector3 positionProbeEdge_HRS_ForCollisionPadD;
        private Vector3 positionProbeEdge_HRS_ForAntiCollisionPadD;
        private VectorMath.Vector3 positionProbeEdge_WRS;

        private VectorMath.Vector3 positionProbeEdge_WRS_ForCollisionPadD;
        private VectorMath.Vector3 positionProbeEdge_WRS_ForAntiCollisionPadD;

        private Vector3 vecCollisionProbe_WRS;

        private Vector3 vecCollisionNeedle_WRS;

        private VectorMath.Vector3 positionSensor01_WRS;

        private VectorMath.Vector3 positionSensor02_WRS_fake;

        private VectorMath.Vector3 positionSensor02_WRS_real;

        private VectorMath.Vector3 positionSensor02_WRS_toBeUsed;

        private bool probeOnSkin = false;

        private YPR probeYPR_HRS;

        private YPR probeYPR_WRS;

        private double rollSensor01, rollSensor02;

        private VectorMath.Quaternion rotationFromSensor02ToNeedle = VectorMath.Quaternion.RotationAxis(new VectorMath.Vector3(1, 0, 0), 100f / 180f * (float)Math.PI);

        public double[,] RotationMatrix_HRS_TO_WRS;

        private double[,] rotationMatrix_WRS_TO_HRS;

        private double[,] rotationMatrixTrasposed_Needle_WRS_real;

        private double[,] rotationMatrixTrasposed_Needle_WRS_toBeUsed;

        private double[,] rotationMatrixTrasposed_Needle_WRS_WhenInsertion;

        private double[,] rotationMatrixTrasposed_Probe_WRS;

        private VectorMath.Quaternion rotationNeedle_HRS_real;

        private System.Windows.Media.Media3D.Quaternion rotationNeedle_WRS_m;

        private VectorMath.Quaternion rotationNeedle_WRS_real;

        private VectorMath.Quaternion rotationNeedle_WRS_WhenInsertion;

        private System.Windows.Media.Media3D.Quaternion rotationOperableEnsamble;

        private VectorMath.Quaternion rotationProbe_HRS;

        private VectorMath.Quaternion rotationProbe_WRS;

        private System.Windows.Media.Media3D.Quaternion rotationProbe_WRS_m;

        private System.Windows.Media.Media3D.Quaternion rotationQuaternion_WRS_TO_HRS;

        internal void WorkingFrameLoaded(object sender, RoutedEventArgs e)
        {
            AppControl.Instance.VisibilityResults = Visibility.Hidden;
        }

        private VectorMath.Quaternion rotationQuaternion_WRS_TO_HRS_VectorMath;

        private VectorMath.Quaternion rotationSensor01_HRS;

        private VectorMath.Quaternion rotationSensor01_WRS;

        private System.Windows.Media.Media3D.Quaternion rotationSensor01_WRS_m;

        private VectorMath.Quaternion rotationSensor02_HRS_real;

        private VectorMath.Quaternion rotationSensor02_WRS_real;

        private VectorMath.Quaternion rotationSensor02_WRS_WhenInsertion;

        private YPR sensor01ypr_HRS;

        private YPR sensor01ypr_WRS;

        private YPR sensor02ypr_HRS_real;

        internal void ZeroEffects()
        {
            ModelDeformableArea = null;
            TargetMuscularIndication = null;
            TargetNerveIndication1 = null;
            TargetNerveIndication2 = null;
            TargetNerveIndication3 = null;
            TargetNerveIndication4 = null;
            TargetNerveIndication5 = null;
            TargetNerveIndication6 = null;
            TargetNerveIndication7 = null;
            TargetNerveIndication8 = null;
            TargetNerveIndication9 = null;
            TargetNerveIndication10= null;
            TargetNerveIndication11 = null;
        }

        private YPR sensor02ypr_WRS_real;

        //private bool showFasciaFrames;

        private bool showTargetPosition;

        private bool showIndicationNeedle;

        private List<SmartGridPoint> smartGridPointsOld = new List<SmartGridPoint>();

        private Point3D startPath;

        private bool visibilityProbeCollisionCheck = false;

        private bool visibilityNeedleCollisionCheck = false;

        private Point3D collidePointNeedle;

        private string subTitle;

        private string textFasciaTarget;

        private string textFasciaTargetExp;

        private string textNerveTargetExp;

        private string textNeedlePuntures;

        private string textNeedlePunturesExp;

        private string textScore;

        private string textTime;

        private string textTimeExp;

        private float timeAnimation = 2000;

        private DispatcherTimer timerCheckPolhemus;

        private bool tipInVisiblePlane;

        private string title;

        private BitmapSource toPass = null;

        private BitmapSource toPass2 = null;

        private bool toPlot;

        private bool toUpdateControls;

        private VectorMath.Vector3 versorNeedle_WhenInsertion;

        private Visibility visibilityBorderArrowDown;

        private Visibility visibilityBorderArrowLeft;

        private Visibility visibilityBorderArrowRight;

        private Visibility visibilityBorderArrowRotation;

        private Visibility visibilityBorderArrowRotation2;

        private Visibility visibilityBorderArrowUp;

        private Visibility visibilityLogoOnStudentPage;

        private Visibility visibilityResults;

        private Visibility visibilityViewEcoImage;

        private Visibility visibilityViewEcoSharpDX;

        private Visibility visibleIndicationLine;

        private Visibility visibleLine;

        private Visibility visibleLineNegative;

        private Visibility visibleLinePositive;

        private Visibility visibleNeedleTipIndication;

        private bool visibleProbePlaneAntenna;

        public float Width = 100;

        private double widthImage;

        private float wOrigin;

        private float wScaled;

        private float xPosOperableEnsamble;

        private float xPosProbeCenter;

        private float xPosProbeEdge;

        private float xPosSensor01 = 0, xPosSensor02, xTipNeedle = 0;

        private double yawSensor01, yawSensor02;

        private float yPosOperableEnsamble;

        private float yPosProbeCenter;

        private float yPosProbeEdge;

        private float yPosSensor01 = 0, yPosSensor02, yTipNeedle = 0;

        private float zPosOperableEnsamble;

        private float zPosProbeCenter;

        private float zPosProbeEdge;

        private float zPosSensor01 = 0, zPosSensor02, zTipNeedle = 0;

        public PleuralAnimator animator1;

        public PleuralAnimator animator2;

        private DispatcherTimer imageRefresher;

        public bool BKSSimulatorConnected { get; private set; }

        public bool ModulesChecked { get; set; }

        public bool[] ModulesActivation { get; private set; }

        private AppControl()
        {
            ModelMaterialNeedlePositive = new ColorStripeMaterial();
            ModelMaterialNeedleNegative = new ColorStripeMaterial();
            ImagesBackGround = new List<Stream>();
            Cases = new ObservableCollection<CaseStructure>();
            myBlurEffect = new BlurEffect();
            myBlurEffectTeacher = new BlurEffect();
            nameFileDefinitionSave = "DefinitionFramesEffect.xml";
            originalEffectPOints = new List<SharpDX.Vector3>();

            originalPositionSkinBlockCenter_WRS = new VectorMath.Vector3(117.5f, 2, -30.5f);

            PhysicalLengthNeedle = Properties.Settings.Default.DistanceSensorNeedleTip;
            // camera models
            CameraModelCollection = new List<string>()
            {
                Orthographic,
                Perspective,
            };

            // on camera changed callback
            CameraModelChanged += (s, e) =>
            {
                if (cameraModel == Orthographic)
                {
                    if (!(Camera is HelixToolkit.Wpf.SharpDX.OrthographicCamera))
                    {
                        Camera = defaultOrthographicCamera;
                    }
                }
                else if (cameraModel == Perspective)
                {
                    if (!(Camera is HelixToolkit.Wpf.SharpDX.PerspectiveCamera))
                    {
                        Camera = defaultPerspectiveCamera;
                    }
                }
                else
                {
                    throw new HelixToolkitException(BlockSim.Globalization.Language.str_camera_model_err);
                }
            };

            // default camera model
            CameraModel = Perspective;

            Title = BlockSim.Globalization.Language.str_demo_helix;
            SubTitle = BlockSim.Globalization.Language.str_def_base_view_mod;

            EffectsManager = new DefaultEffectsManager();

            dispatcherTimerAnimation.Interval = TimeSpan.FromMilliseconds(60);
            dispatcherTimerAnimation.Tick += new EventHandler(AnimationTick);
            ImagesBackGround.Clear();

            YawSensor01 = 0;
            PitchSensor01 = 0;
            RollSensor01 = 0;

            LastIndexSelectedCase = 0;
            LastIndexSelectedModule = 0;

            returnSteps = secondsReturn * 1000f / (float)intervalMsTimer;
            lengthVectorMeanAverage = secondsMeanAverage * 1000f / (float)intervalMsTimer;

            timerReadMouse = new DispatcherTimer();
            timerReadMouse.Interval = new TimeSpan(0, 0, 0, 0, intervalMsTimer);
            timerReadMouse.Tick += timerReadMouseTick;

            timerDeformation = new DispatcherTimer();
            timerDeformation.Interval = new TimeSpan(0, 0, 0, 0, intervalMsTimer);
            timerDeformation.Tick += timerExpansionTick;
            animator1 = new PleuralAnimator();

            animator2 = new PleuralAnimator();

            ModulesActivation = new bool[Enum.GetNames(typeof(Enum_Modules)).Length];

            for (int i = 0; i < ModulesActivation.Length; i++)
            {
                ModulesActivation[i] = false;
            }
            //Length = 200;
        }

        private delegate void BarrelEffectsDelegate();

        private void timerExpansionTick(object sender, EventArgs e)
        {
            //Trace.WriteLine((DateTime.Now - lastDeformationRunTimer).TotalMilliseconds);
            lastDeformationRunTimer = DateTime.Now;
            WindowTeacher.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority.Normal, new BarrelEffectsDelegate(ModificationEffect));
        }

        private void ModificationEffect()
        {
            bool toUpdateVertices = false;
            foreach (Deformation deformation in deformationsForNerveContinuousInjections)
            {
                switch (deformation.DefState)
                {
                    case Enum_DeformationState.TOSTART:
                        deformation.DefState = Enum_DeformationState.STARTED;
                        break;

                    case Enum_DeformationState.STARTED:
                        if (deformation.CountOp == 0)
                        {
                            deformation.ResetOriginalPositions(deformationsForNerveContinuousInjections);
                        }
                        for (int i = 0; i < deformation.SmartGridPoints.Count; i++)
                        {
                            SharpDX.Vector3 diffPoint = deformation.SmartGridPoints[i].OriginalPosition - deformation.CenterDeformation;
                            float l = diffPoint.Length();
                            diffPoint.Normalize();

                            SharpDX.Vector3 modifier = SharpDX.Vector3.Multiply(diffPoint, (float)((float)deformation.CountOp / (float)deformation.NumSteps * (float)deformation.MaxDisplacement * (float)(deformation.SizeEffect - l) / deformation.SizeEffect));

                            deformation.SmartGridPoints[i].SetNewPosition(deformation.SmartGridPoints[i].OriginalPosition + modifier);
                        }
                        deformation.CountOp++;
                        if (deformation.CountOp >= deformation.NumSteps)
                        {
                            switch (deformation.DefMode)
                            {
                                case Enum_DeformationMode.RITMIC:

                                    deformation.CountOp = 0;
                                    break;

                                case Enum_DeformationMode.ONESHOT:
                                    deformation.DefState = Enum_DeformationState.COMPLETED;
                                    break;

                                default:
                                    break;
                            }
                        }
                        UpdatePointsNerve_FullImage(deformation.SmartGridPoints);
                        toUpdateVertices = true;
                        break;

                    case Enum_DeformationState.COMPLETED:
                        break;

                    default:
                        break;
                }
            }

            if (toUpdateVertices)
            {
                Model.UpdateVertices();
            }
        }

        private delegate void MouseMoveDelegate();

        private void timerReadMouseTick(object sender, EventArgs e)
        {
            WindowStudent.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority.Normal, new MouseMoveDelegate(DisplayMouseCrd));
        }

        public static SharpDX.Point GetMousePositionWindowsForms()
        {
            System.Drawing.Point point = System.Windows.Forms.Control.MousePosition;
            return new SharpDX.Point(point.X, point.Y);
        }

        private DispatcherTimer timerReadMouse;

        ~AppControl()
        {
            // Do not change this code. Put cleanup code in Dispose(bool disposing) above.
            Dispose(false);
        }

        public int intervalMsTimer = 30;
        public float secondsMeanAverage = 0.1f;

        private bool definedPrevious = false;
        private float lengthVectorMeanAverage;

        public float offsetHeiEco = 310;

        public float offsetWidEco = 300;

        internal void AcceptValue(float valueAlignment)
        {
            if ((WindowTeacher.PageContainer.Content is WorkingFrameTeacher))
            {
                WorkingFrameTeacher wft = (WorkingFrameTeacher)WindowTeacher.PageContainer.Content;
                LimitZ = valueAlignment;
                wft.tbAlignment.Text = $"{BlockSim.Globalization.Language.str_align_slice} " + LimitZ.ToString("0.00");
                Properties.Settings.Default.LimitZ = LimitZ;
                Properties.Settings.Default.Save();
            }
        }

        private void DisplayMouseCrd()
        {
            if (NeedleAreaEffect != null)
            {
                counter++;

                float amplifyingFactorRear = .2f;
                float arrowDivider = 0.3f;
                float maximumDisplacement = 10;
                float maximumPixelDisplacement = 50;

                List<SmartGridPoint> ss = new List<SmartGridPoint>();

                if ((NedleAreaEnd.X > -Width / 2f) && (NedleAreaEnd.X < Width / 2f) && (NedleAreaEnd.Y > -Height / 2f) && (NedleAreaEnd.Y < Height / 2f))
                {
                    SharpDX.Vector3 needleNow = new SharpDX.Vector3(NedleAreaEnd.X, NedleAreaEnd.Y, -1);
                    SharpDX.Vector3 needlePrevious = new SharpDX.Vector3((float)previousPoint.X * ratio, (float)previousPoint.Y * ratio, -1);

                    SharpDX.Vector3 lateral1;
                    SharpDX.Vector3 lateral2;

                    SharpDX.Vector3 versorMovement = needleNow - needlePrevious;
                    float amplitudeMovementReal = versorMovement.Length();
                    versorMovement.Normalize();

                    SharpDX.Vector3 needlePreviousCorrected = needleNow - versorMovement * amplitudeMovementReal * amplifyingFactorRear;
                    if ((needleNow - needlePreviousCorrected).Length() > maximumDisplacement)
                    {
                        needlePreviousCorrected = needleNow - versorMovement * maximumDisplacement;
                    }

                    SharpDX.Vector3 vectorMovementCorrected = needleNow - needlePreviousCorrected;
                    float amplitudeMovementCorrected = (vectorMovementCorrected).Length();

                    if (needleNow.X != needlePreviousCorrected.X)
                    {
                        float m = (needleNow.Y - needlePreviousCorrected.Y) / (needleNow.X - needlePreviousCorrected.X);
                        float perpm = -1f / m;
                        lateral1 = new SharpDX.Vector3(1, perpm, 0); lateral1.Normalize(); lateral1 = SharpDX.Vector3.Multiply(lateral1, amplitudeMovementCorrected / arrowDivider);
                        lateral2 = new SharpDX.Vector3(-1, -perpm, 0); lateral2.Normalize(); lateral2 = SharpDX.Vector3.Multiply(lateral2, amplitudeMovementCorrected / arrowDivider);
                    }
                    else
                    {
                        lateral1 = new SharpDX.Vector3(0, amplitudeMovementCorrected / arrowDivider, 0);
                        lateral2 = new SharpDX.Vector3(0, -amplitudeMovementCorrected / arrowDivider, 0);
                    }
                    lateral1 = lateral1 + needleNow;
                    lateral2 = lateral2 + needleNow;
                    if (definedPrevious)
                    {
                        if (!viewEffect)
                        {
                            needleNow.Z = 1;
                            needlePreviousCorrected.Z = 1;
                            lateral1.Z = 1;
                            lateral2.Z = 1;
                        }

                        NeedleAreaEffect.Positions[1] = needleNow + vectorMovementCorrected;
                        NeedleAreaEffect.Positions[0] = needleNow;

                        NeedleAreaEffectPerp.Positions[1] = lateral1;
                        NeedleAreaEffectPerp.Positions[0] = lateral2;

                        NeedleAreaEffect.UpdateVertices();
                        NeedleAreaEffectPerp.UpdateVertices();

                        // find the points
                        float minX = Math.Min(Math.Min(lateral1.X, lateral2.X), (needleNow + vectorMovementCorrected).X);
                        float maxX = Math.Max(Math.Max(lateral1.X, lateral2.X), (needleNow + vectorMovementCorrected).X);
                        float minY = Math.Min(Math.Min(lateral1.Y, lateral2.Y), (needleNow + vectorMovementCorrected).Y);
                        float maxY = Math.Max(Math.Max(lateral1.Y, lateral2.Y), (needleNow + vectorMovementCorrected).Y);

                        //find the indexes of the grid
                        int minXIndex = (int)Math.Floor((minX + offsetWidEco) / BlockX); if (minXIndex < 0) minXIndex = 0;
                        int maxXIndex = (int)Math.Ceiling((maxX + offsetWidEco) / BlockX); if (maxXIndex >= NumPointsX) maxXIndex = NumPointsX - 1;
                        int minYIndex = (int)Math.Floor((minY + offsetHeiEco) / BlockY); if (minYIndex < 0) minYIndex = 0;
                        int maxYIndex = (int)Math.Ceiling((maxY + offsetHeiEco) / BlockY); if (maxYIndex >= NumPointsY) maxYIndex = NumPointsY - 1;

                        //Vector3 wingVector = lateral1 - needlePreviousCorrected;
                        SharpDX.Vector3 wingVector = lateral1 - needleNow;
                        float wingLength = wingVector.Length();

                        if (amplitudeMovementCorrected >= (BlockX / 20f))
                        {
                            for (int i = minXIndex; i <= maxXIndex; i++)
                            {
                                for (int j = minYIndex; j <= maxYIndex; j++)
                                {
                                    int index = i * NumPointsX + j;

                                    //Determine Modification
                                    SharpDX.Vector3 pointToTraslate = pointsDX[index];

                                    //Vector3 diffPoint = pointToTraslate - needlePreviousCorrected + vectorMovementCorrected;
                                    SharpDX.Vector3 diffPoint = pointToTraslate - needleNow;

                                    float diffPointLength = diffPoint.Length();

                                    float projectionToVectorMovement = SharpDX.Vector3.Dot(diffPoint, vectorMovementCorrected);

                                    float projectionToWingNormalized = Math.Abs(SharpDX.Vector3.Dot(diffPoint, wingVector)) / (diffPointLength * wingLength);

                                    SmartGridPoint sgp = new SmartGridPoint(index, pointToTraslate);
                                    SharpDX.Vector3 modifier = versorMovement * maximumPixelDisplacement * amplitudeMovementCorrected / maximumDisplacement * (1f - (float)Math.Sqrt(projectionToWingNormalized));

                                    sgp.SetNewPosition(sgp.OriginalPosition + modifier, (int)returnSteps);

                                    ss.Add(sgp);
                                }
                            }
                        }
                    }
                    else
                    {
                        definedPrevious = true;
                    }

                    previousPoints.Add(new System.Windows.Point(NedleAreaEnd.X, NedleAreaEnd.Y));
                }

                if (previousPoints.Count > lengthVectorMeanAverage)

                {
                    previousPoints.RemoveAt(0);
                }
                if (previousPoints.Count > 0)
                {
                    double x = previousPoints.Average(A => A.X);
                    double y = previousPoints.Average(A => A.Y);

                    previousPoint = new System.Windows.Point(x, y);
                }
                UpdatePointseedleEffect(ss);
                if (Model != null)
                {
                    Model.UpdateVertices();
                }
            }
        }

        internal void StopNerveCase()
        {

            WorkingFrameTeacher wft = (WorkingFrameTeacher)WindowTeacher.PageContainer.Content;
            StudentFrame sf = (StudentFrame)WindowStudent.PageContainer.Content;

            if (wft!=null)
            {
                wft.bStopTheCase.IsEnabled = false;
            }
            if (sf!=null)
            {
                sf.bStopTheCase.IsEnabled = false;
            }

            ZeroCaseIndications();

            CalculateAndShowResults();
        }

        public void UpdatePointseedleEffect(List<SmartGridPoint> smartGridPointsNew)
        {
            foreach (SmartGridPoint sgp in smartGridPointsOld)
            {
                sgp.ReturnToPosition();
                Model.Positions[sgp.Index] = sgp.CurrentPosition;
            }
            smartGridPointsOld.RemoveAll(x => x.ToDelete);

            foreach (SmartGridPoint sgp in smartGridPointsNew)
            {
                Model.Positions[sgp.Index] = sgp.CurrentPosition;
                smartGridPointsOld.Add(sgp);
            }
        }

        private System.Windows.Point previousPoint;
        private List<System.Windows.Point> previousPoints = new List<System.Windows.Point>();
        private float ratio = 1f;
        private float returnSteps = 1;
        private float secondsReturn = .5f;

        public delegate void ChangedTimerStateDelegate(bool active);

        public delegate void ReportCompletedDelegate();

        public delegate void ReportProgressDelegate(int percentage);

        private delegate void SetEnabledDelegate(UIElement lbl, bool enabled);

        private delegate void SetImageDelegate(float err);

        private delegate void SetIndicatorDelegate(System.Windows.Shapes.Ellipse bb, bool aactive);

        private delegate bool SetLineDelegate(VectorMath.Vector3 v1, VectorMath.Vector3 v2,
            VectorMath.Vector3 v1Pos, VectorMath.Vector3 v2Pos,
            VectorMath.Vector3 v1Neg, VectorMath.Vector3 v2Neg,
            float d1Pos, float d2Pos, float d1Neg, float d2Neg,
            bool allPresent, bool posPresent, bool negPresent,
            bool visibleAtEntrance);

        private delegate void SetTextDelegate(TextBlock lbl, string text);

        public event EventHandler CameraModelChanged;

        public event ChangedTimerStateDelegate ChangeTimerStateEvent;

        public event PropertyChangedEventHandler PropertyChanged;

        public static AppControl Instance
        {
            get
            {
                if (instance == null)
                {
                    instance = new AppControl();
                }
                return instance;
            }
        }

        public HelixToolkit.Wpf.SharpDX.Camera Camera
        {
            get
            {
                return camera;
            }

            protected set
            {
                SetValue(ref camera, value, "Camera");
                CameraModel = value is HelixToolkit.Wpf.SharpDX.PerspectiveCamera
                                       ? Perspective
                                       : value is HelixToolkit.Wpf.SharpDX.OrthographicCamera ? Orthographic : null;
            }
        }

        public float BlockX;
        public float BlockY;
        private LineGeometry3D needleAreaEffect;
        private LineGeometry3D needleAreaEffectPerp;
        private bool viewEffect = false;
        private HelixToolkit.Wpf.SharpDX.MeshGeometry3D modelMask;
        private HelixToolkit.Wpf.SharpDX.DiffuseMaterial modelMaterialMask;
        private List<SharpDX.Vector3> pointsCircle = new List<SharpDX.Vector3>();

        public string CameraModel
        {
            get
            {
                return cameraModel;
            }
            set
            {
                if (SetValue(ref cameraModel, value, "CameraModel"))
                {
                    OnCameraModelChanged();
                }
            }
        }

        public List<string> CameraModelCollection { get; private set; }

        public float CenterMirrorEcoImage
        {
            get
            {
                return centerMirrorEcoImage;
            }
            set
            {
                if (value != centerMirrorEcoImage)
                {
                    centerMirrorEcoImage = value;
                    RaisePropertyChanged("CenterMirrorEcoImage");
                }
            }
        }

        public Enum_DeformableAreaType DeformableAreaType { get; private set; } = Enum_DeformableAreaType.LOZANGE_ARC;

        public double DepthImage_mm
        {
            get { return depthImage; }
            set
            {
                depthImage = value;
                RaisePropertyChanged("DepthImage");
            }
        }

        public SharpDX.Vector3 DisplacementDeformableArea { get; set; }

        private SharpDX.Vector3 dispCenterCircularBlockMuscular;

        public float DistanceNeedleToFascia { get; private set; }

        public float DistanceNeedleToFasciaAtPunture { get; private set; }

        public float DistanceNeedleToFasciaAtPuntureMM { get; private set; }

        public double DistanceNeedleToFasciaAtPuntureMMLowerLimit { get; private set; }

        public double DistanceNeedleToFasciaAtPuntureMMUpperLimit { get; private set; }

        public TimeSpan DurationNeedlePhase { get; private set; }

        public bool EffectPresent { get; private set; }

        public IEffectsManager EffectsManager
        {
            get { return effectsManager; }
            protected set
            {
                SetValue(ref effectsManager, value);
            }
        }

        public Point3D EndPath
        {
            get
            {
                return endPath;
            }
            set
            {
                endPath = value;
                RaisePropertyChanged("EndPath");
            }
        }

        public bool TargetStructureAvailableInFrame { get; internal set; }

        public BitmapSource ImEcoSource
        {
            get
            {
                return imEcoSource;
            }
            set
            {
                if (value != imEcoSource)
                {
                    imEcoSource = value;
                    RaisePropertyChanged("ImEcoSource");
                }
            }
        }

        public BitmapSource ImEcoSourceTeacher
        {
            get
            {
                return imEcoSourceTeacher;
            }
            set
            {
                if (value != imEcoSourceTeacher)
                {
                    imEcoSourceTeacher = value;
                    RaisePropertyChanged("ImEcoSourceTeacher");
                }
            }
        }

        public int InsertionNeedle
        {
            get
            {
                return insertionNeedle;
            }
            set
            {
                if (insertionNeedle != value)
                {
                    insertionNeedle = value;
                    InsertionNeedleText = insertionNeedle.ToString();
                    RaisePropertyChanged("InsertionNeedle");
                }
            }
        }

        public string InsertionNeedleText
        {
            get
            {
                return insertionNeedleText;
            }
            set
            {
                if (insertionNeedleText != value)
                {
                    insertionNeedleText = value;
                    RaisePropertyChanged("InsertionNeedleText");
                }
            }
        }

        public VectorMath.Vector3 InsertionPointNeedle_WRS { get; private set; }

        public float IntervalNeedleToFascia { get; private set; }

        public float IntervalNeedleToFasciaAtPunture { get; private set; }

        public int LastIndexSelectedCase { get; internal set; }

        public int LastIndexSelectedModule { get; internal set; }
        

        public DateTime LastOrientationBlockSimArrived { get; private set; }

        public float LengthNeedle
        {
            get
            {
                return lengthNeedle;
            }
            set
            {
                lengthNeedle = value;
                RaisePropertyChanged("LengthNeedle");
            }
        }

        //public double Length
        //{
        //    get { return length; }
        //    set
        //    {
        //        length = value;
        //        RaisePropertyChanged("Length");
        //    }
        //}
        public System.Windows.Media.Brush LineColor
        {
            get
            {
                return lineColor;
            }
            set
            {
                lineColor = value;
                RaisePropertyChanged("LineColor");
            }
        }

        public System.Windows.Media.Brush LineColorEco
        {
            get
            {
                return lineColorEco;
            }
            set
            {
                lineColorEco = value;
                RaisePropertyChanged("LineColorEco");
            }
        }

        public System.Windows.Media.Brush LineColorNegative
        {
            get
            {
                return lineColorNegative;
            }
            set
            {
                lineColorNegative = value;
                RaisePropertyChanged("LineColorNegative");
            }
        }

        public System.Windows.Media.Brush LineColorPositive
        {
            get
            {
                return lineColorPositive;
            }
            set
            {
                lineColorPositive = value;
                RaisePropertyChanged("LineColorPositive");
            }
        }

        public float LineX1EcoStudent
        {
            get
            {
                return lineX1EcoStudent;
            }
            set
            {
                lineX1EcoStudent = value;
                RaisePropertyChanged("LineX1EcoStudent");
            }
        }

        public float LineX1EcoStudentNeg { get; private set; }

        public float LineX1EcoStudentPos { get; private set; }

        public float LineX1EcoTeacher
        {
            get
            {
                return lineX1EcoTeacher;
            }
            set
            {
                lineX1EcoTeacher = value;
                RaisePropertyChanged("LineX1EcoTeacher");
            }
        }

        public float LineX1EcoTeacherNegative
        {
            get
            {
                return lineX1EcoTeacherNegative;
            }
            set
            {
                lineX1EcoTeacherNegative = value;
                RaisePropertyChanged("LineX1EcoTeacherNegative");
            }
        }

        public float LineX1EcoTeacherPositive
        {
            get
            {
                return lineX1EcoTeacherPositive;
            }
            set
            {
                lineX1EcoTeacherPositive = value;
                RaisePropertyChanged("LineX1EcoTeacherPositive");
            }
        }

        public float LineX1IndicationEcoStudent
        {
            get
            {
                return lineX1IndicationEcoStudent;
            }
            set
            {
                lineX1IndicationEcoStudent = value;
                RaisePropertyChanged("LineX1IndicationEcoStudent");
            }
        }

        public float LineX1IndicationEcoTeacher
        {
            get
            {
                return lineX1IndicationEcoTeacher;
            }
            set
            {
                lineX1IndicationEcoTeacher = value;
                RaisePropertyChanged("LineX1IndicationEcoTeacher");
            }
        }

        public float LineX2EcoStudent
        {
            get
            {
                return lineX2EcoStudent;
            }
            set
            {
                lineX2EcoStudent = value;
                RaisePropertyChanged("LineX2EcoStudent");
            }
        }

        public float LineX2EcoStudentNeg { get; private set; }

        public float LineX2EcoStudentPos { get; private set; }

        public float LineX2EcoTeacher
        {
            get
            {
                return lineX2EcoTeacher;
            }
            set
            {
                lineX2EcoTeacher = value;
                RaisePropertyChanged("LineX2EcoTeacher");
            }
        }

        public float LineX2EcoTeacherNegative
        {
            get
            {
                return lineX2EcoTeacherNegative;
            }
            set
            {
                lineX2EcoTeacherNegative = value;
                RaisePropertyChanged("LineX2EcoTeacherNegative");
            }
        }

        public float LineX2EcoTeacherPositive
        {
            get
            {
                return lineX2EcoTeacherPositive;
            }
            set
            {
                lineX2EcoTeacherPositive = value;
                RaisePropertyChanged("LineX2EcoTeacherPositive");
            }
        }

        public float LineX2IndicationEcoStudent
        {
            get
            {
                return lineX2IndicationEcoStudent;
            }
            set
            {
                lineX2IndicationEcoStudent = value;
                RaisePropertyChanged("LineX2IndicationEcoStudent");
            }
        }

        public float LineX2IndicationEcoTeacher
        {
            get
            {
                return lineX2IndicationEcoTeacher;
            }
            set
            {
                lineX2IndicationEcoTeacher = value;
                RaisePropertyChanged("LineX2IndicationEcoTeacher");
            }
        }

        public float LineY1EcoStudent
        {
            get
            {
                return lineY1EcoStudent;
            }
            set
            {
                lineY1EcoStudent = value;
                RaisePropertyChanged("LineY1EcoStudent");
            }
        }

        public float LineY1EcoStudentNeg { get; private set; }

        public float LineY1EcoStudentPos { get; private set; }

        public float LineY1EcoTeacher
        {
            get
            {
                return lineY1EcoTeacher;
            }
            set
            {
                lineY1EcoTeacher = value;
                RaisePropertyChanged("LineY1EcoTeacher");
            }
        }

        public float LineY1EcoTeacherNegative
        {
            get
            {
                return lineY1EcoTeacherNegative;
            }
            set
            {
                lineY1EcoTeacherNegative = value;
                RaisePropertyChanged("LineY1EcoTeacherNegative");
            }
        }

        public float LineY1EcoTeacherPositive
        {
            get
            {
                return lineY1EcoTeacherPositive;
            }
            set
            {
                lineY1EcoTeacherPositive = value;
                RaisePropertyChanged("LineY1EcoTeacherPositive");
            }
        }

        public float LineY1IndicationEcoStudent
        {
            get
            {
                return lineY1IndicationEcoStudent;
            }
            set
            {
                lineY1IndicationEcoStudent = value;
                RaisePropertyChanged("LineY1IndicationEcoStudent");
            }
        }

        public float LineY1IndicationEcoTeacher
        {
            get
            {
                return lineY1IndicationEcoTeacher;
            }
            set
            {
                lineY1IndicationEcoTeacher = value;
                RaisePropertyChanged("LineY1IndicationEcoTeacher");
            }
        }

        public float LineY2EcoStudent
        {
            get
            {
                return lineY2EcoStudent;
            }
            set
            {
                lineY2EcoStudent = value;
                RaisePropertyChanged("LineY2EcoStudent");
            }
        }

        public float LineY2EcoStudentNeg { get; private set; }

        public float LineY2EcoStudentPos { get; private set; }

        public float LineY2EcoTeacher
        {
            get
            {
                return lineY2EcoTeacher;
            }
            set
            {
                lineY2EcoTeacher = value;
                RaisePropertyChanged("LineY2EcoTeacher");
            }
        }

        public float LineY2EcoTeacherNegative
        {
            get
            {
                return lineY2EcoTeacherNegative;
            }
            set
            {
                lineY2EcoTeacherNegative = value;
                RaisePropertyChanged("LineY2EcoTeacherNegative");
            }
        }

        public float LineY2EcoTeacherPositive
        {
            get
            {
                return lineY2EcoTeacherPositive;
            }
            set
            {
                lineY2EcoTeacherPositive = value;
                RaisePropertyChanged("LineY2EcoTeacherPositive");
            }
        }

        public float LineY2IndicationEcoStudent
        {
            get
            {
                return lineY2IndicationEcoStudent;
            }
            set
            {
                lineY2IndicationEcoStudent = value;
                RaisePropertyChanged("LineY2IndicationEcoStudent");
            }
        }

        public float LineY2IndicationEcoTeacher
        {
            get
            {
                return lineY2IndicationEcoTeacher;
            }
            set
            {
                lineY2IndicationEcoTeacher = value;
                RaisePropertyChanged("LineY2IndicationEcoTeacher");
            }
        }

        public bool LoadedCase
        {
            get
            {
                return loadedCase;
            }
            set
            {
                loadedCase = value;
                RaisePropertyChanged("LoadedCase");
            }
        }

        public bool LoadingCase { get; internal set; }

        public float MaxEffect { get; internal set; }

        public float MaximumDIstanceNeedleToFasciaPixel { get; private set; } = Properties.Settings.Default.MaxPixelDistanceAllowed;

        public float MaximumDistanceNeedleToMusclePixel { get; private set; } = Properties.Settings.Default.MaxPixelDistanceToMuscleAllowed;

        public double MinutesNeedlePhase { get; private set; }

        public float MirrorImage
        {
            get
            {
                return mirrorImage;
            }
            set
            {
                if (value != mirrorImage)
                {
                    mirrorImage = value;
                    RaisePropertyChanged("MirrorImage");
                }
            }
        }

        public HelixToolkit.Wpf.SharpDX.MeshGeometry3D Model
        {
            get
            {
                return model;
            }
            set
            {
                SetValue(ref model, value, "Model");
            }
        }

        public HelixToolkit.Wpf.SharpDX.MeshGeometry3D ModelMask
        {
            get
            {
                return modelMask;
            }
            set
            {
                SetValue(ref modelMask, value, "ModelMask");
            }
        }

        public HelixToolkit.Wpf.SharpDX.MeshGeometry3D ModelDeformableArea
        {
            get
            {
                return modelDeformableArea;
            }
            set
            {
                SetValue(ref modelDeformableArea, value, "ModelDeformableArea");
            }
        }

        public HelixToolkit.Wpf.SharpDX.DiffuseMaterial ModelMaterialMask
        {
            get
            {
                return modelMaterialMask;
            }
            set
            {
                SetValue(ref modelMaterialMask, value, "ModelMaterialMask");
            }
        }

        public HelixToolkit.Wpf.SharpDX.DiffuseMaterial ModelMaterial
        {
            get
            {
                return modelMaterial;
            }
            set
            {
                SetValue(ref modelMaterial, value, "ModelMaterial");
            }
        }

        public HelixToolkit.Wpf.SharpDX.DiffuseMaterial ModelMaterialDeformableArea
        {
            get
            {
                return modelMaterialDeformableArea;
            }
            set
            {
                SetValue(ref modelMaterialDeformableArea, value, "ModelMaterialDeformableArea");
            }
        }

        public ColorStripeMaterial ModelMaterialNeedleNegative
        {
            get
            {
                return modelMaterialNeedleNegative;
            }
            set
            {
                if (value != modelMaterialNeedleNegative)
                {
                    modelMaterialNeedleNegative = value;
                    RaisePropertyChanged("ModelMaterialNeedleNegative");
                }
            }
        }

        public ColorStripeMaterial ModelMaterialNeedlePositive
        {
            get
            {
                return modelMaterialNeedlePositive;
            }
            set
            {
                if (value != modelMaterialNeedlePositive)
                {
                    modelMaterialNeedlePositive = value;
                    RaisePropertyChanged("ModelMaterialNeedlePositive");
                }
            }
        }

        public HelixToolkit.Wpf.SharpDX.MeshGeometry3D ModelNeedleNegative
        {
            get
            {
                return modelNeedleNegative;
            }
            set
            {
                SetValue(ref modelNeedleNegative, value, "ModelNeedleNegative");
            }
        }

        public HelixToolkit.Wpf.SharpDX.MeshGeometry3D ModelNeedlePositive
        {
            get
            {
                return modelNeedlePositive;
            }
            set
            {
                SetValue(ref modelNeedlePositive, value, "ModelNeedlePositive");
            }
        }

        public HelixToolkit.Wpf.SharpDX.MeshGeometry3D ModelQuad
        {
            get
            {
                return modelQuad;
            }
            set
            {
                SetValue(ref modelQuad, value, "ModelQuad");
            }
        }

        public HelixToolkit.Wpf.SharpDX.DiffuseMaterial ModelQuadMaterial
        {
            get
            {
                return modelQuadMaterial;
            }
            set
            {
                SetValue(ref modelQuadMaterial, value, "ModelQuadMaterial");
            }
        }

        public bool NeedleAlignedCorrectly
        {
            get { return needleAlignedCorrectly; }
            set
            {
                needleAlignedCorrectly = value;
                RaisePropertyChanged("NeedleAlignedCorrectly");
            }
        }

        public bool NeedleAngleOk
        {
            get { return needleAngleOk; }
            set
            {
                needleAngleOk = value;
                RaisePropertyChanged("NeedleAngleOk");
            }
        }

        public LineGeometry3D NeedleArea
        {
            get
            {
                return needleArea;
            }
            set
            {
                SetValue(ref needleArea, value, "NeedleArea");
            }
        }

        public LineGeometry3D NeedleAreaEffect
        {
            get
            {
                return needleAreaEffect;
            }
            set
            {
                SetValue(ref needleAreaEffect, value, "NeedleAreaEffect");
            }
        }

        public LineGeometry3D NeedleAreaEffectPerp
        {
            get
            {
                return needleAreaEffectPerp;
            }
            set
            {
                SetValue(ref needleAreaEffectPerp, value, "NeedleAreaEffectPerp");
            }
        }

        public LineGeometry3D NeedleAreaIndication
        {
            get
            {
                return needleAreaIndication;
            }
            set
            {
                SetValue(ref needleAreaIndication, value, "NeedleAreaIndication");
            }
        }

        public LineGeometry3D TargetMuscularIndication
        {
            get
            {
                return targetMuscularIndication;
            }
            set
            {
                SetValue(ref targetMuscularIndication, value, "TargetMuscularIndication");
            }
        }

        public LineGeometry3D TargetNerveIndication1
        {
            get
            {
                return targetNerveIndication1;
            }
            set
            {
                SetValue(ref targetNerveIndication1, value, "TargetNerveIndication1");
            }
        }

        public LineGeometry3D TargetNerveIndication2
        {
            get
            {
                return targetNerveIndication2;
            }
            set
            {
                SetValue(ref targetNerveIndication2, value, "TargetNerveIndication2");
            }
        }

        public LineGeometry3D TargetNerveIndication3
        {
            get
            {
                return targetNerveIndication3;
            }
            set
            {
                SetValue(ref targetNerveIndication3, value, "TargetNerveIndication3");
            }
        }

        public LineGeometry3D TargetNerveIndication4
        {
            get
            {
                return targetNerveIndication4;
            }
            set
            {
                SetValue(ref targetNerveIndication4, value, "TargetNerveIndication4");
            }
        }
        public LineGeometry3D TargetNerveIndication5
        {
            get
            {
                return targetNerveIndication5;
            }
            set
            {
                SetValue(ref targetNerveIndication5, value, "TargetNerveIndication5");
            }
        }
        public LineGeometry3D TargetNerveIndication6
        {
            get
            {
                return targetNerveIndication6;
            }
            set
            {
                SetValue(ref targetNerveIndication6, value, "TargetNerveIndication6");
            }
        }
        public LineGeometry3D TargetNerveIndication7
        {
            get
            {
                return targetNerveIndication7;
            }
            set
            {
                SetValue(ref targetNerveIndication7, value, "TargetNerveIndication7");
            }
        }
        public LineGeometry3D TargetNerveIndication8
        {
            get
            {
                return targetNerveIndication8;
            }
            set
            {
                SetValue(ref targetNerveIndication8, value, "TargetNerveIndication8");
            }
        }
        public LineGeometry3D TargetNerveIndication9
        {
            get
            {
                return targetNerveIndication9;
            }
            set
            {
                SetValue(ref targetNerveIndication9, value, "TargetNerveIndication9");
            }
        }
        public LineGeometry3D TargetNerveIndication10
        {
            get
            {
                return targetNerveIndication10;
            }
            set
            {
                SetValue(ref targetNerveIndication10, value, "TargetNerveIndication10");
            }
        }
        public LineGeometry3D TargetNerveIndication11
        {
            get
            {
                return targetNerveIndication11;
            }
            set
            {
                SetValue(ref targetNerveIndication11, value, "TargetNerveIndication11");
            }
        }

        public List<LineGeometry3D> TargetsNerveIndication
        {
            get
            {
                return targetsNerveIndication;
            }
            set
            {
                SetValue(ref targetsNerveIndication, value, "TargetsNerveIndication");
            }
        }

        public LineGeometry3D NeedleAreaLine1
        {
            get
            {
                return needleAreaLine1;
            }
            set
            {
                SetValue(ref needleAreaLine1, value, "NeedleAreaLine1");
            }
        }

        public LineGeometry3D NeedleAreaLine2
        {
            get
            {
                return needleAreaLine2;
            }
            set
            {
                SetValue(ref needleAreaLine2, value, "NeedleAreaLine2");
            }
        }

        public System.Windows.Media.Color NeedleColor
        {
            get
            {
                return needleColor;
            }
            set
            {
                if (value != needleColor)
                {
                    needleColor = value;
                    RaisePropertyChanged("NeedleColor");
                }
            }
        }

        public System.Windows.Media.Color NeedleIndicationColor
        {
            get
            {
                return needleIndicationColor;
            }
            set
            {
                if (value != needleIndicationColor)
                {
                    needleIndicationColor = value;
                    RaisePropertyChanged("NeedleIndicationColor");
                }
            }
        }

        public System.Windows.Media.Color TargetMuscularIndicationColor
        {
            get
            {
                return targetMuscularIndicationColor;
            }
            set
            {
                if (value != targetMuscularIndicationColor)
                {
                    targetMuscularIndicationColor = value;
                    RaisePropertyChanged("TargetMuscularIndicationColor");
                }
            }
        }

        public System.Windows.Media.Color TargetNerveIndicationColor
        {
            get
            {
                return targetNerveIndicationColor;
            }
            set
            {
                if (value != targetNerveIndicationColor)
                {
                    targetNerveIndicationColor = value;
                    RaisePropertyChanged("TargetNerveIndicationColor");
                }
            }
        }

        public System.Windows.Media.Color TargetNerveIndicationColor1
        {
            get
            {
                return targetNerveIndicationColor1;
            }
            set
            {
                if (value != targetNerveIndicationColor1)
                {
                    targetNerveIndicationColor1 = value;
                    RaisePropertyChanged("TargetNerveIndicationColor1");
                }
            }
        }
        public System.Windows.Media.Color TargetNerveIndicationColor2
        {
            get
            {
                return targetNerveIndicationColor2;
            }
            set
            {
                if (value != targetNerveIndicationColor2)
                {
                    targetNerveIndicationColor2 = value;
                    RaisePropertyChanged("TargetNerveIndicationColor2");
                }
            }
        }
        public System.Windows.Media.Color TargetNerveIndicationColor3
        {
            get
            {
                return targetNerveIndicationColor3;
            }
            set
            {
                if (value != targetNerveIndicationColor3)
                {
                    targetNerveIndicationColor3 = value;
                    RaisePropertyChanged("TargetNerveIndicationColor3");
                }
            }
        }
        public System.Windows.Media.Color TargetNerveIndicationColor4
        {
            get
            {
                return targetNerveIndicationColor4;
            }
            set
            {
                if (value != targetNerveIndicationColor4)
                {
                    targetNerveIndicationColor4 = value;
                    RaisePropertyChanged("TargetNerveIndicationColor4");
                }
            }
        }
        public System.Windows.Media.Color TargetNerveIndicationColor5
        {
            get
            {
                return targetNerveIndicationColor5;
            }
            set
            {
                if (value != targetNerveIndicationColor5)
                {
                    targetNerveIndicationColor5 = value;
                    RaisePropertyChanged("TargetNerveIndicationColor5");
                }
            }
        }
        public System.Windows.Media.Color TargetNerveIndicationColor6
        {
            get
            {
                return targetNerveIndicationColor6;
            }
            set
            {
                if (value != targetNerveIndicationColor6)
                {
                    targetNerveIndicationColor6 = value;
                    RaisePropertyChanged("TargetNerveIndicationColor6");
                }
            }
        }
        public System.Windows.Media.Color TargetNerveIndicationColor7
        {
            get
            {
                return targetNerveIndicationColor7;
            }
            set
            {
                if (value != targetNerveIndicationColor7)
                {
                    targetNerveIndicationColor7 = value;
                    RaisePropertyChanged("TargetNerveIndicationColor7");
                }
            }
        }
        public System.Windows.Media.Color TargetNerveIndicationColor8
        {
            get
            {
                return targetNerveIndicationColor8;
            }
            set
            {
                if (value != targetNerveIndicationColor8)
                {
                    targetNerveIndicationColor8 = value;
                    RaisePropertyChanged("TargetNerveIndicationColor8");
                }
            }
        }
        public System.Windows.Media.Color TargetNerveIndicationColor9
        {
            get
            {
                return targetNerveIndicationColor9;
            }
            set
            {
                if (value != targetNerveIndicationColor9)
                {
                    targetNerveIndicationColor9 = value;
                    RaisePropertyChanged("TargetNerveIndicationColor9");
                }
            }
        }
        public System.Windows.Media.Color TargetNerveIndicationColor10
        {
            get
            {
                return targetNerveIndicationColor10;
            }
            set
            {
                if (value != targetNerveIndicationColor10)
                {
                    targetNerveIndicationColor10 = value;
                    RaisePropertyChanged("TargetNerveIndicationColor10");
                }
            }
        }
        public System.Windows.Media.Color TargetNerveIndicationColor11
        {
            get
            {
                return targetNerveIndicationColor11;
            }
            set
            {
                if (value != targetNerveIndicationColor11)
                {
                    targetNerveIndicationColor11 = value;
                    RaisePropertyChanged("TargetNerveIndicationColor11");
                }
            }
        }

        public bool NeedleTargetedFascia { get; private set; }

        public System.Windows.Media.Color NeedleTipIndicationColor
        {
            get
            {
                return needleTipIndicationColor;
            }
            set
            {
                if (value != needleTipIndicationColor)
                {
                    needleTipIndicationColor = value;
                    RaisePropertyChanged("NeedleTipIndicationColor");
                }
            }
        }

        public System.Windows.Media.Color NeedleTipIndicationColorInPlane { get; private set; }

        public System.Windows.Media.Color NeedleTipIndicationColorOutPlane { get; private set; }

        public bool NeedleTipOnPlane
        {
            get { return needleTipOnPlane; }
            set
            {
                needleTipOnPlane = value;
                RaisePropertyChanged("NeedleTipOnPlane");
            }
        }

        public string OrientationBlockSim { get; private set; }

        public Point3D OriginPlaneImage
        {
            get { return originPlaneImage; }
            set
            {
                originPlaneImage = value;
                RaisePropertyChanged("OriginPlaneImage");
            }
        }

        public StudentFrame PageStudent { get; internal set; }

        public double PitchSensor01
        {
            get { return pitchSensor01; }
            set
            {
                pitchSensor01 = value;
                RaisePropertyChanged("PitchSensor01");
            }
        }

        public double PitchSensor02
        {
            get { return pitchSensor02; }
            set
            {
                pitchSensor02 = value;
                RaisePropertyChanged("PitchSensor02");
            }
        }

        public bool EffectFasciaHitActivated { get; internal set; }
        public bool EffectNerveHitActivated { get; internal set; }

        public float RatioVisualizationMMperPixel { get; private set; } = 10;

        public double RollSensor01
        {
            get { return rollSensor01; }
            set
            {
                rollSensor01 = value;
                RaisePropertyChanged("RollSensor01");
            }
        }

        //    set
        //    {
        //        this.points = value;
        //        this.RaisePropertyChanged("Points");
        //    }
        //}
        public double RollSensor02
        {
            get { return rollSensor02; }
            set
            {
                rollSensor02 = value;
                RaisePropertyChanged("RollSensor02");
            }
        }

        //public Point3DCollection Points
        //{
        //    get
        //    {
        //        return this.points;
        //    }
        public System.Windows.Media.Media3D.Quaternion RotationNeedle_WRS_real
        {
            get { return rotationNeedle_WRS_m; }
            set
            {
                rotationNeedle_WRS_m = value;
                RaisePropertyChanged("RotationNeedle_WRS_real");
            }
        }

        public System.Windows.Media.Media3D.Quaternion RotationNeedle_WRS_WhenInsertion { get; private set; }

        public System.Windows.Media.Media3D.Quaternion RotationOperableEnsamble
        {
            get { return rotationOperableEnsamble; }
            set
            {
                rotationOperableEnsamble = value;
                RaisePropertyChanged("RotationOperableEnsamble");
            }
        }

        public System.Windows.Media.Media3D.Quaternion RotationProbe_WRS
        {
            get { return rotationProbe_WRS_m; }
            set
            {
                rotationProbe_WRS_m = value;
                RaisePropertyChanged("RotationProbe_WRS");
            }
        }

        //public System.Windows.Media.Media3D.Quaternion RotationSkinBlock
        //{
        //    get { return rotationSkinBlock; }
        //    set
        //    {
        //        rotationSkinBlock = value;
        //        RaisePropertyChanged("RotationSkinBlock");
        //    }
        //}

        public System.Windows.Media.Media3D.Quaternion RotationSensor01_WRS
        {
            get { return rotationSensor01_WRS_m; }
            set
            {
                rotationSensor01_WRS_m = value;
                RaisePropertyChanged("RotationSensor01_WRS");
            }
        }

        //public bool ShowFasciaFrames
        //{
        //    get { return showFasciaFrames; }
        //    set
        //    {
        //        showFasciaFrames = value;
        //        RaisePropertyChanged("ShowFasciaFrames");
        //    }
        //}

        public bool ShowTargetPosition
        {
            get { return showTargetPosition; }
            set
            {
                showTargetPosition = value;
                RaisePropertyChanged("ShowTargetPosition");
            }
        }

        public bool ShowIndicationNeedle
        {
            get { return showIndicationNeedle; }
            set
            {
                showIndicationNeedle = value;
                RaisePropertyChanged("ShowIndicationNeedle");
            }
        }

        public bool ShowInfoToStudent { get; internal set; } = false;

        public DateTime StartNeedlePhaseTime { get; private set; }

        public Point3D StartPath
        {
            get
            {
                return startPath;
            }
            set
            {
                startPath = value;
                RaisePropertyChanged("StartPath");
            }
        }

        public Point3D CollidePointProbe
        {
            get
            {
                return collidePointProbe;
            }
            set
            {
                collidePointProbe = value;
                RaisePropertyChanged("CollidePointProbe");
            }
        }

        public bool ProbeHits { get; private set; }
        public DateTime LastCollisionProbeDetected { get; private set; }

        public bool VisibilityProbeCollisionCheck
        {
            get
            {
                return visibilityProbeCollisionCheck;
            }
            set
            {
                visibilityProbeCollisionCheck = value;
                RaisePropertyChanged("VisibilityProbeCollisionCheck");
            }
        }

        public bool VisibilityNeedleCollisionCheck
        {
            get
            {
                return visibilityNeedleCollisionCheck;
            }
            set
            {
                visibilityNeedleCollisionCheck = value;
                RaisePropertyChanged("VisibilityNeedleCollisionCheck");
            }
        }

        public bool NeedleHits { get; private set; }

        public Point3D CollidePointNeedle
        {
            get
            {
                return collidePointNeedle;
            }
            set
            {
                collidePointNeedle = value;
                RaisePropertyChanged("CollidePointNeedle");
            }
        }

        public DateTime LastCollisionNeedleDetected { get; private set; }

        public string SubTitle
        {
            get
            {
                return subTitle;
            }
            set
            {
                SetValue(ref subTitle, value, "SubTitle");
            }
        }

        public string TextFasciaTarget
        {
            get { return textFasciaTarget; }
            set
            {
                textFasciaTarget = value;
                RaisePropertyChanged("TextFasciaTarget");
            }
        }

        public string TextWrongInjections
        {
            get { return textWrongInjections; }
            set
            {
                textWrongInjections = value;
                RaisePropertyChanged("TextWrongInjections");
            }
        }

        public string TextNerveTarget
        {
            get { return textNerveTarget; }
            set
            {
                textNerveTarget = value;
                RaisePropertyChanged("TextNerveTarget");
            }
        }

        public string TextNerveWrong
        {
            get { return textNerveWrong; }
            set
            {
                textNerveWrong = value;
                RaisePropertyChanged("TextNerveWrong");
            }
        }

        public string TextVascularWrong
        {
            get { return textVascularWrong; }
            set
            {
                textVascularWrong = value;
                RaisePropertyChanged("TextVascularWrong");
            }
        }

        public string TextFasciaTargetExp
        {
            get { return textFasciaTargetExp; }
            set
            {
                textFasciaTargetExp = value;
                RaisePropertyChanged("TextFasciaTargetExp");
            }
        }

        public string TextNerveTargetExp
        {
            get { return textNerveTargetExp; }
            set
            {
                textNerveTargetExp = value;
                RaisePropertyChanged("TextNerveTargetExp");
            }
        }

        public string TextNerveWrongExp
        {
            get { return textNerveWrongExp; }
            set
            {
                textNerveWrongExp = value;
                RaisePropertyChanged("TextNerveWrongExp");
            }
        }


        public string TextNerveWrongIntro
        {
            get { return textNerveWrongIntro; }
            set
            {
                textNerveWrongIntro = value;
                RaisePropertyChanged("TextNerveWrongIntro");
            }
        }

        public string TextVascularWrongIntro
        {
            get { return textVascularWrongIntro; }
            set
            {
                textVascularWrongIntro = value;
                RaisePropertyChanged("TextVascularWrongIntro");
            }
        }


        public string TextVascularWrongExp
        {
            get { return textVascularWrongExp; }
            set
            {
                textVascularWrongExp = value;
                RaisePropertyChanged("TextVascularWrongExp");
            }
        }



        public string TextWrongInjectionsExp
        {
            get { return textWrongInjectionsExp; }
            set
            {
                textWrongInjectionsExp = value;
                RaisePropertyChanged("TextWrongInjectionsExp");
            }
        }

        public string TextNeedlePuntures
        {
            get { return textNeedlePuntures; }
            set
            {
                textNeedlePuntures = value;
                RaisePropertyChanged("TextNeedlePuntures");
            }
        }

        public string TextNeedlePunturesExp
        {
            get { return textNeedlePunturesExp; }
            set
            {
                textNeedlePunturesExp = value;
                RaisePropertyChanged("TextNeedlePunturesExp");
            }
        }

        public string TextScore
        {
            get { return textScore; }
            set
            {
                textScore = value;
                RaisePropertyChanged("TextScore");
            }
        }

        public string TextTime
        {
            get { return textTime; }
            set
            {
                textTime = value;
                RaisePropertyChanged("TextTime");
            }
        }

        public string TextTimeExp
        {
            get { return textTimeExp; }
            set
            {
                textTimeExp = value;
                RaisePropertyChanged("TextTimeExp");
            }
        }

        public bool TipInVisiblePlane { get; private set; }

        public string Title
        {
            get
            {
                return title;
            }
            set
            {
                SetValue(ref title, value, "Title");
            }
        }

        public bool UpperOrLowerLine { get; private set; }

        public SharpDX.Vector3 Vector2CentralPoint { get; private set; }

        public Visibility VisibilityBorderArrowDown
        {
            get
            {
                return visibilityBorderArrowDown;
            }
            set
            {
                if (value != visibilityBorderArrowDown)
                {
                    visibilityBorderArrowDown = value;
                    RaisePropertyChanged("VisibilityBorderArrowDown");
                }
            }
        }

        public Visibility VisibilityBorderArrowLeft
        {
            get
            {
                return visibilityBorderArrowLeft;
            }
            set
            {
                if (value != visibilityBorderArrowLeft)
                {
                    visibilityBorderArrowLeft = value;
                    RaisePropertyChanged("VisibilityBorderArrowLeft");
                }
            }
        }

        public Visibility VisibilityBorderArrowRight
        {
            get
            {
                return visibilityBorderArrowRight;
            }
            set
            {
                if (value != visibilityBorderArrowRight)
                {
                    visibilityBorderArrowRight = value;
                    RaisePropertyChanged("VisibilityBorderArrowRight");
                }
            }
        }

        public Visibility VisibilityBorderArrowRotation
        {
            get
            {
                return visibilityBorderArrowRotation;
            }
            set
            {
                if (value != visibilityBorderArrowRotation)
                {
                    visibilityBorderArrowRotation = value;
                    RaisePropertyChanged("VisibilityBorderArrowRotation");
                }
            }
        }

        public Visibility VisibilityBorderArrowRotation2
        {
            get
            {
                return visibilityBorderArrowRotation2;
            }
            set
            {
                if (value != visibilityBorderArrowRotation2)
                {
                    visibilityBorderArrowRotation2 = value;
                    RaisePropertyChanged("VisibilityBorderArrowRotation2");
                }
            }
        }

        public Visibility VisibilityBorderArrowUp
        {
            get
            {
                return visibilityBorderArrowUp;
            }
            set
            {
                if (value != visibilityBorderArrowUp)
                {
                    visibilityBorderArrowUp = value;
                    RaisePropertyChanged("VisibilityBorderArrowUp");
                }
            }
        }

        public Visibility VisibilityLogoOnStudentPage
        {
            get
            {
                return visibilityLogoOnStudentPage;
            }
            set
            {
                if (value != visibilityLogoOnStudentPage)
                {
                    visibilityLogoOnStudentPage = value;
                    RaisePropertyChanged("VisibilityLogoOnStudentPage");
                }
            }
        }

        public Visibility VisibilityResults
        {
            get
            {
                return visibilityResults;
            }
            set
            {
                if (value != visibilityResults)
                {
                    visibilityResults = value;
                    RaisePropertyChanged("VisibilityResults");
                }
            }
        }

        public Visibility VisibilityViewEcoImage
        {
            get
            {
                return visibilityViewEcoImage;
            }
            set
            {
                if (value != visibilityViewEcoImage)
                {
                    visibilityViewEcoImage = value;
                    RaisePropertyChanged("VisibilityViewEcoImage");
                }
            }
        }

        public Visibility VisibilityViewEcoSharpDX
        {
            get
            {
                return visibilityViewEcoSharpDX;
            }
            set
            {
                if (value != visibilityViewEcoSharpDX)
                {
                    visibilityViewEcoSharpDX = value;
                    RaisePropertyChanged("VisibilityViewEcoSharpDX");
                }
            }
        }

        public Visibility VisibleIndicationLine
        {
            get
            {
                return visibleIndicationLine;
            }
            set
            {
                if (value != visibleIndicationLine)
                {
                    visibleIndicationLine = value;
                    RaisePropertyChanged("VisibleIndicationLine");
                }
            }
        }

        public Visibility VisibleLine
        {
            get
            {
                return visibleLine;
            }
            set
            {
                if (value != visibleLine)
                {
                    visibleLine = value;
                    RaisePropertyChanged("VisibleLine");
                }
            }
        }

        public Visibility VisibleLineNegative
        {
            get
            {
                return visibleLineNegative;
            }
            set
            {
                if (value != visibleLineNegative)
                {
                    visibleLineNegative = value;
                    RaisePropertyChanged("VisibleLineNegative");
                }
            }
        }

        public Visibility VisibleLinePositive
        {
            get
            {
                return visibleLinePositive;
            }
            set
            {
                if (value != visibleLinePositive)
                {
                    visibleLinePositive = value;
                    RaisePropertyChanged("VisibleLinePositive");
                }
            }
        }

        public Visibility VisibleNeedleTipIndication
        {
            get
            {
                return visibleNeedleTipIndication;
            }
            set
            {
                if (value != visibleNeedleTipIndication)
                {
                    visibleNeedleTipIndication = value;
                    RaisePropertyChanged("VisibleNeedleTipIndication");
                }
            }
        }

        public bool VisibleProbePlaneAntenna
        {
            get
            {
                return visibleProbePlaneAntenna;
            }
            set
            {
                if (value != visibleProbePlaneAntenna)
                {
                    visibleProbePlaneAntenna = value;
                    RaisePropertyChanged("VisibleProbePlaneAntenna");
                }
            }
        }

        public double WidthImage_mm
        {
            get { return widthImage; }
            set
            {
                widthImage = value;
                RaisePropertyChanged("WidthImage");
            }
        }

        public WindowStudent WindowStudent { get; internal set; }

        public WindowTeacher WindowTeacher { get; internal set; }

        public WorkingFrameTeacher WorkingFrame { get; internal set; }

        public float XPosOperableEnsamble
        {
            get
            {
                return xPosOperableEnsamble;
            }
            set
            {
                xPosOperableEnsamble = value;
                RaisePropertyChanged("XPosOperableEnsamble");
            }
        }

        //public BackgroundWorker Worker { get; private set; }
        public float XPosProbeCenter
        {
            get
            {
                return xPosProbeCenter;
            }
            set
            {
                xPosProbeCenter = value;
                RaisePropertyChanged("XPosProbeCenter");
            }
        }

        public float XPosProbeEdge
        {
            get
            {
                return xPosProbeEdge;
            }
            set
            {
                xPosProbeEdge = value;
                RaisePropertyChanged("XPosProbeEdge");
            }
        }

        //public float XPosSkinBlock
        //{
        //    get
        //    {
        //        return xPosSkinBlock;
        //    }
        //    set
        //    {
        //        xPosSkinBlock = value;
        //        RaisePropertyChanged("XPosSkinBlock");
        //    }
        //}

        //public float YPosSkinBlock
        //{
        //    get
        //    {
        //        return yPosSkinBlock;
        //    }
        //    set
        //    {
        //        yPosSkinBlock = value;
        //        RaisePropertyChanged("YPosSkinBlock");
        //    }
        //}

        //public float ZPosSkinBlock
        //{
        //    get
        //    {
        //        return zPosSkinBlock;
        //    }
        //    set
        //    {
        //        zPosSkinBlock = value;
        //        RaisePropertyChanged("ZPosSkinBlock");
        //    }
        //}
        public float XPosSensor01
        {
            get
            {
                return xPosSensor01;
            }
            set
            {
                xPosSensor01 = value;
                RaisePropertyChanged("XPosSensor01");
            }
        }

        public float XPosSensor02
        {
            get
            {
                return xPosSensor02;
            }
            set
            {
                xPosSensor02 = value;
                RaisePropertyChanged("XPosSensor02");
            }
        }

        public float XTipNeedle
        {
            get
            {
                return xTipNeedle;
            }
            set
            {
                xTipNeedle = value;
                RaisePropertyChanged("XTipNeedle");
            }
        }

        public double YawSensor01
        {
            get { return yawSensor01; }
            set
            {
                yawSensor01 = value;
                RaisePropertyChanged("YawSensor01");
            }
        }

        public double YawSensor02
        {
            get { return yawSensor02; }
            set
            {
                yawSensor02 = value;
                RaisePropertyChanged("YawSensor02");
            }
        }

        public float YPosOperableEnsamble
        {
            get
            {
                return yPosOperableEnsamble;
            }
            set
            {
                yPosOperableEnsamble = value;
                RaisePropertyChanged("YPosOperableEnsamble");
            }
        }

        public float YPosProbeCenter
        {
            get
            {
                return yPosProbeCenter;
            }
            set
            {
                yPosProbeCenter = value;
                RaisePropertyChanged("YPosProbeCenter");
            }
        }

        public float YPosProbeEdge
        {
            get
            {
                return yPosProbeEdge;
            }
            set
            {
                yPosProbeEdge = value;
                RaisePropertyChanged("YPosProbeEdge");
            }
        }

        public float YPosSensor01
        {
            get
            {
                return yPosSensor01;
            }
            set
            {
                yPosSensor01 = value;
                RaisePropertyChanged("YPosSensor01");
            }
        }

        public float YPosSensor02
        {
            get
            {
                return yPosSensor02;
            }
            set
            {
                yPosSensor02 = value;
                RaisePropertyChanged("YPosSensor02");
            }
        }

        public float YTipNeedle
        {
            get
            {
                return yTipNeedle;
            }
            set
            {
                yTipNeedle = value;
                RaisePropertyChanged("YTipNeedle");
            }
        }

        public float ZPosOperableEnsamble
        {
            get
            {
                return zPosOperableEnsamble;
            }
            set
            {
                zPosOperableEnsamble = value;
                RaisePropertyChanged("ZPosOperableEnsamble");
            }
        }

        public float ZPosProbeCenter
        {
            get
            {
                return zPosProbeCenter;
            }
            set
            {
                zPosProbeCenter = value;
                RaisePropertyChanged("ZPosProbeCenter");
            }
        }

        public float ZPosProbeEdge
        {
            get
            {
                return zPosProbeEdge;
            }
            set
            {
                zPosProbeEdge = value;
                RaisePropertyChanged("ZPosProbeEdge");
            }
        }

        public float ZPosSensor01
        {
            get
            {
                return zPosSensor01;
            }
            set
            {
                zPosSensor01 = value;
                RaisePropertyChanged("ZPosSensor01");
            }
        }

        public float ZPosSensor02
        {
            get
            {
                return zPosSensor02;
            }
            set
            {
                zPosSensor02 = value;
                RaisePropertyChanged("ZPosSensor02");
            }
        }

        public float ZTipNeedle
        {
            get
            {
                return zTipNeedle;
            }
            set
            {
                zTipNeedle = value;
                RaisePropertyChanged("ZTipNeedle");
            }
        }

        public bool ToElaborateData { get; set; } = false;
        public int IndexRealFinishNeedle { get; internal set; }
        public string CurrentModel { get; internal set; }
        public DateTime TimeElapseForImageChange { get; private set; }
        public int TargetMissedNerve_Injections { get; private set; }
        public DateTime LastTimeInjection { get; private set; }

        public void CloseApp(bool forceClose = false)
        {
            if (WindowTeacher != null)
            {
                if (forceClose || MessageBox.Show(BlockSim.Globalization.Language.str_close_blocksim, true, 1000, false))
                {
                    if (CurrentTeacher != null)
                    {
                        Properties.Settings.Default.LastValidTeacherIndex = (int)CurrentTeacher.Id;
                        if (CurrentStudent != null)
                        {
                            Properties.Settings.Default.LastValidStudentIndex = (int)CurrentStudent.Id;
                        }
                        else
                        {
                            Properties.Settings.Default.LastValidStudentIndex = -1;
                        }
                    }
                    else
                    {
                        Properties.Settings.Default.LastValidTeacherIndex = -1;
                    }
                    if (CurrentEvent != null)
                    {
                        Properties.Settings.Default.LastValidEventIndex = (int)CurrentEvent.Id;
                    }
                    else
                    {
                        Properties.Settings.Default.LastValidEventIndex = -1;
                    }
                    Properties.Settings.Default.Save();
                    WindowTeacher.Close();
                }
            }
        }

        public static BitmapImage Convert(System.Drawing.Image img)
        {
            using (var memory = new MemoryStream())
            {
                img.Save(memory, ImageFormat.Png);
                memory.Position = 0;

                var bitmapImage = new BitmapImage();
                bitmapImage.BeginInit();
                bitmapImage.StreamSource = memory;
                bitmapImage.CacheOption = BitmapCacheOption.OnLoad;
                bitmapImage.EndInit();

                return bitmapImage;
            }
        }

        // To detect redundant calls
        public void Dispose()
        {
            // Do not change this code. Put cleanup code in Dispose(bool disposing) above.
            Dispose(true);
            // TODO: uncomment the following line if the finalizer is overridden above.
            // GC.SuppressFinalize(this);
        }

        public void Init()
        {
            Assembly assembly = Assembly.GetExecutingAssembly();
            FileVersionInfo fvi = FileVersionInfo.GetVersionInfo(assembly.Location);
            string version = fvi.ProductVersion;

            DBConnector.Instance.InitDB("C:\\BlockSim\\Database\\BlockSimDB.db");
            pDIClass = new PDIClass();
            AppControl.Instance.PopulateAvailableCases();

            NeedleTipIndicationColorInPlane = System.Windows.Media.Color.FromArgb(255, 0, 255, 255);
            NeedleTipIndicationColorOutPlane = System.Windows.Media.Color.FromArgb(255, 150, 150, 150);
            AppControl.Instance.LimitZ = Properties.Settings.Default.LimitZ;

            // COLLIDR THINGS
            /// COLLIDER STUFF
            System.Windows.Media.Media3D.Quaternion RotationOperableEnsambleCOLLIDER_HRS = new System.Windows.Media.Media3D.Quaternion();

            Vector3D axisc4 = new Vector3D(0, 1, 0);
            double anglec4 = 180;
            RotationOperableEnsambleCOLLIDER_HRS = System.Windows.Media.Media3D.Quaternion.Multiply(RotationOperableEnsambleCOLLIDER_HRS, new System.Windows.Media.Media3D.Quaternion(axisc4, anglec4));

            Vector3D axisc3 = new Vector3D(1, 0, 0);
            double anglec3 = -90;
            RotationOperableEnsambleCOLLIDER_HRS = System.Windows.Media.Media3D.Quaternion.Multiply(RotationOperableEnsambleCOLLIDER_HRS, new System.Windows.Media.Media3D.Quaternion(axisc3, anglec3));

            Vector3D axisc2 = new Vector3D(0, 1, 0);
            double anglec2 = 90;
            RotationOperableEnsambleCOLLIDER_HRS = System.Windows.Media.Media3D.Quaternion.Multiply(RotationOperableEnsambleCOLLIDER_HRS, new System.Windows.Media.Media3D.Quaternion(axisc2, anglec2));

            VectorMath.Quaternion rotationQuaternion_WRS_TO_HRS_VectorMath = Calculator.Instance.GetQuatFromMedia3D(RotationOperableEnsambleCOLLIDER_HRS);
            rotMatrix_Collider_TO_HRS = Calculator.Instance.GetRotationMatrix(VectorMath.Matrix.RotationQuaternion(Calculator.Instance.GetQuatFromMedia3D(RotationOperableEnsambleCOLLIDER_HRS)));
            rotMatrix_HRS_TO_Collider = Calculator.Instance.TrasposeMatrix(rotMatrix_Collider_TO_HRS);
        }

        private double[,] rotMatrix_Collider_TO_HRS;
        private double[,] rotMatrix_HRS_TO_Collider;

        public void InitializeCurrentTeacherStudentEvent()
        {
            if (Properties.Settings.Default.RememberLastValidTeacher)
            {
                if (Properties.Settings.Default.LastValidTeacherIndex > -1)
                {
                    List<Users> users = DBConnector.Instance.FindAll<Users>().ToList();
                    var teach = from db in users where db.Id == Properties.Settings.Default.LastValidTeacherIndex && db.Role > 0 select db;
                    if (teach.Count() > 0)
                    {
                        SelectTeacher((Users)teach.First());
                        if (Properties.Settings.Default.LastValidStudentIndex > -1)
                        {
                            var stud = from db in users where db.Id == Properties.Settings.Default.LastValidStudentIndex && db.Role == 0 && db.IdParentUser == CurrentTeacher.Id select db;
                            if (stud.Count() > 0)
                            {
                                SelectStudent((Users)stud.First());
                            }
                        }
                    }
                }
            }
            if (Properties.Settings.Default.LastValidEventIndex > -1)
            {
                Events ev = DBConnector.Instance.FindRowById<Events>(new BsonValue((int)Properties.Settings.Default.LastValidEventIndex));
                if (ev != null)
                {
                    SelectEvent(ev);
                }
            }
        }

        public Stream LoadTexture(string file)
        {
            var bytecode = global::SharpDX.IO.NativeFile.ReadAllBytes(file);
            return new MemoryStream(bytecode);
        }

        //private void ChangeBackgroundTick(object sender, EventArgs e)
        //{
        //    counterImage++;
        //    if (counterImage >= imagesBackGround.Count)
        //    {
        //        counterImage = 0;
        //    }
        //    ModelMaterial.DiffuseMap = imagesBackGround[counterImage];
        //}
        public Stream LoadTextureCorrected(string file)
        {
            System.IO.FileStream fs = new System.IO.FileStream(file, System.IO.FileMode.Open, System.IO.FileAccess.Read);
            System.IO.MemoryStream ms = new System.IO.MemoryStream();
            fs.CopyTo(ms);
            return fs;
        }

        public void LogOut()
        {
            SelectStudent(null);
            SelectTeacher(null);
        }

        public void PopulateAvailableCases()
        {
            // find all available cases
            Cases.Clear();

            var directories = Directory.GetDirectories(AppControl.CasesFolder);
            foreach (string s in directories)
            {
                CaseStructure cs = new CaseStructure(s);

                Cases.Add(cs);
            }
        }

        public void Prepare_HRS(Enum_Configuration caseStudio)
        {
            try
            {
                rotationQuaternion_WRS_TO_HRS = new System.Windows.Media.Media3D.Quaternion();
                switch (caseStudio)
                {
                    case Enum_Configuration.STUDIO: //OK

                        #region STUDIO

                        {
                            var axis2 = new Vector3D(0, 1, 0);
                            var angle2 = -90;
                            rotationQuaternion_WRS_TO_HRS = System.Windows.Media.Media3D.Quaternion.Multiply(new System.Windows.Media.Media3D.Quaternion(axis2, angle2), rotationQuaternion_WRS_TO_HRS);
                            var axis3 = new Vector3D(0, 0, 1);
                            var angle3 = 180;
                            rotationQuaternion_WRS_TO_HRS = System.Windows.Media.Media3D.Quaternion.Multiply(new System.Windows.Media.Media3D.Quaternion(axis3, angle3), rotationQuaternion_WRS_TO_HRS);
                            break;
                        }

                    #endregion STUDIO

                    case Enum_Configuration.PARAVERTEBRAL: // OK

                        #region PARAVERTEBRAL

                        {
                            var axis6 = new Vector3D(0, 0, 1);
                            var angle6 = 90;
                            rotationQuaternion_WRS_TO_HRS = System.Windows.Media.Media3D.Quaternion.Multiply(new System.Windows.Media.Media3D.Quaternion(axis6, angle6), rotationQuaternion_WRS_TO_HRS);
                            var axis7 = new Vector3D(0, 1, 0);
                            var angle7 = 90;
                            rotationQuaternion_WRS_TO_HRS = System.Windows.Media.Media3D.Quaternion.Multiply(new System.Windows.Media.Media3D.Quaternion(axis7, angle7), rotationQuaternion_WRS_TO_HRS);
                            break;
                        }

                    #endregion PARAVERTEBRAL

                    case Enum_Configuration.TAP:

                        #region TAP

                        {
                            var axis5 = new Vector3D(0, 1, 0);
                            var angle5 = 90;
                            rotationQuaternion_WRS_TO_HRS = System.Windows.Media.Media3D.Quaternion.Multiply(new System.Windows.Media.Media3D.Quaternion(axis5, angle5), rotationQuaternion_WRS_TO_HRS);
                            break;
                        }

                    #endregion TAP

                    case Enum_Configuration.PECS1:
                    case Enum_Configuration.PECS2:
                    case Enum_Configuration.ESP:
                    case Enum_Configuration.LUMBAR:
                    case Enum_Configuration.PARASTERNAL:
                    case Enum_Configuration.QLB:
                    case Enum_Configuration.SERRATUM:
                    case Enum_Configuration.N_AXILLARY_BP:
                    case Enum_Configuration.N_ADDUCTORCANAL:
                    case Enum_Configuration.N_LUMBARPLEXUS:
                    case Enum_Configuration.N_INTERSCALENE_BP:
                    case Enum_Configuration.N_INFRACLAVICULAR:
                    case Enum_Configuration.N_SUPRACLAVICULAR:
                    case Enum_Configuration.FASCIAILIACA: // OK
                    case Enum_Configuration.N_FEMURAL: // OK
                    case Enum_Configuration.N_SCIATIC_GLUTEAL: // OK
                    case Enum_Configuration.N_SCIATIC_POPLITEAL: // OK
                        {
                            var axis5 = new Vector3D(0, 1, 0);
                            var angle5 = 90;
                            rotationQuaternion_WRS_TO_HRS = System.Windows.Media.Media3D.Quaternion.Multiply(new System.Windows.Media.Media3D.Quaternion(axis5, angle5), rotationQuaternion_WRS_TO_HRS);

                            break;
                        }

                    default:
                        break;
                }
                rotationQuaternion_WRS_TO_HRS_VectorMath = Calculator.Instance.GetQuatFromMedia3D(rotationQuaternion_WRS_TO_HRS);
                rotationMatrix_WRS_TO_HRS = Calculator.Instance.GetRotationMatrix(VectorMath.Matrix.RotationQuaternion(Calculator.Instance.GetQuatFromMedia3D(rotationQuaternion_WRS_TO_HRS)));
                RotationMatrix_HRS_TO_WRS = Calculator.Instance.TrasposeMatrix(rotationMatrix_WRS_TO_HRS);
                CenterOfWRS_inHRS = Calculator.Instance.ChangeCoordinatesOfAPoint(new VectorMath.Vector3(0, 0, 0), originalPositionSkinBlockCenter_WRS, rotationMatrix_WRS_TO_HRS);
            }
            catch (Exception)
            {
            }
        }

        //        var directories = Directory.GetDirectories(AppControl.CasesFolder);
        //        foreach (string s in directories)
        //        {
        //            CaseStructure cs = new CaseStructure(s);
        //            if (cs.LoadCaseDescriptor())
        //            {
        //                Cases.Add(cs);
        //            }
        //        }
        public void RaisePropertyChanged(string property)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            {
                handler(this, new PropertyChangedEventArgs(property));
            }
        }

        //public void PopulateAvailableCases()
        //{
        //    if ((WindowTeacher.PageContainer.Content is WorkingFrameTeacher))
        //    {
        //        WorkingFrameTeacher wft = (WorkingFrameTeacher)WindowTeacher.PageContainer.Content;
        //        // find all available cases
        //        Cases.Clear();
        public void ResetPoints()
        {
            index_points_to_move.Clear();
        }

        public void RotoTraslateEnsambleOnHumanModel(Enum_Configuration configur)
        {
            if ((WindowTeacher.PageContainer.Content is WorkingFrameTeacher))
            {
                WorkingFrameTeacher wft = (WorkingFrameTeacher)WindowTeacher.PageContainer.Content;

                Point3D pointSkinBlockCenter = new Point3D();

                Point3D pointAntenna = new Point3D();
                VectorMath.Vector3 rotTrasl = new VectorMath.Vector3();
                Vector3D axis2 = new Vector3D();
                double angle2 = 0;
                Vector3D axis3 = new Vector3D();
                double angle3 = 0;
                switch (configur)
                {
                    case Enum_Configuration.STUDIO: //OK

                        #region STUDIO

                        {
                            RotationOperableEnsamble = new System.Windows.Media.Media3D.Quaternion();

                            pointSkinBlockCenter = Calculator.Instance.GiveMePoint3D(-originalPositionSkinBlockCenter_WRS);

                            pointAntenna = pointSkinBlockCenter + Calculator.Instance.GiveMeVector3D(originalPositionSkinBlockCenter_WRS);

                            rotTrasl = GiveMeRotationRelativeAntenna(RotationOperableEnsamble);

                            wft.hvView3D.CameraController.CameraUpDirection = new Vector3D(-0.707, 0, -0.707);
                            wft.hvView3D.CameraController.CameraLookDirection = new Vector3D(-0.707, 0, 0.707);
                            wft.hvView3D.CameraController.CameraPosition = new Point3D(pointAntenna.X + 500 + rotTrasl.X, pointAntenna.Y + rotTrasl.Y, pointAntenna.Z + rotTrasl.Z - 500);

                            XPosOperableEnsamble = (float)pointAntenna.X;
                            YPosOperableEnsamble = (float)pointAntenna.Y;
                            ZPosOperableEnsamble = (float)pointAntenna.Z;
                            break;
                        }

                    #endregion STUDIO

                    case Enum_Configuration.PARAVERTEBRAL: //OK

                        #region PARAVERTEBRAL

                        {
                            axis2 = new Vector3D(1, 0, 0);
                            angle2 = 90;
                            RotationOperableEnsamble = new System.Windows.Media.Media3D.Quaternion();
                            RotationOperableEnsamble = System.Windows.Media.Media3D.Quaternion.Multiply(RotationOperableEnsamble, new System.Windows.Media.Media3D.Quaternion(axis2, angle2));
                            axis3 = new Vector3D(0, 1, 0);
                            angle3 = 90;
                            RotationOperableEnsamble = System.Windows.Media.Media3D.Quaternion.Multiply(RotationOperableEnsamble, new System.Windows.Media.Media3D.Quaternion(axis3, angle3));

                            pointSkinBlockCenter = new Point3D(-287.5f, -82, -1349.5);
                            //pointSkinBlockCenter = new Point3D(-275.5f, -82, -1349.5);

                            pointAntenna = pointSkinBlockCenter + Calculator.Instance.GiveMeVector3D(originalPositionSkinBlockCenter_WRS);

                            XPosOperableEnsamble = (float)pointAntenna.X;
                            YPosOperableEnsamble = (float)pointAntenna.Y;
                            ZPosOperableEnsamble = (float)pointAntenna.Z;

                            rotTrasl = GiveMeRotationRelativeAntenna(RotationOperableEnsamble);

                            wft.hvView3D.CameraController.CameraUpDirection = new Vector3D(0, 0, -1);
                            wft.hvView3D.CameraController.CameraLookDirection = new Vector3D(1, 0, 0);
                            wft.hvView3D.CameraController.CameraPosition = new Point3D(pointAntenna.X - deltaViewFar + rotTrasl.X, pointAntenna.Y + rotTrasl.Y, pointAntenna.Z + rotTrasl.Z);
                            wft.startCircle.Normal = new Vector3D(0, 0, 1);
                            wft.hvView3D.LookAt(new Point3D(pointAntenna.X - deltaViewNear + rotTrasl.X, pointAntenna.Y + rotTrasl.Y, pointAntenna.Z + rotTrasl.Z), timeAnimation);
                            break;
                        }

                    #endregion PARAVERTEBRAL

                    case Enum_Configuration.PECS2: //OK

                        #region PECS2

                        {
                            axis2 = new Vector3D(1, 0, 0);
                            angle2 = 90;
                            RotationOperableEnsamble = new System.Windows.Media.Media3D.Quaternion();
                            RotationOperableEnsamble = System.Windows.Media.Media3D.Quaternion.Multiply(RotationOperableEnsamble, new System.Windows.Media.Media3D.Quaternion(axis2, angle2));

                            rotTrasl = GiveMeRotationRelativeAntenna(RotationOperableEnsamble);

                            pointSkinBlockCenter = new Point3D(-317.5f, 105, -1395.5);
                            //pointSkinBlockCenter = new Point3D(-317.5f, 93, -1395.5);

                            pointAntenna = pointSkinBlockCenter + Calculator.Instance.GiveMeVector3D(originalPositionSkinBlockCenter_WRS);

                            //pointAntenna = new Point3D(-160, 85, -1380);

                            XPosOperableEnsamble = (float)pointAntenna.X;
                            YPosOperableEnsamble = (float)pointAntenna.Y;
                            ZPosOperableEnsamble = (float)pointAntenna.Z;

                            wft.hvView3D.CameraController.CameraUpDirection = new Vector3D(1, 0, 0);
                            wft.hvView3D.CameraController.CameraLookDirection = new Vector3D(0, -1, 0);
                            wft.hvView3D.CameraController.CameraPosition = new Point3D(pointAntenna.X + rotTrasl.X, pointAntenna.Y + deltaViewFar + rotTrasl.Y, pointAntenna.Z + rotTrasl.Z);
                            wft.hvView3D.LookAt(new Point3D(pointAntenna.X + rotTrasl.X, pointAntenna.Y + deltaViewNear / 3f * 2f + rotTrasl.Y, pointAntenna.Z + rotTrasl.Z), timeAnimation);
                            wft.startCircle.Normal = new Vector3D(0, 0, 1);
                            break;
                        }

                    #endregion PECS2

                    case Enum_Configuration.TAP: //OK

                        #region TAP

                        {
                            axis2 = new Vector3D(1, 0, 0);
                            angle2 = 90;
                            RotationOperableEnsamble = new System.Windows.Media.Media3D.Quaternion();
                            RotationOperableEnsamble = System.Windows.Media.Media3D.Quaternion.Multiply(RotationOperableEnsamble, new System.Windows.Media.Media3D.Quaternion(axis2, angle2));

                            pointSkinBlockCenter = new Point3D(-312.5f, 78, -1129.5);
                            //pointSkinBlockCenter = new Point3D(-312.5f, 66, -1129.5);
                            pointAntenna = pointSkinBlockCenter + Calculator.Instance.GiveMeVector3D(originalPositionSkinBlockCenter_WRS);

                            XPosOperableEnsamble = (float)pointAntenna.X;
                            YPosOperableEnsamble = (float)pointAntenna.Y;
                            ZPosOperableEnsamble = (float)pointAntenna.Z;
                            rotTrasl = GiveMeRotationRelativeAntenna(RotationOperableEnsamble);

                            wft.hvView3D.CameraController.CameraUpDirection = new Vector3D(1, 0, 0);
                            wft.hvView3D.CameraController.CameraLookDirection = new Vector3D(0, -1, 0);
                            wft.hvView3D.CameraController.CameraPosition = new Point3D(pointAntenna.X + rotTrasl.X, pointAntenna.Y + deltaViewFar + rotTrasl.Y, pointAntenna.Z + rotTrasl.Z);
                            wft.hvView3D.LookAt(new Point3D(pointAntenna.X + rotTrasl.X, pointAntenna.Y + deltaViewNear + rotTrasl.Y, pointAntenna.Z + rotTrasl.Z), timeAnimation);
                            wft.startCircle.Normal = new Vector3D(0, 0, 1);
                            break;
                        }

                    #endregion TAP

                    case Enum_Configuration.PECS1: //OK

                        #region PECS1

                        {
                            axis2 = new Vector3D(0, 1, 0);
                            angle2 = -90;
                            RotationOperableEnsamble = new System.Windows.Media.Media3D.Quaternion();
                            RotationOperableEnsamble = System.Windows.Media.Media3D.Quaternion.Multiply(RotationOperableEnsamble, new System.Windows.Media.Media3D.Quaternion(axis2, angle2));
                            axis3 = new Vector3D(0, 0, 1);
                            angle3 = 180;
                            RotationOperableEnsamble = System.Windows.Media.Media3D.Quaternion.Multiply(RotationOperableEnsamble, new System.Windows.Media.Media3D.Quaternion(axis3, angle3));

                            rotTrasl = GiveMeRotationRelativeAntenna(RotationOperableEnsamble);
                            pointSkinBlockCenter = new Point3D(-171.5f, 65, -1300.5);
                            //pointSkinBlockCenter = new Point3D(-183.5f, 65, -1300.5);
                            pointAntenna = pointSkinBlockCenter + Calculator.Instance.GiveMeVector3D(originalPositionSkinBlockCenter_WRS);

                            XPosOperableEnsamble = (float)pointAntenna.X;
                            YPosOperableEnsamble = (float)pointAntenna.Y;
                            ZPosOperableEnsamble = (float)pointAntenna.Z;

                            wft.hvView3D.CameraController.CameraUpDirection = new Vector3D(0, -1, 0);
                            wft.hvView3D.CameraController.CameraLookDirection = new Vector3D(-1, 0, 0);
                            wft.hvView3D.CameraController.CameraPosition = new Point3D(pointAntenna.X + rotTrasl.X + deltaViewFar, pointAntenna.Y + rotTrasl.Y, pointAntenna.Z + rotTrasl.Z);
                            wft.hvView3D.LookAt(new Point3D(pointAntenna.X + rotTrasl.X + deltaViewNear / 3f * 2f, pointAntenna.Y + rotTrasl.Y, pointAntenna.Z + rotTrasl.Z), timeAnimation);
                            wft.startCircle.Normal = new Vector3D(0, 0, 1);
                            break;
                        }

                    #endregion PECS1

                    case Enum_Configuration.FASCIAILIACA: //OK

                        #region FASCIAILIACA SUPRAINGUINAL

                        {
                            axis2 = new Vector3D(0, 0, 1);
                            angle2 = 90;
                            RotationOperableEnsamble = new System.Windows.Media.Media3D.Quaternion();
                            RotationOperableEnsamble = System.Windows.Media.Media3D.Quaternion.Multiply(RotationOperableEnsamble, new System.Windows.Media.Media3D.Quaternion(axis2, angle2));
                            axis3 = new Vector3D(1, 0, 0);
                            angle3 = -90;
                            RotationOperableEnsamble = System.Windows.Media.Media3D.Quaternion.Multiply(RotationOperableEnsamble, new System.Windows.Media.Media3D.Quaternion(axis3, angle3));

                            rotTrasl = GiveMeRotationRelativeAntenna(RotationOperableEnsamble);

                            pointSkinBlockCenter = new Point3D(-141.5f, -25, -1020.5);
                            //pointSkinBlockCenter = new Point3D(-153.5f, -25, -1020.5);

                            pointAntenna = pointSkinBlockCenter + Calculator.Instance.GiveMeVector3D(originalPositionSkinBlockCenter_WRS);

                            XPosOperableEnsamble = (float)pointAntenna.X;
                            YPosOperableEnsamble = (float)pointAntenna.Y;
                            ZPosOperableEnsamble = (float)pointAntenna.Z;

                            wft.hvView3D.CameraController.CameraUpDirection = new Vector3D(0, 0, -1);
                            wft.hvView3D.CameraController.CameraLookDirection = new Vector3D(-1, 0, 0);
                            wft.hvView3D.CameraController.CameraPosition = new Point3D(pointAntenna.X + rotTrasl.X + deltaViewFar, pointAntenna.Y + rotTrasl.Y, pointAntenna.Z + rotTrasl.Z);
                            wft.hvView3D.LookAt(new Point3D(pointAntenna.X + rotTrasl.X + deltaViewNear / 3f * 2f, pointAntenna.Y + rotTrasl.Y, pointAntenna.Z + rotTrasl.Z), timeAnimation);
                            wft.startCircle.Normal = new Vector3D(0, 0, 1);
                            break;
                        }

                    #endregion FASCIAILIACA SUPRAINGUINAL

                    case Enum_Configuration.H_FASCIAILIACA_INFRAINGUINAL: //OK

                        #region FASCIAILIACA INFRAINGUINAL

                        {
                            axis2 = new Vector3D(0, 0, 1);
                            angle2 = 90;
                            RotationOperableEnsamble = new System.Windows.Media.Media3D.Quaternion();
                            RotationOperableEnsamble = System.Windows.Media.Media3D.Quaternion.Multiply(RotationOperableEnsamble, new System.Windows.Media.Media3D.Quaternion(axis2, angle2));
                            axis3 = new Vector3D(1, 0, 0);
                            angle3 = -90;
                            RotationOperableEnsamble = System.Windows.Media.Media3D.Quaternion.Multiply(RotationOperableEnsamble, new System.Windows.Media.Media3D.Quaternion(axis3, angle3));

                            rotTrasl = GiveMeRotationRelativeAntenna(RotationOperableEnsamble);

                            pointSkinBlockCenter = new Point3D(-141.5f, -25, -1020.5);

                            pointAntenna = pointSkinBlockCenter + Calculator.Instance.GiveMeVector3D(originalPositionSkinBlockCenter_WRS);

                            XPosOperableEnsamble = (float)pointAntenna.X;
                            YPosOperableEnsamble = (float)pointAntenna.Y;
                            ZPosOperableEnsamble = (float)pointAntenna.Z;

                            wft.hvView3D.CameraController.CameraUpDirection = new Vector3D(0, 0, -1);
                            wft.hvView3D.CameraController.CameraLookDirection = new Vector3D(-1, 0, 0);
                            wft.hvView3D.CameraController.CameraPosition = new Point3D(pointAntenna.X + rotTrasl.X + deltaViewFar, pointAntenna.Y + rotTrasl.Y, pointAntenna.Z + rotTrasl.Z);
                            wft.hvView3D.LookAt(new Point3D(pointAntenna.X + rotTrasl.X + deltaViewNear / 3f * 2f, pointAntenna.Y + rotTrasl.Y, pointAntenna.Z + rotTrasl.Z), timeAnimation);
                            wft.startCircle.Normal = new Vector3D(0, 0, 1);
                            break;
                        }

                    #endregion FASCIAILIACA INFRAINGUINAL

                    case Enum_Configuration.H_PENG: //OK

                        #region PENG

                        {
                            axis2 = new Vector3D(0, 0, 1);
                            angle2 = 90;
                            RotationOperableEnsamble = new System.Windows.Media.Media3D.Quaternion();
                            RotationOperableEnsamble = System.Windows.Media.Media3D.Quaternion.Multiply(RotationOperableEnsamble, new System.Windows.Media.Media3D.Quaternion(axis2, angle2));
                            axis3 = new Vector3D(1, 0, 0);
                            angle3 = -90;
                            RotationOperableEnsamble = System.Windows.Media.Media3D.Quaternion.Multiply(RotationOperableEnsamble, new System.Windows.Media.Media3D.Quaternion(axis3, angle3));

                            rotTrasl = GiveMeRotationRelativeAntenna(RotationOperableEnsamble);

                            pointSkinBlockCenter = new Point3D(-141.5f, -25, -1020.5);

                            pointAntenna = pointSkinBlockCenter + Calculator.Instance.GiveMeVector3D(originalPositionSkinBlockCenter_WRS);

                            XPosOperableEnsamble = (float)pointAntenna.X;
                            YPosOperableEnsamble = (float)pointAntenna.Y;
                            ZPosOperableEnsamble = (float)pointAntenna.Z;

                            wft.hvView3D.CameraController.CameraUpDirection = new Vector3D(0, 0, -1);
                            wft.hvView3D.CameraController.CameraLookDirection = new Vector3D(-1, 0, 0);
                            wft.hvView3D.CameraController.CameraPosition = new Point3D(pointAntenna.X + rotTrasl.X + deltaViewFar, pointAntenna.Y + rotTrasl.Y, pointAntenna.Z + rotTrasl.Z);
                            wft.hvView3D.LookAt(new Point3D(pointAntenna.X + rotTrasl.X + deltaViewNear / 3f * 2f, pointAntenna.Y + rotTrasl.Y, pointAntenna.Z + rotTrasl.Z), timeAnimation);
                            wft.startCircle.Normal = new Vector3D(0, 0, 1);
                            break;
                        }

                    #endregion PENG

                    case Enum_Configuration.N_ADDUCTORCANAL: //OK

                        #region ADDUCTORCANAL

                        {
                            axis2 = new Vector3D(0, 0, 1);
                            angle2 = 90;
                            RotationOperableEnsamble = new System.Windows.Media.Media3D.Quaternion();
                            RotationOperableEnsamble = System.Windows.Media.Media3D.Quaternion.Multiply(RotationOperableEnsamble, new System.Windows.Media.Media3D.Quaternion(axis2, angle2));
                            axis3 = new Vector3D(1, 0, 0);
                            angle3 = -90;
                            RotationOperableEnsamble = System.Windows.Media.Media3D.Quaternion.Multiply(RotationOperableEnsamble, new System.Windows.Media.Media3D.Quaternion(axis3, angle3));

                            rotTrasl = GiveMeRotationRelativeAntenna(RotationOperableEnsamble);

                            pointSkinBlockCenter = new Point3D(-111.5f, -7, -720.5);
                            //pointSkinBlockCenter = new Point3D(-123.5f, -7, -720.5);

                            pointAntenna = pointSkinBlockCenter + Calculator.Instance.GiveMeVector3D(originalPositionSkinBlockCenter_WRS);

                            XPosOperableEnsamble = (float)pointAntenna.X;
                            YPosOperableEnsamble = (float)pointAntenna.Y;
                            ZPosOperableEnsamble = (float)pointAntenna.Z;

                            wft.hvView3D.CameraController.CameraUpDirection = new Vector3D(0, 0, -1);
                            wft.hvView3D.CameraController.CameraLookDirection = new Vector3D(-1, 0, 0);
                            wft.hvView3D.CameraController.CameraPosition = new Point3D(pointAntenna.X + rotTrasl.X + deltaViewFar, pointAntenna.Y + rotTrasl.Y, pointAntenna.Z + rotTrasl.Z);
                            wft.hvView3D.LookAt(new Point3D(pointAntenna.X + rotTrasl.X + deltaViewNear / 3f * 2f, pointAntenna.Y + rotTrasl.Y, pointAntenna.Z + rotTrasl.Z), timeAnimation);
                            wft.startCircle.Normal = new Vector3D(0, 0, 1);
                            break;
                        }

                    #endregion ADDUCTORCANAL

                    case Enum_Configuration.N_AXILLARY_BP: //OK

                        #region AXILLARY_BP

                        {
                            RotationOperableEnsamble = new System.Windows.Media.Media3D.Quaternion();
                            axis2 = new Vector3D(0, 1, 0);
                            angle2 = -90;

                            RotationOperableEnsamble = System.Windows.Media.Media3D.Quaternion.Multiply(RotationOperableEnsamble, new System.Windows.Media.Media3D.Quaternion(axis2, angle2));
                            axis3 = new Vector3D(0, 0, 1);
                            angle3 = 180;
                            RotationOperableEnsamble = System.Windows.Media.Media3D.Quaternion.Multiply(RotationOperableEnsamble, new System.Windows.Media.Media3D.Quaternion(axis3, angle3));

                            rotTrasl = GiveMeRotationRelativeAntenna(RotationOperableEnsamble);
                            pointSkinBlockCenter = new Point3D(-271.5f, -199, -1330.5);
                            //pointSkinBlockCenter = new Point3D(-283.5f, -199, -1325.5);

                            pointAntenna = pointSkinBlockCenter + Calculator.Instance.GiveMeVector3D(originalPositionSkinBlockCenter_WRS);

                            XPosOperableEnsamble = (float)pointAntenna.X;
                            YPosOperableEnsamble = (float)pointAntenna.Y;
                            ZPosOperableEnsamble = (float)pointAntenna.Z;

                            wft.hvView3D.CameraController.CameraUpDirection = new Vector3D(0, 0, -1);
                            wft.hvView3D.CameraController.CameraLookDirection = new Vector3D(-.7, .3, 0);
                            wft.hvView3D.CameraController.CameraPosition = new Point3D(pointAntenna.X + rotTrasl.X + deltaViewFar * 0.7, pointAntenna.Y + rotTrasl.Y - deltaViewFar * 0.3, pointAntenna.Z + rotTrasl.Z);
                            wft.hvView3D.LookAt(new Point3D(pointAntenna.X + rotTrasl.X + deltaViewNear / 3f * 2f * 0.7, pointAntenna.Y + rotTrasl.Y - +deltaViewNear / 3f * 2f * 0.3, pointAntenna.Z + rotTrasl.Z), timeAnimation);
                            wft.startCircle.Normal = new Vector3D(0, 0, 1);
                            break;
                        }

                    #endregion AXILLARY_BP

                    case Enum_Configuration.N_FEMURAL: //OK

                        #region N_FEMURAL

                        axis2 = new Vector3D(0, 0, 1);
                        angle2 = -90;
                        RotationOperableEnsamble = new System.Windows.Media.Media3D.Quaternion();
                        RotationOperableEnsamble = System.Windows.Media.Media3D.Quaternion.Multiply(RotationOperableEnsamble, new System.Windows.Media.Media3D.Quaternion(axis2, angle2));
                        axis3 = new Vector3D(1, 0, 0);
                        angle3 = 90;
                        RotationOperableEnsamble = System.Windows.Media.Media3D.Quaternion.Multiply(RotationOperableEnsamble, new System.Windows.Media.Media3D.Quaternion(axis3, angle3));

                        rotTrasl = GiveMeRotationRelativeAntenna(RotationOperableEnsamble);

                        pointSkinBlockCenter = new Point3D(-151.5f, 25, -1010.5);
                        //pointSkinBlockCenter = new Point3D(-153.5f, -25, -1020.5);

                        pointAntenna = pointSkinBlockCenter + Calculator.Instance.GiveMeVector3D(originalPositionSkinBlockCenter_WRS);

                        XPosOperableEnsamble = (float)pointAntenna.X;
                        YPosOperableEnsamble = (float)pointAntenna.Y;
                        ZPosOperableEnsamble = (float)pointAntenna.Z;

                        wft.hvView3D.CameraController.CameraUpDirection = new Vector3D(0, 0, -1);
                        wft.hvView3D.CameraController.CameraLookDirection = new Vector3D(-1, 0, 0);
                        wft.hvView3D.CameraController.CameraPosition = new Point3D(pointAntenna.X + rotTrasl.X + deltaViewFar, pointAntenna.Y + rotTrasl.Y, pointAntenna.Z + rotTrasl.Z);
                        wft.hvView3D.LookAt(new Point3D(pointAntenna.X + rotTrasl.X + deltaViewNear / 3f * 2f, pointAntenna.Y + rotTrasl.Y, pointAntenna.Z + rotTrasl.Z), timeAnimation);
                        wft.startCircle.Normal = new Vector3D(0, 0, 1);
                        break;

                    #endregion N_FEMURAL

                    case Enum_Configuration.N_INFRACLAVICULAR:
                    case Enum_Configuration.N_INTERSCALENE_BP://OK
                    case Enum_Configuration.N_SUPRACLAVICULAR:

                        #region N_INFRACLAVICULAR, N_SUPRACLAVICULAR, N_INTERSCALENE_BP

                        {
                            RotationOperableEnsamble = new System.Windows.Media.Media3D.Quaternion();

                            rotTrasl = GiveMeRotationRelativeAntenna(RotationOperableEnsamble);

                            pointSkinBlockCenter = new Point3D(-315, -90, -1449.5);
                            //pointSkinBlockCenter = new Point3D(-315, -90, -1437.5);

                            pointAntenna = pointSkinBlockCenter + Calculator.Instance.GiveMeVector3D(originalPositionSkinBlockCenter_WRS);

                            XPosOperableEnsamble = (float)pointAntenna.X;
                            YPosOperableEnsamble = (float)pointAntenna.Y;
                            ZPosOperableEnsamble = (float)pointAntenna.Z;


                            Point3D additionalTrasl = new Point3D(0, 0, -40);
                           



                            if (configur == Enum_Configuration.N_INTERSCALENE_BP)
                            {
                                wft.startCircle.Normal = new Vector3D(0, .7, 0.7);

                            }
                            if (configur == Enum_Configuration.N_INFRACLAVICULAR)
                            {
                                wft.startCircle.Normal = new Vector3D(1, 0, 0);
                                additionalTrasl.Z = 0;

                            }
                            if (configur == Enum_Configuration.N_SUPRACLAVICULAR)
                            {
                                wft.startCircle.Normal = new Vector3D(0, 0, 1);

                            }

                            wft.hvView3D.CameraController.CameraUpDirection = new Vector3D(0, 0, -1);
                            wft.hvView3D.CameraController.CameraLookDirection = new Vector3D(-.7, .3, .43);
                            wft.hvView3D.CameraController.CameraPosition = new Point3D(pointAntenna.X + rotTrasl.X + deltaViewFar * 0.7 + additionalTrasl.X, pointAntenna.Y + rotTrasl.Y - deltaViewFar * 0.3 + additionalTrasl.Y, pointAntenna.Z + rotTrasl.Z - deltaViewFar * .3 + additionalTrasl.Z);
                            wft.hvView3D.LookAt(new Point3D(pointAntenna.X + rotTrasl.X + deltaViewNear / 3f * 2f * 0.7 + additionalTrasl.X, pointAntenna.Y + rotTrasl.Y - deltaViewNear / 3f * 2f * 0.3 + additionalTrasl.Y, pointAntenna.Z + rotTrasl.Z - deltaViewNear / 3f * 2f * 0.3 + additionalTrasl.Z), timeAnimation);


                            break;
                        }

                    #endregion N_INFRACLAVICULAR, N_SUPRACLAVICULAR, N_INTERSCALENE_BP

                    case Enum_Configuration.N_LUMBARPLEXUS:

                        //    #region N_LUMBARPLEXUS

                        //    {
                        //        axis2 = new Vector3D(0, 0, 1);
                        //        angle2 = 90;
                        //        RotationOperableEnsamble = new System.Windows.Media.Media3D.Quaternion();
                        //        RotationOperableEnsamble = System.Windows.Media.Media3D.Quaternion.Multiply(RotationOperableEnsamble, new System.Windows.Media.Media3D.Quaternion(axis2, angle2));
                        //        axis3 = new Vector3D(1, 0, 0);
                        //        angle3 = -90;
                        //        RotationOperableEnsamble = System.Windows.Media.Media3D.Quaternion.Multiply(RotationOperableEnsamble, new System.Windows.Media.Media3D.Quaternion(axis3, angle3));

                        //        rotTrasl = GiveMeRotationRelativeAntenna(RotationOperableEnsamble);

                        //        pointSkinBlockCenter = new Point3D(-141.5f, -25, -1020.5);
                        //        //pointSkinBlockCenter = new Point3D(-153.5f, -25, -1020.5);

                        //        pointAntenna = pointSkinBlockCenter + Calculator.Instance.GiveMeVector3D(originalPositionSkinBlockCenter_WRS);

                        //        XPosOperableEnsamble = (float)pointAntenna.X;
                        //        YPosOperableEnsamble = (float)pointAntenna.Y;
                        //        ZPosOperableEnsamble = (float)pointAntenna.Z;

                        //        wft.hvView3D.CameraController.CameraUpDirection = new Vector3D(0, 0, -1);
                        //        wft.hvView3D.CameraController.CameraLookDirection = new Vector3D(-1, 0, 0);
                        //        wft.hvView3D.CameraController.CameraPosition = new Point3D(pointAntenna.X + rotTrasl.X + deltaViewFar, pointAntenna.Y + rotTrasl.Y, pointAntenna.Z + rotTrasl.Z);
                        //        wft.hvView3D.LookAt(new Point3D(pointAntenna.X + rotTrasl.X + deltaViewNear / 3f * 2f, pointAntenna.Y + rotTrasl.Y, pointAntenna.Z + rotTrasl.Z), timeAnimation);
                        //        wft.startCircle.Normal = new Vector3D(0, 0, 1);
                        //        break;
                        //    }

                        //#endregion N_LUMBARPLEXUS

                        #region N_LUMBARPLEXUS

                        {
                            axis2 = new Vector3D(1, 0, 0);
                            angle2 = 90;
                            RotationOperableEnsamble = new System.Windows.Media.Media3D.Quaternion();
                            RotationOperableEnsamble = System.Windows.Media.Media3D.Quaternion.Multiply(RotationOperableEnsamble, new System.Windows.Media.Media3D.Quaternion(axis2, angle2));
                            axis3 = new Vector3D(0, 1, 0);
                            angle3 = 90;
                            RotationOperableEnsamble = System.Windows.Media.Media3D.Quaternion.Multiply(RotationOperableEnsamble, new System.Windows.Media.Media3D.Quaternion(axis3, angle3));

                            pointSkinBlockCenter = new Point3D(-240.5f, -65, -1109.5);
                            //pointSkinBlockCenter = new Point3D(-228.5f, -35, -1099.5);
                            pointAntenna = pointSkinBlockCenter + Calculator.Instance.GiveMeVector3D(originalPositionSkinBlockCenter_WRS);

                            XPosOperableEnsamble = (float)pointAntenna.X;
                            YPosOperableEnsamble = (float)pointAntenna.Y;
                            ZPosOperableEnsamble = (float)pointAntenna.Z;

                            rotTrasl = GiveMeRotationRelativeAntenna(RotationOperableEnsamble);

                            wft.hvView3D.CameraController.CameraUpDirection = new Vector3D(-0.2, .8, 0);
                            wft.hvView3D.CameraController.CameraLookDirection = new Vector3D(0.8, -0.2, 0);
                            wft.hvView3D.CameraController.CameraPosition = new Point3D(pointAntenna.X - deltaViewFar + rotTrasl.X, pointAntenna.Y + rotTrasl.Y + 50, pointAntenna.Z + rotTrasl.Z);
                            wft.startCircle.Normal = new Vector3D(0, 0, 1);
                            wft.hvView3D.LookAt(new Point3D(pointAntenna.X - deltaViewNear + rotTrasl.X, pointAntenna.Y + rotTrasl.Y + 50, pointAntenna.Z + rotTrasl.Z), timeAnimation);
                            break;
                        }
                    #endregion

                    case Enum_Configuration.N_SCIATIC_GLUTEAL: //OK

                        #region N_SCIATIC_GLUTEAL

                        {
                            axis2 = new Vector3D(1, 0, 0);
                            angle2 = 90;
                            RotationOperableEnsamble = new System.Windows.Media.Media3D.Quaternion();
                            RotationOperableEnsamble = System.Windows.Media.Media3D.Quaternion.Multiply(RotationOperableEnsamble, new System.Windows.Media.Media3D.Quaternion(axis2, angle2));
                            axis3 = new Vector3D(0, 1, 0);
                            angle3 = 90;
                            RotationOperableEnsamble = System.Windows.Media.Media3D.Quaternion.Multiply(RotationOperableEnsamble, new System.Windows.Media.Media3D.Quaternion(axis3, angle3));

                            pointSkinBlockCenter = new Point3D(-257.5f, -25, -939.5);
                            //pointSkinBlockCenter = new Point3D(-245.5f, -25, -939.5);

                            pointAntenna = pointSkinBlockCenter + Calculator.Instance.GiveMeVector3D(originalPositionSkinBlockCenter_WRS);

                            XPosOperableEnsamble = (float)pointAntenna.X;
                            YPosOperableEnsamble = (float)pointAntenna.Y;
                            ZPosOperableEnsamble = (float)pointAntenna.Z;

                            rotTrasl = GiveMeRotationRelativeAntenna(RotationOperableEnsamble);

                            wft.hvView3D.CameraController.CameraUpDirection = new Vector3D(0, 0, -1);
                            wft.hvView3D.CameraController.CameraLookDirection = new Vector3D(1, 0, 0);
                            wft.hvView3D.CameraController.CameraPosition = new Point3D(pointAntenna.X - deltaViewFar + rotTrasl.X, pointAntenna.Y + rotTrasl.Y, pointAntenna.Z + rotTrasl.Z);
                            wft.startCircle.Normal = new Vector3D(0, 0, 1);
                            wft.hvView3D.LookAt(new Point3D(pointAntenna.X - deltaViewNear + rotTrasl.X, pointAntenna.Y + rotTrasl.Y, pointAntenna.Z + rotTrasl.Z), timeAnimation);
                            break;
                        }

                    #endregion N_SCIATIC_GLUTEAL

                    case Enum_Configuration.N_SCIATIC_POPLITEAL: //OK

                        #region N_SCIATIC_POPLITEAL

                        {
                            axis2 = new Vector3D(1, 0, 0);
                            angle2 = 90;
                            RotationOperableEnsamble = new System.Windows.Media.Media3D.Quaternion();
                            RotationOperableEnsamble = System.Windows.Media.Media3D.Quaternion.Multiply(RotationOperableEnsamble, new System.Windows.Media.Media3D.Quaternion(axis2, angle2));
                            axis3 = new Vector3D(0, 1, 0);
                            angle3 = 90;
                            RotationOperableEnsamble = System.Windows.Media.Media3D.Quaternion.Multiply(RotationOperableEnsamble, new System.Windows.Media.Media3D.Quaternion(axis3, angle3));

                            pointSkinBlockCenter = new Point3D(-141f, 0, -480.5);
                            //pointSkinBlockCenter = new Point3D(-129f, 0, -480.5);
                            pointAntenna = pointSkinBlockCenter + Calculator.Instance.GiveMeVector3D(originalPositionSkinBlockCenter_WRS);

                            XPosOperableEnsamble = (float)pointAntenna.X;
                            YPosOperableEnsamble = (float)pointAntenna.Y;
                            ZPosOperableEnsamble = (float)pointAntenna.Z;

                            rotTrasl = GiveMeRotationRelativeAntenna(RotationOperableEnsamble);

                            wft.hvView3D.CameraController.CameraUpDirection = new Vector3D(0, 0, -1);
                            wft.hvView3D.CameraController.CameraLookDirection = new Vector3D(1, 0, 0);
                            wft.hvView3D.CameraController.CameraPosition = new Point3D(pointAntenna.X - deltaViewFar + rotTrasl.X, pointAntenna.Y + rotTrasl.Y, pointAntenna.Z + rotTrasl.Z);
                            wft.startCircle.Normal = new Vector3D(0, 0, 1);
                            wft.hvView3D.LookAt(new Point3D(pointAntenna.X - deltaViewNear + rotTrasl.X, pointAntenna.Y + rotTrasl.Y, pointAntenna.Z + rotTrasl.Z), timeAnimation);
                            break;
                        }

                    #endregion N_SCIATIC_POPLITEAL

                    case Enum_Configuration.PARASTERNAL: //OK

                        #region PARASTERNAL

                        {
                            axis2 = new Vector3D(0, 0, 1);
                            angle2 = 90;
                            RotationOperableEnsamble = new System.Windows.Media.Media3D.Quaternion();
                            RotationOperableEnsamble = System.Windows.Media.Media3D.Quaternion.Multiply(RotationOperableEnsamble, new System.Windows.Media.Media3D.Quaternion(axis2, angle2));
                            axis3 = new Vector3D(1, 0, 0);
                            angle3 = -90;
                            RotationOperableEnsamble = System.Windows.Media.Media3D.Quaternion.Multiply(RotationOperableEnsamble, new System.Windows.Media.Media3D.Quaternion(axis3, angle3));

                            rotTrasl = GiveMeRotationRelativeAntenna(RotationOperableEnsamble);

                            pointSkinBlockCenter = new Point3D(-141.5f, -50, -1370.5);
                            //pointSkinBlockCenter = new Point3D(-129.5f, -50, -1370.5);

                            pointAntenna = pointSkinBlockCenter + Calculator.Instance.GiveMeVector3D(originalPositionSkinBlockCenter_WRS);

                            XPosOperableEnsamble = (float)pointAntenna.X;
                            YPosOperableEnsamble = (float)pointAntenna.Y;
                            ZPosOperableEnsamble = (float)pointAntenna.Z;

                            wft.hvView3D.CameraController.CameraUpDirection = new Vector3D(0, -1, 0);
                            wft.hvView3D.CameraController.CameraLookDirection = new Vector3D(-1, 0, 0);
                            wft.hvView3D.CameraController.CameraPosition = new Point3D(pointAntenna.X + rotTrasl.X + deltaViewFar, pointAntenna.Y + rotTrasl.Y, pointAntenna.Z + rotTrasl.Z);
                            wft.hvView3D.LookAt(new Point3D(pointAntenna.X + rotTrasl.X + deltaViewNear / 3f * 2f, pointAntenna.Y + rotTrasl.Y, pointAntenna.Z + rotTrasl.Z), timeAnimation);
                            wft.startCircle.Normal = new Vector3D(0, 0, 1);
                            break;
                        }

                    #endregion PARASTERNAL

                    case Enum_Configuration.ESP: //OK

                        #region ESP

                        {
                            axis2 = new Vector3D(1, 0, 0);
                            angle2 = 90;
                            RotationOperableEnsamble = new System.Windows.Media.Media3D.Quaternion();
                            RotationOperableEnsamble = System.Windows.Media.Media3D.Quaternion.Multiply(RotationOperableEnsamble, new System.Windows.Media.Media3D.Quaternion(axis2, angle2));
                            axis3 = new Vector3D(0, 1, 0);
                            angle3 = 90;
                            RotationOperableEnsamble = System.Windows.Media.Media3D.Quaternion.Multiply(RotationOperableEnsamble, new System.Windows.Media.Media3D.Quaternion(axis3, angle3));

                            pointSkinBlockCenter = new Point3D(-287.5f, -82, -1349.5);
                            //pointSkinBlockCenter = new Point3D(-275.5f, -82, -1349.5);
                            pointAntenna = pointSkinBlockCenter + Calculator.Instance.GiveMeVector3D(originalPositionSkinBlockCenter_WRS);

                            XPosOperableEnsamble = (float)pointAntenna.X;
                            YPosOperableEnsamble = (float)pointAntenna.Y;
                            ZPosOperableEnsamble = (float)pointAntenna.Z;

                            rotTrasl = GiveMeRotationRelativeAntenna(RotationOperableEnsamble);

                            wft.hvView3D.CameraController.CameraUpDirection = new Vector3D(0, 1, 0);
                            wft.hvView3D.CameraController.CameraLookDirection = new Vector3D(1, 0, 0);
                            wft.hvView3D.CameraController.CameraPosition = new Point3D(pointAntenna.X - deltaViewFar + rotTrasl.X, pointAntenna.Y + rotTrasl.Y, pointAntenna.Z + rotTrasl.Z);
                            wft.startCircle.Normal = new Vector3D(0, 0, 1);
                            wft.hvView3D.LookAt(new Point3D(pointAntenna.X - deltaViewNear + rotTrasl.X, pointAntenna.Y + rotTrasl.Y, pointAntenna.Z + rotTrasl.Z), timeAnimation);
                            break;
                        }

                    #endregion ESP

                    case Enum_Configuration.LUMBAR: //OK

                        #region LUMBAR

                        {
                            axis2 = new Vector3D(1, 0, 0);
                            angle2 = 90;
                            RotationOperableEnsamble = new System.Windows.Media.Media3D.Quaternion();
                            RotationOperableEnsamble = System.Windows.Media.Media3D.Quaternion.Multiply(RotationOperableEnsamble, new System.Windows.Media.Media3D.Quaternion(axis2, angle2));
                            axis3 = new Vector3D(0, 1, 0);
                            angle3 = 90;
                            RotationOperableEnsamble = System.Windows.Media.Media3D.Quaternion.Multiply(RotationOperableEnsamble, new System.Windows.Media.Media3D.Quaternion(axis3, angle3));

                            pointSkinBlockCenter = new Point3D(-240.5f, -35, -1099.5);
                            //pointSkinBlockCenter = new Point3D(-228.5f, -35, -1099.5);
                            pointAntenna = pointSkinBlockCenter + Calculator.Instance.GiveMeVector3D(originalPositionSkinBlockCenter_WRS);

                            XPosOperableEnsamble = (float)pointAntenna.X;
                            YPosOperableEnsamble = (float)pointAntenna.Y;
                            ZPosOperableEnsamble = (float)pointAntenna.Z;

                            rotTrasl = GiveMeRotationRelativeAntenna(RotationOperableEnsamble);

                            wft.hvView3D.CameraController.CameraUpDirection = new Vector3D(-0.2, .8, 0);
                            wft.hvView3D.CameraController.CameraLookDirection = new Vector3D(0.8, -0.2, 0);
                            wft.hvView3D.CameraController.CameraPosition = new Point3D(pointAntenna.X - deltaViewFar + rotTrasl.X, pointAntenna.Y + rotTrasl.Y + 50, pointAntenna.Z + rotTrasl.Z);
                            wft.startCircle.Normal = new Vector3D(-0.8, 0, 0.3);
                            wft.hvView3D.LookAt(new Point3D(pointAntenna.X - deltaViewNear + rotTrasl.X, pointAntenna.Y + rotTrasl.Y + 50, pointAntenna.Z + rotTrasl.Z), timeAnimation);
                            break;
                        }

                    #endregion LUMBAR

                    case Enum_Configuration.SERRATUM: //OK

                        #region SERRATUM

                        {
                            axis2 = new Vector3D(1, 0, 0);
                            angle2 = 90;
                            RotationOperableEnsamble = new System.Windows.Media.Media3D.Quaternion();
                            RotationOperableEnsamble = System.Windows.Media.Media3D.Quaternion.Multiply(RotationOperableEnsamble, new System.Windows.Media.Media3D.Quaternion(axis2, angle2));

                            rotTrasl = GiveMeRotationRelativeAntenna(RotationOperableEnsamble);

                            pointSkinBlockCenter = new Point3D(-337.5f, 105, -1327.5);
                            //pointSkinBlockCenter = new Point3D(-337.5f, 93, -1327.5);

                            pointAntenna = pointSkinBlockCenter + Calculator.Instance.GiveMeVector3D(originalPositionSkinBlockCenter_WRS);

                            XPosOperableEnsamble = (float)pointAntenna.X;
                            YPosOperableEnsamble = (float)pointAntenna.Y;
                            ZPosOperableEnsamble = (float)pointAntenna.Z;

                            wft.hvView3D.CameraController.CameraUpDirection = new Vector3D(1, 0, 0);
                            wft.hvView3D.CameraController.CameraLookDirection = new Vector3D(0, -1, 0);
                            wft.hvView3D.CameraController.CameraPosition = new Point3D(pointAntenna.X + rotTrasl.X, pointAntenna.Y + deltaViewFar + rotTrasl.Y, pointAntenna.Z + rotTrasl.Z);
                            wft.hvView3D.LookAt(new Point3D(pointAntenna.X + rotTrasl.X, pointAntenna.Y + deltaViewNear / 3f * 2f + rotTrasl.Y, pointAntenna.Z + rotTrasl.Z), timeAnimation);
                            wft.startCircle.Normal = new Vector3D(0, 0, 1);
                            break;
                        }

                    #endregion SERRATUM

                    case Enum_Configuration.QLB: //OK

                        #region QLB

                        {
                            axis2 = new Vector3D(1, 0, 0);
                            angle2 = 90;
                            RotationOperableEnsamble = new System.Windows.Media.Media3D.Quaternion();
                            RotationOperableEnsamble = System.Windows.Media.Media3D.Quaternion.Multiply(RotationOperableEnsamble, new System.Windows.Media.Media3D.Quaternion(axis2, angle2));
                            axis3 = new Vector3D(0, 1, 0);
                            angle3 = 90;
                            RotationOperableEnsamble = System.Windows.Media.Media3D.Quaternion.Multiply(RotationOperableEnsamble, new System.Windows.Media.Media3D.Quaternion(axis3, angle3));

                            pointSkinBlockCenter = new Point3D(-240.5f, -35, -1079.5);
                            //pointSkinBlockCenter = new Point3D(-228.5f, -35, -1079.5);
                            pointAntenna = pointSkinBlockCenter + Calculator.Instance.GiveMeVector3D(originalPositionSkinBlockCenter_WRS);

                            XPosOperableEnsamble = (float)pointAntenna.X;
                            YPosOperableEnsamble = (float)pointAntenna.Y;
                            ZPosOperableEnsamble = (float)pointAntenna.Z;

                            rotTrasl = GiveMeRotationRelativeAntenna(RotationOperableEnsamble);

                            wft.hvView3D.CameraController.CameraUpDirection = new Vector3D(-0.2, .8, 0);
                            wft.hvView3D.CameraController.CameraLookDirection = new Vector3D(0.8, -0.2, 0);
                            wft.hvView3D.CameraController.CameraPosition = new Point3D(pointAntenna.X - deltaViewFar + rotTrasl.X, pointAntenna.Y + rotTrasl.Y + 50, pointAntenna.Z + rotTrasl.Z);
                            wft.startCircle.Normal = new Vector3D(-0.8, 0, 0.3);
                            wft.hvView3D.LookAt(new Point3D(pointAntenna.X - deltaViewNear + rotTrasl.X, pointAntenna.Y + rotTrasl.Y + 50, pointAntenna.Z + rotTrasl.Z), timeAnimation);
                            break;
                        }

                    #endregion QLB

                    default:
                        break;
                }
            }
        }

        public void SelectCurrentPhase(int index)

        {
            try
            {
                {
                    if ((WindowTeacher.PageContainer.Content is WorkingFrameTeacher) && (WindowStudent.PageContainer.Content is StudentFrame))
                    {
                        WorkingFrameTeacher wft = (WorkingFrameTeacher)WindowTeacher.PageContainer.Content;
                        StudentFrame sf = (StudentFrame)WindowStudent.PageContainer.Content;
                        if (CurrentCase != null)
                        {
                            if (CurrentCase.Phases.Count > 0)
                            {
                                EffectFasciaHitActivated = false;
                                EffectNerveHitActivated = false;
                                CurrentPhase = CurrentCase.Phases[index];


                                WindowStudent.spEllipseTarget.Visibility = Visibility.Collapsed;
                                WindowStudent.spLineTarget.Visibility = Visibility.Collapsed;
                                WindowStudent.spEllipseNotTarget.Visibility = Visibility.Collapsed;
                                WindowStudent.spEllipseVascular.Visibility = Visibility.Collapsed;
                                //Legenda Visualization
                                if (CurrentPhase.NerveMultipleInjections)
                                {
                                    int wn = CurrentPhase.TargetPointsNerve.Where(x => x.T == 1).Count();
                                    int vt = CurrentPhase.TargetPointsNerve.Where(x => x.T == 2).Count();

                                    WindowStudent.spEllipseTarget.Visibility = Visibility.Visible;
                                    if (wn>0)
                                    {
                                        WindowStudent.spEllipseNotTarget.Visibility = Visibility.Visible;
                                    }
                                    if (vt > 0)
                                    {
                                        WindowStudent.spEllipseVascular.Visibility = Visibility.Visible;
                                    }
                                }
                                else
                                {
                                    if ((CurrentPhase.PhaseType == Enum_Phases.INVESTIGATE_HOTSPOT_NEEDLE) || (CurrentPhase.PhaseType == Enum_Phases.INVESTIGATE_TRAJECTORY_NEEDLE))
                                    {
                                        if (CurrentPhase.MuscularBlock)
                                        {
                                            WindowStudent.spEllipseTarget.Visibility = Visibility.Visible;
                                        }
                                        else
                                        {
                                            WindowStudent.spLineTarget.Visibility = Visibility.Visible;
                                        }
                                    }
                                }



                                deformationsForNerveContinuousInjections.Clear();
                                TargetMissedNerve_Injections = 0;
                                AppControl.Instance.needlePoints_NRS = new List<VectorMath.Vector3>();
                                float step = 0.25f;

                                AppControl.Instance.LengthNeedle = AppControl.Instance.PhysicalLengthNeedle + (float)AppControl.Instance.TraslationFromSensor02ToNeedleStart.X + AppControl.Instance.CurrentPhase.AdditionalCorrectionLengthNeedle;

                                AppControl.Instance.numPointsNeedle = (int)((float)AppControl.Instance.LengthNeedle / step);
                                AppControl.Instance.IndexRealFinishNeedle = (int)(((float)AppControl.Instance.LengthNeedle - (float)AppControl.Instance.CurrentPhase.AdditionalCorrectionLengthNeedle) / step);

                                AppControl.Instance.needlePoints_WRS = new List<VectorMath.Vector3>();
                                AppControl.Instance.needlePoints_PRS = new List<VectorMath.Vector3>();

                                for (int i = 0; i < AppControl.Instance.numPointsNeedle; i++)
                                {
                                    AppControl.Instance.needlePoints_NRS.Add(new VectorMath.Vector3(i * step, 0, 0));
                                    AppControl.Instance.needlePoints_WRS.Add(new VectorMath.Vector3());
                                    AppControl.Instance.needlePoints_PRS.Add(new VectorMath.Vector3());
                                }

                                switch (CurrentCase.InsertTypeEnum)
                                {
                                    case Enum_InsertType.A:
                                        zPadSurface = Properties.Settings.Default.ZPadA;
                                        break;

                                    case Enum_InsertType.B:
                                        zPadSurface = Properties.Settings.Default.ZPadB;
                                        break;

                                    case Enum_InsertType.C:
                                        zPadSurface = Properties.Settings.Default.ZPadC;
                                        break;

                                    default:
                                        zPadSurface = Properties.Settings.Default.ZPadA;
                                        break;
                                }

                                //PIRINI 14.03.2021
                                //additionalLengthZForPunctureOnCurve = CurrentPhase.PunctureOnCurve ? Properties.Settings.Default.AdditionalZCurve : 0;
                                additionalLengthZForPunctureOnCurve = CurrentPhase.PunctureOnCurve ? 0 : 0;

                                foreach (Phase f in CurrentCase.Phases)
                                {
                                    if (f != CurrentPhase)
                                    {
                                        f.Selected = false;
                                    }
                                    else
                                    {
                                        f.Selected = true;
                                    }
                                }

                                SetText(sf.tbText, CurrentCase.Name + " - " + CurrentPhase.Description);
                                switch (CurrentPhase.PhaseType)
                                {
                                    case Enum_Phases.INVESTIGATE_TRAJECTORY:
                                    case Enum_Phases.INVESTIGATE_TRAJECTORY_NEEDLE:
                                        pointStart_WRS = Calculator.Instance.ChangeCoordinatesOfAPoint(CurrentPhase.PointStart_HRS, CenterOfWRS_inHRS, RotationMatrix_HRS_TO_WRS);
                                        pointEnd_WRS = Calculator.Instance.ChangeCoordinatesOfAPoint(CurrentPhase.PointEnd_HRS, CenterOfWRS_inHRS, RotationMatrix_HRS_TO_WRS);
                                        StartPath = new Point3D(pointStart_WRS.X, pointStart_WRS.Y, pointStart_WRS.Z);
                                        EndPath = new Point3D(pointEnd_WRS.X, pointEnd_WRS.Y, pointEnd_WRS.Z);
                                        break;

                                    case Enum_Phases.INVESTIGATE_HOTSPOT:
                                    case Enum_Phases.INVESTIGATE_HOTSPOT_NEEDLE:
                                        pointStart_WRS = Calculator.Instance.ChangeCoordinatesOfAPoint(CurrentPhase.PointStart_HRS, CenterOfWRS_inHRS, RotationMatrix_HRS_TO_WRS);
                                        StartPath = new Point3D(pointStart_WRS.X, pointStart_WRS.Y, pointStart_WRS.Z);
                                        EndPath = new Point3D(-1000, -1000, -1000);
                                        break;

                                    default:
                                        break;
                                }

                                if ((CurrentPhase.PhaseType == Enum_Phases.INVESTIGATE_TRAJECTORY_NEEDLE) || (CurrentPhase.PhaseType == Enum_Phases.INVESTIGATE_HOTSPOT_NEEDLE))
                                {
                                    StartNeedlePhaseTime = DateTime.Now;

                                    wft.bStopTheCase.Visibility = CurrentPhase.NerveMultipleInjections ? Visibility.Visible : Visibility.Hidden;
                                    sf.bStopTheCase.Visibility = CurrentPhase.NerveMultipleInjections ? Visibility.Visible : Visibility.Hidden;

                                    wft.bStopTheCase.IsEnabled = false;
                                    sf.bStopTheCase.IsEnabled = false;

                                    sf.tbNerveTarget.Visibility = CurrentPhase.NerveMultipleInjections ? Visibility.Visible : Visibility.Hidden;
                                    sf.tbFasciaTarget.Visibility = CurrentPhase.NerveMultipleInjections ? Visibility.Hidden : Visibility.Visible;
                                    sf.tbWrongInjections.Visibility = CurrentPhase.NerveMultipleInjections ? Visibility.Visible : Visibility.Hidden;

                                    sf.tbTextNerveTarget.Visibility = CurrentPhase.NerveMultipleInjections ? Visibility.Visible : Visibility.Hidden;
                                    sf.tbTextFasciaTarget.Visibility = CurrentPhase.NerveMultipleInjections ? Visibility.Hidden : Visibility.Visible;
                                    sf.tbTextWrongInjections.Visibility = CurrentPhase.NerveMultipleInjections ? Visibility.Visible : Visibility.Hidden;

                                    sf.tbNerveTargetExp.Visibility = CurrentPhase.NerveMultipleInjections ? Visibility.Visible : Visibility.Hidden;
                                    sf.tbFasciaTargetExp.Visibility = CurrentPhase.NerveMultipleInjections ? Visibility.Hidden : Visibility.Visible;
                                    sf.tbWrongInjectionsExp.Visibility = CurrentPhase.NerveMultipleInjections ? Visibility.Visible : Visibility.Hidden;

                                    wft.tbNerveTarget.Visibility = CurrentPhase.NerveMultipleInjections ? Visibility.Visible : Visibility.Hidden;
                                    wft.tbFasciaTarget.Visibility = CurrentPhase.NerveMultipleInjections ? Visibility.Hidden : Visibility.Visible;
                                    wft.tbWrongInjections.Visibility = CurrentPhase.NerveMultipleInjections ? Visibility.Visible : Visibility.Hidden;

                                    wft.tbTextNerveTarget.Visibility = CurrentPhase.NerveMultipleInjections ? Visibility.Visible : Visibility.Hidden;
                                    wft.tbTextFasciaTarget.Visibility = CurrentPhase.NerveMultipleInjections ? Visibility.Hidden : Visibility.Visible;
                                    wft.tbTextWrongInjections.Visibility = CurrentPhase.NerveMultipleInjections ? Visibility.Visible : Visibility.Hidden;

                                    wft.tbNerveTargetExp.Visibility = CurrentPhase.NerveMultipleInjections ? Visibility.Visible : Visibility.Hidden;
                                    wft.tbFasciaTargetExp.Visibility = CurrentPhase.NerveMultipleInjections ? Visibility.Hidden : Visibility.Visible;
                                    wft.tbWrongInjectionsExp.Visibility = CurrentPhase.NerveMultipleInjections ? Visibility.Visible : Visibility.Hidden;
                                }

                                if (CurrentPhase.ImEcoPhase)
                                {
                                    double ratio = 600.0 / Math.Max(CurrentPhase.WidthImage, CurrentPhase.HeightImage);

                                    hOrigin = CurrentPhase.HeightImage;
                                    wOrigin = CurrentPhase.WidthImage;
                                    hScaled = hOrigin * (float)ratio;
                                    wScaled = wOrigin * (float)ratio;

                                    sf.bCanvasEco.Width = wScaled;
                                    sf.bCanvasEco.Height = hScaled;
                                    sf.imEco.Width = wScaled;
                                    sf.imEco.Height = hScaled;

                                    offsetWidEco = wScaled / 2;
                                    offsetHeiEco = hScaled / 2;

                                    sf.hvViewEcoSharpDX3D.Width = wScaled;
                                    sf.hvViewEcoSharpDX3D.Height = hScaled;

                                    double ratio2 = 240.0 / Math.Max(CurrentPhase.WidthImage, CurrentPhase.HeightImage);
                                    wft.bCanvasEco.Width = CurrentPhase.WidthImage * ratio2;
                                    wft.bCanvasEco.Height = CurrentPhase.HeightImage * ratio2;

                                    wft.imEcoTeacher.Width = CurrentPhase.WidthImage * ratio2;
                                    wft.imEcoTeacher.Height = CurrentPhase.HeightImage * ratio2;

                                    wft.imMask.Width = CurrentPhase.WidthImage * ratio2;
                                    wft.imMask.Height = CurrentPhase.HeightImage * ratio2;
                                    wft.imMask.Source = new BitmapImage(new Uri(CurrentPhase.FolderImages + "\\Mask.png"));

                                    DepthImage_mm = CurrentPhase.DepthImage;
                                    MirrorImage = CurrentPhase.Mirror ? -1f : 1f;

                                    CenterMirrorEcoImage = (float)(sf.hvViewEcoSharpDX3D.Width) / 2f;

                                    WidthImage_mm = DepthImage_mm * (double)CurrentPhase.WidthImage / (double)CurrentPhase.HeightImage;

                                    OriginPlaneImage = new Point3D(-DepthImage_mm / 2.0, 0, 0);

                                    List<SharpDX.Vector3> pointsEffectScaled = new List<SharpDX.Vector3>();
                                    foreach (SharpDX.Vector3 v in CurrentPhase.PointsEffect)
                                    {
                                        pointsEffectScaled.Add(new SharpDX.Vector3(v.X * wScaled, v.Y * hScaled, 0.1f));
                                    }

                                    isFasciaOrNerve = (CurrentCase.Module == Enum_Modules.FasciaBlocks || CurrentCase.Module == Enum_Modules.Hip);

                                    SetUpModelFasciaOrNerve(CurrentPhase.EffectPresent, CurrentPhase.DeformableAreaType, (int)(CurrentPhase.HeightImage * ratio), (int)(CurrentPhase.WidthImage * ratio), CurrentPhase.RatioDeformUp, CurrentPhase.RatioDeformDown, CurrentPhase.StartingSurfaceType, pointsEffectScaled, CurrentPhase.TDeformation, CurrentPhase.EffectSize);
                                    if ((CurrentPhase.PhaseType != Enum_Phases.INVESTIGATE_HOTSPOT_NEEDLE) && (CurrentPhase.PhaseType != Enum_Phases.INVESTIGATE_TRAJECTORY_NEEDLE))
                                    {
                                        SetText(sf.tbIndicationsStudent, CurrentPhase.MessageToStudent);
                                        if (ModelMaterialDeformableArea != null)
                                        {
                                            ModelMaterialDeformableArea.DiffuseColor = new SharpDX.Color4(255, 255, 255, 0);
                                        }
                                    }
                                    else
                                    {
                                        SetText(sf.tbIndicationsStudent, StringNeedleInjFindFrame);
                                        if (File.Exists(CurrentPhase.FolderImages + "\\" + nameFileDefinitionSave))
                                        {
                                            framesDefinition = InfoFrames.Load<InfoFrames>(CurrentPhase.FolderImages + "\\" + nameFileDefinitionSave);
                                        }
                                        else
                                        {
                                            framesDefinition = new InfoFrames(CurrentPhase.NumberOfImages);
                                            framesDefinition.Save<InfoFrames>(CurrentPhase.NumberOfImages + "\\" + nameFileDefinitionSave);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception)
            {
            }
        }

        public void SetEnabled(UIElement lbl, bool enabled)
        {
            if (!WindowTeacher.Dispatcher.CheckAccess())
            {
                SetEnabledDelegate d = new SetEnabledDelegate(SetEnabled);
                WindowTeacher.Dispatcher.Invoke(d, new object[] { lbl, enabled });
            }
            else
            {
                lbl.IsEnabled = enabled;
            }
        }

        public void SetImage(float err, BitmapSource imagePassed, BitmapSource imagePassedTeacher, LimitDefinition maxLimit, bool hideAll, int indexImage)
        {
            try
            {
                if (!hideAll)
                {
                    if (imagePassed != null)
                    {
                        imagePassed.Freeze();
                    }
                }
                if (imagePassedTeacher != null)
                {
                    imagePassedTeacher.Freeze();
                }
                WindowTeacher.Dispatcher.BeginInvoke(
            new ThreadStart(() =>
            {
                try
                {
                    if (hideAll)
                    {
                        VisibilityBorderArrowDown = Visibility.Hidden;
                        VisibilityBorderArrowLeft = Visibility.Hidden;
                        VisibilityBorderArrowRight = Visibility.Hidden;
                        VisibilityBorderArrowRotation = Visibility.Hidden;
                        VisibilityBorderArrowRotation2 = Visibility.Hidden;
                        VisibilityBorderArrowUp = Visibility.Hidden;
                    }
                    else
                    {
                        if (err > 0)
                        {
                            ImEcoSource = imagePassed;

                            if ((WindowTeacher.PageContainer.Content is WorkingFrameTeacher))
                            {
                                WorkingFrameTeacher wft = (WorkingFrameTeacher)WindowTeacher.PageContainer.Content;
                                ImEcoSourceTeacher = imagePassedTeacher;
                                wft.imEcoTeacher.Effect = AppControl.Instance.myBlurEffect;
                            }
                            VisibilityViewEcoImage = Visibility.Visible;
                            VisibilityViewEcoSharpDX = Visibility.Hidden;

                            switch (maxLimit.variableTypeLimit)
                            {
                                case Enum_VariableTypeLimit.X:
                                    {
                                        switch (CurrentCase.TypeBlock)
                                        {
                                            case Enum_Configuration.N_INFRACLAVICULAR:
                                                {
                                                    VisibilityBorderArrowRight = Visibility.Hidden;
                                                    VisibilityBorderArrowLeft = Visibility.Hidden;
                                                    VisibilityBorderArrowDown = maxLimit.ExceededMax ? Visibility.Visible : Visibility.Hidden;
                                                    VisibilityBorderArrowUp = maxLimit.ExceededMin ? Visibility.Visible : Visibility.Hidden;
                                                    VisibilityBorderArrowRotation = Visibility.Hidden;
                                                    VisibilityBorderArrowRotation2 = Visibility.Hidden;

                                                    break;
                                                }
                                        }

                                        break;
                                    }
                                case Enum_VariableTypeLimit.Y:
                                    {
                                        switch (CurrentCase.TypeBlock)
                                        {
                                            case Enum_Configuration.STUDIO:
                                            case Enum_Configuration.PARAVERTEBRAL:
                                            case Enum_Configuration.PECS2:
                                            case Enum_Configuration.TAP:
                                            case Enum_Configuration.LUMBAR:
                                            case Enum_Configuration.QLB:
                                            case Enum_Configuration.PECS1:
                                            case Enum_Configuration.SERRATUM:
                                            case Enum_Configuration.N_AXILLARY_BP:
                                            case Enum_Configuration.N_INFRACLAVICULAR:
                                            case Enum_Configuration.N_LUMBARPLEXUS:
                                            
                                                VisibilityBorderArrowDown = Visibility.Hidden;
                                                VisibilityBorderArrowUp = Visibility.Hidden;
                                                VisibilityBorderArrowRight = maxLimit.ExceededMax ? Visibility.Visible : Visibility.Hidden;
                                                VisibilityBorderArrowLeft = maxLimit.ExceededMin ? Visibility.Visible : Visibility.Hidden;
                                                VisibilityBorderArrowRotation = Visibility.Hidden;
                                                VisibilityBorderArrowRotation2 = Visibility.Hidden;
                                                break;



                                            case Enum_Configuration.N_ADDUCTORCANAL:
                                            
                                                VisibilityBorderArrowUp = maxLimit.ExceededMax ? Visibility.Visible : Visibility.Hidden;
                                                VisibilityBorderArrowDown = maxLimit.ExceededMin ? Visibility.Visible : Visibility.Hidden;
                                                VisibilityBorderArrowRight = Visibility.Hidden;
                                                VisibilityBorderArrowLeft = Visibility.Hidden;
                                                VisibilityBorderArrowRotation = Visibility.Hidden;
                                                VisibilityBorderArrowRotation2 = Visibility.Hidden;
                                                break;

                                            case Enum_Configuration.N_FEMURAL:
                                            case Enum_Configuration.N_SCIATIC_POPLITEAL:
                                            case Enum_Configuration.N_SCIATIC_GLUTEAL:
                                                VisibilityBorderArrowDown = maxLimit.ExceededMax ? Visibility.Visible : Visibility.Hidden;
                                                VisibilityBorderArrowUp = maxLimit.ExceededMin ? Visibility.Visible : Visibility.Hidden;
                                                VisibilityBorderArrowRight = Visibility.Hidden;
                                                VisibilityBorderArrowLeft = Visibility.Hidden;
                                                VisibilityBorderArrowRotation = Visibility.Hidden;
                                                VisibilityBorderArrowRotation2 = Visibility.Hidden;
                                                break;

                                            case Enum_Configuration.PARASTERNAL:
                                            case Enum_Configuration.N_INTERSCALENE_BP:
                                            case Enum_Configuration.N_SUPRACLAVICULAR:
                                                VisibilityBorderArrowDown = Visibility.Hidden;
                                                VisibilityBorderArrowUp = Visibility.Hidden;
                                                VisibilityBorderArrowLeft = maxLimit.ExceededMax ? Visibility.Visible : Visibility.Hidden;
                                                VisibilityBorderArrowRight = maxLimit.ExceededMin ? Visibility.Visible : Visibility.Hidden;
                                                VisibilityBorderArrowRotation = Visibility.Hidden;
                                                VisibilityBorderArrowRotation2 = Visibility.Hidden;
                                                break;

                                            case Enum_Configuration.ESP:

                                                VisibilityBorderArrowUp = Visibility.Hidden;
                                                VisibilityBorderArrowDown = Visibility.Hidden;
                                                VisibilityBorderArrowRight = maxLimit.ExceededMax ? Visibility.Visible : Visibility.Hidden;
                                                VisibilityBorderArrowLeft = maxLimit.ExceededMin ? Visibility.Visible : Visibility.Hidden;
                                                VisibilityBorderArrowRotation = Visibility.Hidden;
                                                VisibilityBorderArrowRotation2 = Visibility.Hidden;
                                                break;

                                            default:
                                                break;
                                        }

                                        break;
                                    }
                                case Enum_VariableTypeLimit.Z:
                                    {
                                        switch (CurrentCase.TypeBlock)
                                        {
                                            case Enum_Configuration.STUDIO:
                                            case Enum_Configuration.PARAVERTEBRAL:
                                            case Enum_Configuration.PECS2:
                                            case Enum_Configuration.TAP:
                                            case Enum_Configuration.LUMBAR:
                                            case Enum_Configuration.QLB:
                                            case Enum_Configuration.PECS1:
                                            case Enum_Configuration.SERRATUM:
                                            case Enum_Configuration.PARASTERNAL:
                                            case Enum_Configuration.N_AXILLARY_BP:
                                            case Enum_Configuration.N_INTERSCALENE_BP:
                                            case Enum_Configuration.N_LUMBARPLEXUS:
                                            
                                                VisibilityBorderArrowDown = maxLimit.ExceededMax ? Visibility.Visible : Visibility.Hidden;
                                                VisibilityBorderArrowUp = maxLimit.ExceededMin ? Visibility.Visible : Visibility.Hidden;
                                                VisibilityBorderArrowRight = Visibility.Hidden;
                                                VisibilityBorderArrowLeft = Visibility.Hidden;
                                                VisibilityBorderArrowRotation = Visibility.Hidden;
                                                VisibilityBorderArrowRotation2 = Visibility.Hidden;
                                                break;

                                            case Enum_Configuration.N_SUPRACLAVICULAR:
                                                VisibilityBorderArrowUp = maxLimit.ExceededMax ? Visibility.Visible : Visibility.Hidden;
                                                VisibilityBorderArrowDown = maxLimit.ExceededMin ? Visibility.Visible : Visibility.Hidden;
                                                VisibilityBorderArrowRight = Visibility.Hidden;
                                                VisibilityBorderArrowLeft = Visibility.Hidden;
                                                VisibilityBorderArrowRotation = Visibility.Hidden;
                                                VisibilityBorderArrowRotation2 = Visibility.Hidden;
                                                break;

                                            case Enum_Configuration.ESP:
                                                VisibilityBorderArrowDown = maxLimit.ExceededMax ? Visibility.Visible : Visibility.Hidden;
                                                VisibilityBorderArrowUp = maxLimit.ExceededMin ? Visibility.Visible : Visibility.Hidden;
                                                VisibilityBorderArrowLeft = Visibility.Hidden;
                                                VisibilityBorderArrowRight = Visibility.Hidden;
                                                VisibilityBorderArrowRotation = Visibility.Hidden;
                                                VisibilityBorderArrowRotation2 = Visibility.Hidden;
                                                break;

                                            case Enum_Configuration.N_ADDUCTORCANAL:
                                            
                                                VisibilityBorderArrowDown = Visibility.Hidden;
                                                VisibilityBorderArrowUp = Visibility.Hidden;
                                                VisibilityBorderArrowRight = maxLimit.ExceededMax ? Visibility.Visible : Visibility.Hidden;
                                                VisibilityBorderArrowLeft = maxLimit.ExceededMin ? Visibility.Visible : Visibility.Hidden;
                                                VisibilityBorderArrowRotation = Visibility.Hidden;
                                                VisibilityBorderArrowRotation2 = Visibility.Hidden;
                                                break;
                                            case Enum_Configuration.N_FEMURAL:
                                            case Enum_Configuration.N_SCIATIC_POPLITEAL:
                                            case Enum_Configuration.N_SCIATIC_GLUTEAL:
                                                VisibilityBorderArrowDown = Visibility.Hidden;
                                                VisibilityBorderArrowUp = Visibility.Hidden;
                                                VisibilityBorderArrowLeft = maxLimit.ExceededMax ? Visibility.Visible : Visibility.Hidden;
                                                VisibilityBorderArrowRight = maxLimit.ExceededMin ? Visibility.Visible : Visibility.Hidden;
                                                VisibilityBorderArrowRotation = Visibility.Hidden;
                                                VisibilityBorderArrowRotation2 = Visibility.Hidden;
                                                break;
                                        }

                                        break;
                                    }
                                case Enum_VariableTypeLimit.YZ:
                                    //this is valid for PECS1
                                    //this is valid for FasciaIliaca
                                    VisibilityBorderArrowUp = (maxLimit.variableLimitExceeded == Enum_VariableTypeLimit.Y && maxLimit.ExceededMax) ? Visibility.Visible : Visibility.Hidden;
                                    VisibilityBorderArrowDown = (maxLimit.variableLimitExceeded == Enum_VariableTypeLimit.Y && maxLimit.ExceededMin) ? Visibility.Visible : Visibility.Hidden;
                                    VisibilityBorderArrowRight = (maxLimit.variableLimitExceeded == Enum_VariableTypeLimit.Z && maxLimit.ExceededMax) ? Visibility.Visible : Visibility.Hidden;
                                    VisibilityBorderArrowLeft = (maxLimit.variableLimitExceeded == Enum_VariableTypeLimit.Z && maxLimit.ExceededMin) ? Visibility.Visible : Visibility.Hidden;
                                    VisibilityBorderArrowRotation = Visibility.Hidden;
                                    VisibilityBorderArrowRotation2 = Visibility.Hidden;
                                    break;

                                case Enum_VariableTypeLimit.YAW:
                                    break;

                                case Enum_VariableTypeLimit.PITCH:
                                    {
                                        switch (CurrentCase.TypeBlock)
                                        {
                                            case Enum_Configuration.N_INFRACLAVICULAR:
                                                VisibilityBorderArrowDown = Visibility.Hidden;
                                                VisibilityBorderArrowUp = Visibility.Hidden;
                                                VisibilityBorderArrowRight = Visibility.Hidden;
                                                VisibilityBorderArrowLeft = Visibility.Hidden;
                                                VisibilityBorderArrowRotation = maxLimit.ExceededMax ? Visibility.Visible : Visibility.Hidden;
                                                VisibilityBorderArrowRotation2 = maxLimit.ExceededMin ? Visibility.Visible : Visibility.Hidden;
                                                break;
                                        }
                                    }
                                    break;

                                case Enum_VariableTypeLimit.ROLL:
                                case Enum_VariableTypeLimit.ROLL_OFFSET180:
                                    switch (CurrentCase.TypeBlock)
                                    {
                                        case Enum_Configuration.N_INTERSCALENE_BP:
                                            VisibilityBorderArrowDown = Visibility.Hidden;
                                            VisibilityBorderArrowUp = Visibility.Hidden;
                                            VisibilityBorderArrowRight = Visibility.Hidden;
                                            VisibilityBorderArrowLeft = Visibility.Hidden;
                                            VisibilityBorderArrowRotation2 = maxLimit.ExceededMax ? Visibility.Visible : Visibility.Hidden;
                                            VisibilityBorderArrowRotation = maxLimit.ExceededMin ? Visibility.Visible : Visibility.Hidden;
                                            break;
                                        case Enum_Configuration.N_SCIATIC_POPLITEAL:
                                            VisibilityBorderArrowDown = Visibility.Hidden;
                                            VisibilityBorderArrowUp = Visibility.Hidden;
                                            VisibilityBorderArrowRight = Visibility.Hidden;
                                            VisibilityBorderArrowLeft = Visibility.Hidden;
                                            VisibilityBorderArrowRotation2 = maxLimit.ExceededMax ? Visibility.Visible : Visibility.Hidden;
                                            VisibilityBorderArrowRotation = maxLimit.ExceededMin ? Visibility.Visible : Visibility.Hidden;
                                            break;
                                        default:
                                            VisibilityBorderArrowDown = Visibility.Hidden;
                                            VisibilityBorderArrowUp = Visibility.Hidden;
                                            VisibilityBorderArrowRight = Visibility.Hidden;
                                            VisibilityBorderArrowLeft = Visibility.Hidden;
                                            VisibilityBorderArrowRotation = maxLimit.ExceededMax ? Visibility.Visible : Visibility.Hidden;
                                            VisibilityBorderArrowRotation2 = maxLimit.ExceededMin ? Visibility.Visible : Visibility.Hidden;
                                            break;
                                    }
                                    break;
                                case Enum_VariableTypeLimit.ROLLABS:
                                    {
                                        switch (CurrentCase.TypeBlock)
                                        {
                                            case Enum_Configuration.STUDIO:
                                            case Enum_Configuration.PARAVERTEBRAL:
                                            case Enum_Configuration.PECS2:
                                            case Enum_Configuration.TAP:
                                            case Enum_Configuration.LUMBAR:
                                            case Enum_Configuration.QLB:
                                            case Enum_Configuration.PECS1:
                                            case Enum_Configuration.SERRATUM:
                                            case Enum_Configuration.ESP:
                                           
                                                VisibilityBorderArrowDown = Visibility.Hidden;
                                                VisibilityBorderArrowUp = Visibility.Hidden;
                                                VisibilityBorderArrowRight = Visibility.Hidden;
                                                VisibilityBorderArrowLeft = Visibility.Hidden;
                                                VisibilityBorderArrowRotation = maxLimit.ExceededMax ? Visibility.Visible : Visibility.Hidden;
                                                VisibilityBorderArrowRotation2 = maxLimit.ExceededMin ? Visibility.Visible : Visibility.Hidden;
                                                break;

                                            case Enum_Configuration.PARASTERNAL:
                                                VisibilityBorderArrowDown = Visibility.Hidden;
                                                VisibilityBorderArrowUp = Visibility.Hidden;
                                                VisibilityBorderArrowRight = Visibility.Hidden;
                                                VisibilityBorderArrowLeft = Visibility.Hidden;
                                                VisibilityBorderArrowRotation2 = maxLimit.ExceededMax ? Visibility.Visible : Visibility.Hidden;
                                                VisibilityBorderArrowRotation = maxLimit.ExceededMin ? Visibility.Visible : Visibility.Hidden;
                                                break;
                                        }
                                        break;
                                    }
                            }
                        }
                        else
                        {
                            if (!EffectFasciaHitActivated)
                            {
                                if (indexImage != -1)
                                {
                                    VisibilityViewEcoImage = probeOnSkin ? Visibility.Hidden : Visibility.Visible;
                                    VisibilityViewEcoSharpDX = probeOnSkin ? Visibility.Visible : Visibility.Hidden;

                                    if (CurrentPhase.RequireAnimation())
                                    {
                                        if (indexImage + CurrentPhase.StartIndexImages < ImagesBackGround.Count)
                                        {
                                            ModelMaterial.DiffuseMap = animator2.GetStreamFromBitmapSource(
                                                                            animator2.GetAnimationFrame(
                                                                                new PleuralAnimationParameters(CurrentPhase, indexImage,
                                                                                                               animator2.GetBitmapSourceFromStream(ImagesBackGround[indexImage + CurrentPhase.StartIndexImages]), true)));
                                        }
                                    }
                                    else
                                    {
                                        Stream bmp = new MemoryStream();

                                        BitmapEncoder enc = new BmpBitmapEncoder();
                                        enc.Frames.Add(BitmapFrame.Create(imagePassed));
                                        enc.Save(bmp);

                                        ModelMaterial.DiffuseMap = bmp; /*ImagesBackGround[indexImage + CurrentPhase.StartIndexImages];*/
                                    }

                                    if ((WindowTeacher.PageContainer.Content is WorkingFrameTeacher))
                                    {
                                        WorkingFrameTeacher wft = (WorkingFrameTeacher)WindowTeacher.PageContainer.Content;
                                        ImEcoSourceTeacher = imagePassedTeacher;
                                        wft.imEcoTeacher.Effect = probeOnSkin ? null : AppControl.Instance.myBlurEffect;
                                    }

                                    VisibilityBorderArrowDown = Visibility.Hidden;
                                    VisibilityBorderArrowLeft = Visibility.Hidden;
                                    VisibilityBorderArrowRight = Visibility.Hidden;
                                    VisibilityBorderArrowRotation = Visibility.Hidden;
                                    VisibilityBorderArrowRotation2 = Visibility.Hidden;
                                    VisibilityBorderArrowUp = Visibility.Hidden;
                                }
                            }
                        }
                    }
                }
                catch (Exception ex)
                {
                }
            }));
            }
            catch (Exception)
            {
            }
        }

        public void SetIndicator(System.Windows.Shapes.Ellipse bb, bool active)
        {
            if (!WindowTeacher.Dispatcher.CheckAccess())
            {
                SetIndicatorDelegate d = new SetIndicatorDelegate(SetIndicator);
                WindowTeacher.Dispatcher.Invoke(d, new object[] { bb, active });
            }
            else
            {
                bb.Fill = active ? ActiveEllipse : Brushes.Gray;
            }
        }

        public void SetText(TextBlock lbl, string text)
        {
            if (!WindowTeacher.Dispatcher.CheckAccess())
            {
                SetTextDelegate d = new SetTextDelegate(SetText);
                WindowTeacher.Dispatcher.Invoke(d, new object[] { lbl, text });
            }
            else
            {
                lbl.Text = text;
            }
        }

        private List<LineBuilder> lineBuildersNerveTarget;

        public void SetUpModelFasciaOrNerve(bool effectPresent, Enum_DeformableAreaType defAreaType, int height, int width, float ratioDeformUp, float ratioDeformDown, Enum_StartingSurface startingSurface, List<SharpDX.Vector3> pointsStartingSurface, float ratioDeformation, float effectSize)
        {
            if (isFasciaOrNerve)
            {
                originalEffectPOints.Clear();
                foreach (SharpDX.Vector3 vec in pointsStartingSurface)
                {
                    originalEffectPOints.Add(new SharpDX.Vector3(vec.X, vec.Y, vec.Z));
                }

                StopAnimation();
                EffectPresent = effectPresent;
            }
            else
            {
                timerDeformation.Stop();
            }
            ModelMaterial = new HelixToolkit.Wpf.SharpDX.DiffuseMaterial();
            ModelMaterialMask = new HelixToolkit.Wpf.SharpDX.DiffuseMaterial();
            if (isFasciaOrNerve)
            {
                if (dispatcherTimerAnimation.IsEnabled)
                {
                    StopAnimation();
                }
            }

            var builder = new MeshBuilder(true);
            var builderMask = new MeshBuilder(true);

            var lineBuilder = new LineBuilder();
            var lineBuilderEffect = new LineBuilder();
            var lineBuilderEffectPerp = new LineBuilder();
            var lineBuilderIndication = new LineBuilder();
            var lineBuilderMuscularTargetIndication = new LineBuilder();
            var lineBuilderLine1 = new LineBuilder();
            var lineBuilderLine2 = new LineBuilder();
            lineBuildersNerveTarget = new List<LineBuilder>();
            TargetsNerveIndication = new List<LineGeometry3D>();
            pointsNerve = new List<List<SharpDX.Vector3>>();
            Width = width;
            Height = height;

            // camera setup
            Camera = new HelixToolkit.Wpf.SharpDX.OrthographicCamera
            {
                Position = new Point3D(0, 0, 1),
                Width = this.Width,
                LookDirection = new Vector3D(0, 0, 1),
                UpDirection = new Vector3D(0, 1, 0),
                FarPlaneDistance = 25000
            };

            BlockX = Width / (float)(NumPointsX - 1);
            BlockY = Height / (float)(NumPointsY - 1);

            pointsDX = new SharpDX.Vector3[NumPointsX * NumPointsY];
            for (int i = 0; i < NumPointsX; ++i)
            {
                for (int j = 0; j < NumPointsY; ++j)
                {
                    pointsDX[i * NumPointsX + j] = new SharpDX.Vector3(i * Width / (NumPointsX - 1) - Width / 2, j * Height / (NumPointsY - 1) - Height / 2, 0);
                }
            }
            pointsDXMask = new SharpDX.Vector3[NumPointsX * NumPointsY];
            for (int i = 0; i < NumPointsX; ++i)
            {
                for (int j = 0; j < NumPointsY; ++j)
                {
                    pointsDXMask[i * NumPointsX + j] = new SharpDX.Vector3(i * Width / (NumPointsX - 1) - Width / 2, j * Height / (NumPointsY - 1) - Height / 2, -5);
                }
            }

            builder.AddRectangularMesh(pointsDX, NumPointsX);
            builderMask.AddRectangularMesh(pointsDXMask, NumPointsX);

            Model = builder.ToMesh();
            Model.IsDynamic = true;
            ModelMask = builderMask.ToMesh();
            ModelMask.IsDynamic = true;
            for (int i = 0; i < Model.TextureCoordinates.Count; i++)
            {
                Model.TextureCoordinates[i] = new SharpDX.Vector2(1 - Model.TextureCoordinates[i].Y, 1 - Model.TextureCoordinates[i].X);
            }
            for (int i = 0; i < ModelMask.TextureCoordinates.Count; i++)
            {
                ModelMask.TextureCoordinates[i] = new SharpDX.Vector2(1 - ModelMask.TextureCoordinates[i].Y, 1 - ModelMask.TextureCoordinates[i].X);
            }

            ModelMaterial.DiffuseMap = LoadTexture("scacchiera.jpg");
            ModelMaterialMask.DiffuseMap = LoadTexture(CurrentPhase.FolderImages + "\\Mask.png");
            ModelMaterial.EnableUnLit = true;
            ModelMaterialMask.EnableUnLit = true;

            lineBuilder.AddLine(new SharpDX.Vector3(100, 100, -3), new SharpDX.Vector3(200, 200, -3));
            lineBuilderLine1.AddLine(new SharpDX.Vector3(100, 100, -3), new SharpDX.Vector3(200, 200, -3));
            lineBuilderLine2.AddLine(new SharpDX.Vector3(100, 100, -3), new SharpDX.Vector3(200, 200, -3));
            lineBuilderIndication.AddLine(new SharpDX.Vector3(-100, -100, -3), new SharpDX.Vector3(-200, -200, -3));
            lineBuilderMuscularTargetIndication.AddCircle(new SharpDX.Vector3(0, 0, -3), new SharpDX.Vector3(0, 0, 1), MaximumDistanceNeedleToMusclePixel, 20);

            lineBuildersNerveTarget.Clear();
            foreach (TargetPointNerve item in CurrentPhase.TargetPointsNerve)
            {
                lineBuildersNerveTarget.Add(new LineBuilder());
                lineBuildersNerveTarget.Last().AddCircle(new SharpDX.Vector3(0, 0, -3), new SharpDX.Vector3(0, 0, 1), (float)item.R * Width, 20);
            }

            NeedleArea = lineBuilder.ToLineGeometry3D();
            NeedleAreaLine1 = lineBuilderLine1.ToLineGeometry3D();
            NeedleAreaLine2 = lineBuilderLine2.ToLineGeometry3D();
            NeedleAreaIndication = lineBuilderIndication.ToLineGeometry3D();

            TargetMuscularIndication = lineBuilderMuscularTargetIndication.ToLineGeometry3D();
            pointsCircle.Clear();
            foreach (SharpDX.Vector3 v3 in targetMuscularIndication.Positions)
            {
                pointsCircle.Add(new SharpDX.Vector3(v3.X, v3.Y, 0));
            }

            pointsNerve.Clear();
            foreach (LineBuilder item in lineBuildersNerveTarget)
            {
                TargetsNerveIndication.Add(item.ToLineGeometry3D());
                pointsNerve.Add(new List<SharpDX.Vector3>());
                foreach (SharpDX.Vector3 v3 in TargetsNerveIndication.Last().Positions)
                {
                    pointsNerve.Last().Add(new SharpDX.Vector3(v3.X, v3.Y, 0));
                }
            }

            lineBuilderEffect.AddLine(new SharpDX.Vector3(1, 1, 0), new SharpDX.Vector3(2, 2, 0));
            lineBuilderEffectPerp.AddLine(new SharpDX.Vector3(1, 1, 0), new SharpDX.Vector3(2, 2, 0));
            NeedleAreaEffect = lineBuilderEffect.ToLineGeometry3D();
            NeedleAreaEffectPerp = lineBuilderEffectPerp.ToLineGeometry3D();

            index_points_to_move.Clear();

            if (isFasciaOrNerve)
            {
                if (EffectPresent)
                {
                    var builderDeformableArea = new MeshBuilder(true);

                    DeformableAreaType = defAreaType;
                    switch (DeformableAreaType)
                    {
                        case Enum_DeformableAreaType.LOZANGE_ARC:
                        case Enum_DeformableAreaType.LOZANGE_DOUBLEV:

                            //losanga
                            deformableArea = new LozangeArea();
                            deformableArea.DeformableAreaType = DeformableAreaType;
                            deformableArea.StartingSurface = startingSurface;
                            deformableArea.DefiningPointsSurface = pointsStartingSurface;
                            deformableArea.tAppliedDeformation = ratioDeformation;
                            deformableArea.RatioDeformUp = ratioDeformUp;
                            deformableArea.RatioDeformDown = ratioDeformDown;
                            deformableArea.EffectSize = effectSize;
                            break;

                        case Enum_DeformableAreaType.CIRCULAR_ENLARGEMENT:
                            break;

                        default:
                            break;
                    }

                    deformableArea.Create();

                    builderDeformableArea.AddRectangularMesh(deformableArea.GiveMeBorderPoints(DisplacementDeformableArea), DeformableArea.NUMPOINTS_SIDE);
                    if (ModelDeformableArea != null)
                    {
                        ModelDeformableArea = null;
                    }

                    ModelDeformableArea = builderDeformableArea.ToMesh();
                    modelDeformableArea.CalculateNormals();
                    ModelDeformableArea.IsDynamic = true;

                    ModelMaterialDeformableArea = new HelixToolkit.Wpf.SharpDX.DiffuseMaterial();
                    SetModelMaterialDeformableArea(true, false, false);
                }
            }
            if (isFasciaOrNerve)
            {
                if (EffectPresent)
                {
                    UpdatePointsFascia(false, false);
                }
            }
            else
            {
                UpdatePointsNerve_FullImage(new List<SmartGridPoint2>());
                timerDeformation.Start();
            }
        }

        public void StartAnimation()
        {
            dispatcherTimerAnimation.Start();
            if (ChangeTimerStateEvent != null)
            {
                ChangeTimerStateEvent(true);
            }
        }

        public void StopAnimation()
        {
            if (dispatcherTimerAnimation.IsEnabled)
            {
                dispatcherTimerAnimation.Stop();
                if (ChangeTimerStateEvent != null)
                {
                    ChangeTimerStateEvent(false);
                }
            }
        }

        public void StopCase(bool IhaveToSaveResults)
        {
            if (IhaveToSaveResults)
            {
                AppControl.Instance.SaveResult();
            }
            ToElaborateData = false;
        }

        public void InjectAnesthetic()
        {
            if ((WindowTeacher.PageContainer.Content is WorkingFrameTeacher))
            {
                WorkingFrameTeacher wft = (WorkingFrameTeacher)WindowTeacher.PageContainer.Content;
                StudentFrame sf = (StudentFrame)WindowStudent.PageContainer.Content;
                if (CurrentPhase != null)
                {
                    if ((CurrentPhase.PhaseType == Enum_Phases.INVESTIGATE_HOTSPOT_NEEDLE) || (CurrentPhase.PhaseType == Enum_Phases.INVESTIGATE_TRAJECTORY_NEEDLE))
                    {

                        if (needleInSkin || DemoMode)
                        {
                            if (!CurrentPhase.NerveMultipleInjections)
                            {
                                ResetPoints();
                                if (!CurrentPhase.MuscularBlock)
                                {
                                    if ((DistanceNeedleToFascia < MaximumDIstanceNeedleToFasciaPixel) && (IntervalNeedleToFascia > 0.05) && (IntervalNeedleToFascia < 0.95))
                                    {
                                        DistanceNeedleToFasciaAtPunture = DistanceNeedleToFascia;
                                        NeedleTargetedFascia = true;
                                        IntervalNeedleToFasciaAtPunture = IntervalNeedleToFascia;

                                        float t = IntervalNeedleToFasciaAtPunture;
                                        if (t > 0.9) t = 0.9f;
                                        if (t < 0.1) t = 0.1f;
                                        UpdateDeformableArea(t);

                                        //DisplacementDeformableArea = DisplacementDeformableArea + new SharpDX.Vector3(0, DistanceNeedleToFascia * (UpperOrLowerLine ? 1.0f : -1.0f), 0);
                                        WindowTeacher.Dispatcher.Invoke(() =>
                                        {
                                            ModelMaterialDeformableArea = null;
                                            SetModelMaterialDeformableArea(false, true, CurrentPhase.EffectLiquidVisible);
                                        });
                                        MaxEffect = CurrentPhase.EffectSize;
                                        SetText(sf.tbIndicationsStudent, StringNeedleInjCorrectTarget);
                                    }
                                    else
                                    {
                                        DistanceNeedleToFasciaAtPunture = DistanceNeedleToFascia;
                                        NeedleTargetedFascia = false;
                                        IntervalNeedleToFasciaAtPunture = IntervalNeedleToFascia;
                                        DisplacementDeformableArea = DisplacementDeformableArea + Vector2CentralPoint;
                                        WindowTeacher.Dispatcher.Invoke(() =>
                                        {
                                            SetModelMaterialDeformableArea(false, false, false);
                                        });
                                        MaxEffect = (float)CurrentPhase.EffectSizeWrong;
                                        SetText(sf.tbIndicationsStudent, StringNeedleInjWrongTarget);
                                    }

                                    DistanceNeedleToFasciaAtPuntureMM = DistanceNeedleToFascia * RatioVisualizationMMperPixel;
                                }
                                else
                                {
                                    TargetMuscularIndicationColor = System.Windows.Media.Color.FromArgb(0, 0, 255, 255);
                                    if ((DistanceNeedleToFascia < MaximumDistanceNeedleToMusclePixel))
                                    {
                                        DistanceNeedleToFasciaAtPunture = DistanceNeedleToFascia;
                                        NeedleTargetedFascia = true;
                                        IntervalNeedleToFasciaAtPunture = IntervalNeedleToFascia;

                                        float t = IntervalNeedleToFasciaAtPunture;
                                        if (t > 0.9) t = 0.9f;
                                        if (t < 0.1) t = 0.1f;
                                        DisplacementDeformableArea = DisplacementDeformableArea + new SharpDX.Vector3(Vector2CentralPoint.X, Vector2CentralPoint.Y, 0);
                                        UpdateDeformableArea(t);

                                        //DisplacementDeformableArea = DisplacementDeformableArea + new SharpDX.Vector3(0, DistanceNeedleToFascia * (UpperOrLowerLine ? 1.0f : -1.0f), 0);
                                        WindowTeacher.Dispatcher.Invoke(() =>
                                        {
                                            ModelMaterialDeformableArea = null;
                                            SetModelMaterialDeformableArea(false, true, CurrentPhase.EffectLiquidVisible);
                                        });
                                        MaxEffect = CurrentPhase.EffectSize;
                                        SetText(sf.tbIndicationsStudent, StringNeedleInjCorrectTarget);
                                    }
                                    else
                                    {
                                        DistanceNeedleToFasciaAtPunture = DistanceNeedleToFascia;
                                        NeedleTargetedFascia = false;
                                        IntervalNeedleToFasciaAtPunture = IntervalNeedleToFascia;
                                        DisplacementDeformableArea = DisplacementDeformableArea + Vector2CentralPoint;
                                        WindowTeacher.Dispatcher.Invoke(() =>
                                        {
                                            SetModelMaterialDeformableArea(false, false, false);
                                        });
                                        MaxEffect = (float)CurrentPhase.EffectSizeWrong;
                                        SetText(sf.tbIndicationsStudent, StringNeedleInjWrongTarget);
                                    }

                                    DistanceNeedleToFasciaAtPuntureMM = DistanceNeedleToFascia * RatioVisualizationMMperPixel;
                                }
                                wft.lvPhases.IsEnabled = false;
                                wft.grControls.IsEnabled = false;
                                wft.bCaseInfo.IsEnabled = false;
                                sf.grIndicationsStudent.IsEnabled = false;
                                EffectFasciaHitActivated = true;

                                StartAnimation();

                                ZeroCaseIndications();

                                CalculateAndShowResults();
                            }
                            else
                            {
                                bool found = false;
                                for (int i = 0; i < CurrentPhase.TargetPointsNerve.Count; i++)
                                {
                                    if ((CurrentPhase.TargetPointsNerve[i].T == 0) && (CurrentPhase.TargetPointsNerve[i].Injections.Count==0))
                                    {
                                        Vector2 aa = new Vector2(NedleAreaEnd.X - (float)(CurrentPhase.TargetPointsNerve[i].X * wScaled), NedleAreaEnd.Y - (float)(CurrentPhase.TargetPointsNerve[i].Y * hScaled));
                                        if (aa.Length < CurrentPhase.TargetPointsNerve[i].R * wScaled)
                                        {
                                            found = true;
                                            CurrentPhase.TargetPointsNerve[i].Injections.Add(aa.Length * RatioVisualizationMMperPixel);
                                        }
                                    }
                                }
                                if (!found)
                                {
                                    TargetMissedNerve_Injections++;
                                }

                                deformationsForNerveContinuousInjections.Add(new Deformation(Enum_DeformationMode.ONESHOT, sizeEffect / 2.0, maximumDisplacement / 2.0, new Point(NedleAreaEnd.X, NedleAreaEnd.Y), AppControl.Instance, offsetWidEco, offsetHeiEco, deformationTotalTimeSeconds, intervalMsTimer, deformationsForNerveContinuousInjections));
                                EffectNerveHitActivated = true;
                                wft.bStopTheCase.IsEnabled = true;
                                sf.bStopTheCase.IsEnabled = true;
                            }
                        }
                    }
                }
            }
        }

        public void UpdatePointsFascia(bool incrementEffect, bool justTraslation)
        {
            WindowTeacher.Dispatcher.BeginInvoke((Action)(() =>
            {
                try
                {
                    if (deformableArea != null)
                    {
                        if (incrementEffect)
                        {
                            deformableArea.UpdatePositions();
                            deformableArea.UpdateCurves();
                            deformableArea.IncrementEffect(MaxEffect);

                            if (index_points_to_move.Count == 0)
                            {
                                for (int i = 0; i < pointsDX.Count(); i++)
                                {
                                    SharpDX.Vector3 vertex = pointsDX[i];

                                    bool res = deformableArea.GetMovedPoint(vertex, out SharpDX.Vector3 newpoint, DisplacementDeformableArea);

                                    if (res)
                                    {
                                        index_points_to_move.Add(i);
                                    }

                                    Model.Positions[i] = newpoint;
                                }
                            }
                            else
                            {
                                foreach (int index in index_points_to_move)
                                {
                                    SharpDX.Vector3 vertex = pointsDX[index];

                                    bool res = deformableArea.GetMovedPoint(vertex, out SharpDX.Vector3 newpoint, DisplacementDeformableArea);

                                    Model.Positions[index] = newpoint;
                                }
                            }
                            Model.UpdateVertices();
                        }
                        SharpDX.Vector3[] pointsNew = deformableArea.GiveMeBorderPoints(DisplacementDeformableArea);
                        for (int i = 0; i < pointsNew.Length; i++)
                        {
                            ModelDeformableArea.Positions[i] = pointsNew[i];
                        }
                        ModelDeformableArea.UpdateVertices();
                    }
                }
                catch (Exception ex)
                {
                    if (Properties.Settings.Default.ErrorLog)
                    {
                        MessageBox.Show(ex.Message + ex.StackTrace);
                    }
                }
            }));
        }

        public void WindowTeacherLoaded(object sender, RoutedEventArgs e)
        {
        }

        public void ZeroCaseIndications()
        {
            if ((WindowTeacher.PageContainer.Content is FunctionalitiesFrame))
            {
                FunctionalitiesFrame wft = (FunctionalitiesFrame)WindowTeacher.PageContainer.Content;
                if (CurrentCase != null)
                {
                    if (CurrentCase.Phases != null)
                    {
                        foreach (Phase f in CurrentCase.Phases)
                        {
                            f.Selected = false;
                        }
                    }
                }
                foreach (CaseStructure f in Cases)
                {
                    f.Selected = false;
                }
                wft.pbLoadCaseSingleStep.Value = 0;
                SetText(wft.tbInfoLoadCase, StringLoadCase);
                //SetText(wft.tCurrentCase, StringCurrentCase);
            }
        }

        internal void ClearTempResults()
        {
            if (!Directory.Exists("C:\\BlockSim\\ResultsTemp"))
            {
                Directory.CreateDirectory("C:\\BlockSim\\ResultsTemp");
            }
            DirectoryInfo di = new DirectoryInfo("C:\\BlockSim\\ResultsTemp");

            FileInfo[] files = di.GetFiles("*.pdf");
            foreach (FileInfo ff in files)
            {
                ff.Delete();
            }
        }

        internal bool CloseCurrentCase()
        {
            if (EffectFasciaHitActivated || EffectNerveHitActivated)
            {
                //VisibilityResults = Visibility.Hidden;
                StopCase(true);
                return true;
            }
            else
            {
                if (MessageBox.Show(BlockSim.Globalization.Language.str_sure_stop_case, true, 1000))
                {
                    StopCase(false);
                    return true;
                }
                else
                {
                    return false;
                }
            }
        }

        internal void ConnectBlockSim()
        {
            HwndSource hwnd = HwndSource.FromHwnd(new WindowInteropHelper(WindowTeacher).Handle);
            BlockSimController.Instance.ScannedSimulatorsEvent += new BlockSimController.ScannedSimulatorsDelegate(ScannedSimulatorListener);
            BlockSimController.Instance.AMessageArrivedEvent += new BlockSimController.AMessageArrivedDelegate(AMessageArriveListener);

            BlockSimController.Instance.Go();
            BlockSimController.Instance.StartHookDevices(hwnd);
        }

        internal void ConnectPDI()
        {
            pDIClass.OnConnectionStatusChanged += PDIClass_OnConnectionStatusChanged;
            pDIClass.OnNewFrameAvailable += PDIClass_OnNewFrameAvailable;
            pDIClass.Connect(new WindowInteropHelper(WindowTeacher).Handle);
            timerCheckPolhemus = new DispatcherTimer();
            timerCheckPolhemus.Interval = new TimeSpan(0, 0, 1);
            timerCheckPolhemus.IsEnabled = true;
            timerCheckPolhemus.Tick += new EventHandler(TimerCheckPolhemusTick_Listener);
            timerCheckPolhemus.Start();
        }

        internal void DisconnectBlockSim()
        {
            BlockSimController.Instance.ScannedSimulatorsEvent -= new BlockSimController.ScannedSimulatorsDelegate(ScannedSimulatorListener);
            BlockSimController.Instance.AMessageArrivedEvent -= new BlockSimController.AMessageArrivedDelegate(AMessageArriveListener);
            BlockSimController.Instance.Dispose();
        }

        internal void DisconnectPDI()
        {
            pDIClass.OnConnectionStatusChanged -= PDIClass_OnConnectionStatusChanged;
            pDIClass.OnNewFrameAvailable -= PDIClass_OnNewFrameAvailable;
            pDIClass.Disconnect();
        }

        internal List<string> GetListOfBlockSimPosition(string module)
        {
            List<string> toRet = new List<string>();
            foreach (CaseStructure cs in Cases)
            {
                if (module == Enum.GetName(typeof(Enum_Modules), cs.Module))
                {
                    toRet.Add(cs.PositionOk);
                }
            }
            return toRet;
        }

        internal List<string> GetListOfImageBlockSim(string module)
        {
            List<string> toRet = new List<string>();
            foreach (CaseStructure cs in Cases)
            {
                if (module == Enum.GetName(typeof(Enum_Modules), cs.Module))
                {
                    toRet.Add(cs.Folder + "\\BlockSimPosition.jpg");
                }
            }
            return toRet;
        }

        internal List<string> GetListOfPad(string module)
        {
            List<string> toRet = new List<string>();
            foreach (CaseStructure cs in Cases)
            {
                if (module == Enum.GetName(typeof(Enum_Modules), cs.Module))
                {
                    toRet.Add(cs.InsertType);
                }
            }
            return toRet;
        }

        internal List<string> GetListOfStringCases(string module)
        {
            List<string> toRet = new List<string>();
            foreach (CaseStructure cs in Cases)
            {
                if (module == Enum.GetName(typeof(Enum_Modules), cs.Module))
                {
                    toRet.Add(cs.Name);
                }
            }
           
            return toRet;
        }

        internal List<string> GetListOfStringCasesDescription(string module)
        {
            List<string> toRet = new List<string>();
            foreach (CaseStructure cs in Cases)
            {
                if (module == Enum.GetName(typeof(Enum_Modules), cs.Module))
                {
                    toRet.Add(cs.Description);
                }
            }
            return toRet;
        }

        internal string GiveMeTheEvent(int idEvent)
        {
            Events entries = DBConnector.Instance.FindRowById<Events>(new BsonValue(idEvent));

            if (entries != null)
            {
                return entries.ShortName;
            }
            return "";
        }

        internal string GiveMeTheStudent(int idStudent)
        {
            Users entries = DBConnector.Instance.FindRowById<Users>(new BsonValue(idStudent));

            if (entries != null)
            {
                return entries.Name + " " + entries.Surname;
            }
            return "";
        }

        internal void SelectEvent(Events selectedItem)
        {
            CurrentEvent = selectedItem;
            if (CurrentEvent != null)
            {
                WindowTeacher.lEvent.Text = selectedItem.ShortName;
            }
            else
            {
                WindowTeacher.lEvent.Text = "";
            }
        }

        internal void SelectStudent(Users p)
        {
            CurrentStudent = p;
            if (CurrentStudent != null)
            {
                WindowTeacher.lStudent.Text = p.Title + " " + p.Name + " " + p.Surname;
            }
            else
            {
                WindowTeacher.lStudent.Text = "";
            }
        }

        internal void SelectTeacher(Users p)
        {
            CurrentTeacher = p;
            if (CurrentTeacher != null)
            {
                WindowTeacher.lTeacher.Text = p.Title + " " + p.Name + " " + p.Surname;
                WindowTeacher.lTeacher.Foreground = p.Role == 2 ? Brushes.RoyalBlue : Brushes.White;
            }
            else
            {
                WindowTeacher.lTeacher.Text = "";
            }
        }

        private float lengthLineIndication = 300;
        private float zPadSurface;
        private bool visibleNeedleDefinedAtEntrance = false;
        private DateTime lastCollisioneCheck;

        internal bool SetLine(
            VectorMath.Vector3 v1,
            VectorMath.Vector3 v2,
            VectorMath.Vector3 v1Pos,
            VectorMath.Vector3 v2Pos,
            VectorMath.Vector3 v1Neg,
            VectorMath.Vector3 v2Neg,
            float dist1Pos, float dist2Pos, float dist1Neg, float dist2Neg,
            bool present, bool posPresent, bool negPresent,
            double heiEcoTeacher, double widEcoTeacher, double heiEcoStudent, double widEcoStudent,
            bool needleVisible)
        {

            float deltaYTeacher = 0;
            float deltaXTeacher = 0;
            if (AppControl.Instance.CurrentCase.TypeBlock==Enum_Configuration.N_INFRACLAVICULAR)
            {
                deltaYTeacher = -120f;
                deltaXTeacher = 180f;
            }
            
            float deltaYStudent= (float)(deltaYTeacher * heiEcoStudent/ heiEcoTeacher);
            float deltaXStudent = (float)(deltaXTeacher * widEcoStudent / widEcoTeacher);

            if (present)
            {
                //Calculate eco indication, neddle line visible, and interaction with deformableArea

                //These offsets are just used for centering
                float offsetWidEco = (float)widEcoStudent / 2f;
                float offsetHeiEco = (float)heiEcoStudent / 2f;

                int widthEcoTeacher = (int)widEcoTeacher;
                int lengthEcoTeacher = (int)heiEcoTeacher;
                int widthEcoStudent = (int)widEcoStudent;
                int lengthEcoStudent = (int)heiEcoStudent;

                VectorMath.Vector3 diff = (v2 - v1); diff.Normalize();
                if (diff.Y <= 0) diff.Negate();

                VectorMath.Vector3 v1Ind = v1 - (lengthLineIndication) * diff;
                VectorMath.Vector3 v2Ind = v1 + (lengthLineIndication) * diff;

                int mmWidth = (int)(WidthImage_mm);
                int mmLength = (int)(DepthImage_mm);
                RatioVisualizationMMperPixel = (float)mmLength / (float)lengthEcoStudent;

                //TEACHER
                float x1 = -v1.Y * widthEcoTeacher / mmWidth + widthEcoTeacher / 2;
                float x2 = -v2.Y * widthEcoTeacher / mmWidth + widthEcoTeacher / 2;
                float y1 = -v1.X * lengthEcoTeacher / mmLength;
                float y2 = -v2.X * lengthEcoTeacher / mmLength;

                float x1Ind = -v1Ind.Y * widthEcoTeacher / mmWidth + widthEcoTeacher / 2;
                float x2Ind = -v2Ind.Y * widthEcoTeacher / mmWidth + widthEcoTeacher / 2;
                float y1Ind = -v1Ind.X * lengthEcoTeacher / mmLength;
                float y2Ind = -v2Ind.X * lengthEcoTeacher / mmLength;

                //STUDENT
                float x1Eco = -v1.Y * widthEcoStudent / mmWidth + widthEcoStudent / 2;
                float x2Eco = -v2.Y * widthEcoStudent / mmWidth + widthEcoStudent / 2;
                float y1Eco = -v1.X * lengthEcoStudent / mmLength;
                float y2Eco = -v2.X * lengthEcoStudent / mmLength;

                float x1EcoInd = -v1Ind.Y * widthEcoStudent / mmWidth + widthEcoStudent / 2;
                float x2EcoInd = -v2Ind.Y * widthEcoStudent / mmWidth + widthEcoStudent / 2;
                float y1EcoInd = -v1Ind.X * lengthEcoStudent / mmLength;
                float y2EcoInd = -v2Ind.X * lengthEcoStudent / mmLength;

                LineX1EcoTeacher = x1 + deltaXTeacher;
                LineX2EcoTeacher = x2 + deltaXTeacher;
                LineY1EcoTeacher = y1 + deltaYTeacher;
                LineY2EcoTeacher = y2 + deltaYTeacher;

                LineX1IndicationEcoTeacher = x1Ind + deltaXTeacher;
                LineX2IndicationEcoTeacher = x2Ind + deltaXTeacher;
                LineY1IndicationEcoTeacher = y1Ind + deltaYTeacher;
                LineY2IndicationEcoTeacher = y2Ind + deltaYTeacher;

                LineX1EcoStudent = x1Eco + deltaXStudent;
                LineX2EcoStudent = x2Eco + deltaXStudent;
                LineY1EcoStudent = y1Eco + deltaYStudent;
                LineY2EcoStudent = y2Eco + deltaYStudent;

                LineX1IndicationEcoStudent = x1EcoInd + deltaXStudent;
                LineX2IndicationEcoStudent = x2EcoInd + deltaXStudent;
                LineY1IndicationEcoStudent = y1EcoInd + deltaYStudent;
                LineY2IndicationEcoStudent = y2EcoInd + deltaYStudent;

                float x1Pos = 0;
                float x2Pos = 0;
                float y1Pos = 0;
                float y2Pos = 0;
                float x1EcoPos = 0;
                float x2EcoPos = 0;
                float y1EcoPos = 0;
                float y2EcoPos = 0;

                float x1Neg = 0;
                float x2Neg = 0;
                float y1Neg = 0;
                float y2Neg = 0;
                float x1EcoNeg = 0;
                float x2EcoNeg = 0;
                float y1EcoNeg = 0;
                float y2EcoNeg = 0;

                if (negPresent)
                {
                    x1Neg = -v1Neg.Y * widthEcoTeacher / mmWidth + widthEcoTeacher / 2;
                    x2Neg = -v2Neg.Y * widthEcoTeacher / mmWidth + widthEcoTeacher / 2;
                    y1Neg = -v1Neg.X * lengthEcoTeacher / mmLength;
                    y2Neg = -v2Neg.X * lengthEcoTeacher / mmLength;
                    x1EcoNeg = -v1Neg.Y * widthEcoStudent / mmWidth + widthEcoStudent / 2;
                    x2EcoNeg = -v2Neg.Y * widthEcoStudent / mmWidth + widthEcoStudent / 2;
                    y1EcoNeg = -v1Neg.X * lengthEcoStudent / mmLength;
                    y2EcoNeg = -v2Neg.X * lengthEcoStudent / mmLength;

                    LineX1EcoTeacherNegative = x1Neg + deltaXTeacher;
                    LineX2EcoTeacherNegative = x2Neg + deltaXTeacher;
                    LineY1EcoTeacherNegative = y1Neg + deltaYTeacher;
                    LineY2EcoTeacherNegative = y2Neg + deltaYTeacher;

                    LineX1EcoStudentNeg = x1EcoNeg + deltaXStudent;
                    LineX2EcoStudentNeg = x2EcoNeg + deltaXStudent;
                    LineY1EcoStudentNeg = y1EcoNeg + deltaYStudent;
                    LineY2EcoStudentNeg = y2EcoNeg + deltaYStudent;

                    VisibleLineNegative = needleVisible ? Visibility.Visible : Visibility.Hidden;
                }
                else
                {
                    VisibleLineNegative = Visibility.Hidden;
                }

                if (posPresent)
                {
                    x1Pos = -v1Pos.Y * widthEcoTeacher / mmWidth + widthEcoTeacher / 2;
                    x2Pos = -v2Pos.Y * widthEcoTeacher / mmWidth + widthEcoTeacher / 2;
                    y1Pos = -v1Pos.X * lengthEcoTeacher / mmLength;
                    y2Pos = -v2Pos.X * lengthEcoTeacher / mmLength;
                    x1EcoPos = -v1Pos.Y * widthEcoStudent / mmWidth + widthEcoStudent / 2;
                    x2EcoPos = -v2Pos.Y * widthEcoStudent / mmWidth + widthEcoStudent / 2;
                    y1EcoPos = -v1Pos.X * lengthEcoStudent / mmLength;
                    y2EcoPos = -v2Pos.X * lengthEcoStudent / mmLength;

                    LineX1EcoTeacherPositive = x1Pos + deltaXTeacher;
                    LineX2EcoTeacherPositive = x2Pos + deltaXTeacher;
                    LineY1EcoTeacherPositive = y1Pos + deltaYTeacher;
                    LineY2EcoTeacherPositive = y2Pos + deltaYTeacher;

                    LineX1EcoStudentPos = x1EcoPos + deltaXStudent;
                    LineX2EcoStudentPos = x2EcoPos + deltaXStudent;
                    LineY1EcoStudentPos = y1EcoPos + deltaYStudent;
                    LineY2EcoStudentPos = y2EcoPos + deltaYStudent;

                    VisibleLinePositive = needleVisible ? Visibility.Visible : Visibility.Hidden;
                }
                else
                {
                    VisibleLinePositive = Visibility.Hidden;
                }

                SharpDX.Vector3 nedleAreaStart = new SharpDX.Vector3(-LineX1EcoStudent + offsetWidEco, -LineY1EcoStudent + offsetHeiEco, -3);
                NedleAreaEnd = new SharpDX.Vector3(-LineX2EcoStudent + offsetWidEco, -LineY2EcoStudent + offsetHeiEco, -3);
                //Trace.WriteLine(NedleAreaEnd.X.ToString("00.00") + "    " + NedleAreaEnd.Y.ToString("00.00"));
                SharpDX.Vector3 nedleAreaIndicationStart = new SharpDX.Vector3(-LineX1IndicationEcoStudent + offsetWidEco, -LineY1IndicationEcoStudent + offsetHeiEco, -3);
                SharpDX.Vector3 nedleAreaIndicationEnd = new SharpDX.Vector3(-LineX2IndicationEcoStudent + offsetWidEco, -LineY2IndicationEcoStudent + offsetHeiEco, -3);

                //Calculate the distance from fascia and update the controls
                float t = 0;
                bool upOrLow = false;
                SharpDX.Vector3 vectorToCentral = new SharpDX.Vector3();

                if (TargetStructureAvailableInFrame)
                {
                    if (!CurrentPhase.NerveMultipleInjections)
                    {
                        if (!CurrentPhase.MuscularBlock)
                        {
                            DistanceNeedleToFascia = CalculateDistanceNeedleToFascia(NedleAreaEnd, out t, out upOrLow, out vectorToCentral);
                            IntervalNeedleToFascia = t;
                            UpperOrLowerLine = upOrLow;
                            Vector2CentralPoint = new SharpDX.Vector3(vectorToCentral.X, vectorToCentral.Y, 0);


                            //PIRINI

                        }
                        else
                        {
                            Vector2CentralPoint = NedleAreaEnd - dispCenterCircularBlockMuscular;
                            DistanceNeedleToFascia = Vector2CentralPoint.Length();
                            IntervalNeedleToFascia = 0.5f;
                            UpperOrLowerLine = true;
                        }
                    }
                    else
                    {

                            foreach (TargetPointNerve tpn in CurrentPhase.TargetPointsNerve)
                            {
                                Vector2 aa = new Vector2(NedleAreaEnd.X - (float)(tpn.X * wScaled), NedleAreaEnd.Y - (float)(tpn.Y * hScaled));
                                if (aa.Length < tpn.R * wScaled)
                                {
                                    if (!tpn.NeedleInside)
                                    {
                                        tpn.NeedleInside = true;
                                        tpn.AreaEnteredFromNeedle++;
                                    }

                                }
                                else
                                {
                                    if (tpn.NeedleInside)
                                    {
                                        tpn.NeedleInside = false;
                                    }
                                }
                            }
                        
                    }

                }
                else
                {
                    DistanceNeedleToFascia = 1000;
                    IntervalNeedleToFascia = 1000;
                    Vector2CentralPoint = new SharpDX.Vector3(NedleAreaEnd.X, NedleAreaEnd.Y, 0);
                }

                //Show NeedleIndication
                if (NeedleAreaIndication != null)
                {
                    NeedleAreaIndication.Positions[0] = nedleAreaIndicationStart;
                    NeedleAreaIndication.Positions[1] = nedleAreaIndicationEnd;
                    NeedleAreaIndication.UpdateVertices();
                }
                VisibleIndicationLine = Visibility.Visible;
                NeedleIndicationColor = System.Windows.Media.Color.FromArgb((ShowIndicationNeedle ? (byte)255 : (byte)0), 150, 150, 150);

                VisibleIndicationLine = Visibility.Visible;

                float sizeIndication = 5;

                //Show NeedleArea
                if (NeedleArea != null)
                {
                    NeedleArea.Positions[0] = nedleAreaStart;
                    NeedleArea.Positions[1] = NedleAreaEnd;
                    NeedleArea.UpdateVertices();

                    NeedleAreaLine1.Positions[0] = NedleAreaEnd + new SharpDX.Vector3(-sizeIndication, -sizeIndication, 0);
                    NeedleAreaLine1.Positions[1] = NedleAreaEnd + new SharpDX.Vector3(sizeIndication, sizeIndication, 0);
                    NeedleAreaLine1.UpdateVertices();

                    NeedleAreaLine2.Positions[0] = NedleAreaEnd + new SharpDX.Vector3(-sizeIndication, sizeIndication, 0);
                    NeedleAreaLine2.Positions[1] = NedleAreaEnd + new SharpDX.Vector3(sizeIndication, -sizeIndication, 0);
                    NeedleAreaLine2.UpdateVertices();
                }

                VisibleLine = Visibility.Visible;
                int valueAlpha = (int)((10.0 - Math.Min(Math.Abs(angleDeg), LimitAngleDeg)) * 25.0);
                NeedleColor = System.Windows.Media.Color.FromArgb((byte)valueAlpha, 255, 255, 255);

                NeedleTipIndicationColor = TipInVisiblePlane ? NeedleTipIndicationColorInPlane : NeedleTipIndicationColorOutPlane;
                int numPointsNeedleLength = 50;
                int numPointsNeedleWidth = 2;
                float pixelsNeedleWidth = 9;
                //needle negative
                if (negPresent)
                {
                    SharpDX.Vector3 nedleAreaStartNegative = new SharpDX.Vector3(-LineX1EcoStudentNeg + offsetWidEco, -LineY1EcoStudentNeg + offsetHeiEco, -3);
                    SharpDX.Vector3 nedleAreaEndNegative = new SharpDX.Vector3(-LineX2EcoStudentNeg + offsetWidEco, -LineY2EcoStudentNeg + offsetHeiEco, -3);
                    var builderNeedleNegative = new MeshBuilder(true);

                    SharpDX.Vector3 versorNegative = (nedleAreaEndNegative - nedleAreaStartNegative);
                    float needleLengthNegative = versorNegative.Length();
                    versorNegative.Normalize();

                    SharpDX.Vector3[] pointsNeedle = new SharpDX.Vector3[numPointsNeedleLength * numPointsNeedleWidth];
                    for (int i = 0; i < numPointsNeedleLength; ++i)
                    {
                        for (int j = 0; j < numPointsNeedleWidth; ++j)
                        {
                            SharpDX.Vector3 vec = new SharpDX.Vector3(
                                nedleAreaStartNegative.X + (float)i / (float)(numPointsNeedleLength - 1) * versorNegative.X * needleLengthNegative,
                                nedleAreaStartNegative.Y + (float)i / (float)(numPointsNeedleLength - 1) * versorNegative.Y * needleLengthNegative + j * pixelsNeedleWidth / numPointsNeedleWidth,
                                -3);
                            pointsNeedle[j * numPointsNeedleLength + i] = vec;
                        }
                    }
                    builderNeedleNegative.AddRectangularMesh(pointsNeedle, numPointsNeedleLength);
                    ModelNeedleNegative = builderNeedleNegative.ToMesh();

                    //imposto stripe tutta Blu

                    float valStart = Math.Max(1f - (dist1Neg / LimitZ), minValueAlpha);
                    float valEnd = Math.Max(1f - (dist2Neg / LimitZ), minValueAlpha);

                    List<SharpDX.Color4> colors = new List<SharpDX.Color4>();
                    for (int i = 0; i < numPointsNeedleLength; i++)
                    {
                        colors.Add(new SharpDX.Color4(1, 1, 1, valStart + (valEnd - valStart) / (float)(numPointsNeedleLength - 1) * (float)i));
                    }

                    ModelMaterialNeedleNegative.ColorStripeX = colors;
                    ModelMaterialNeedleNegative.ColorStripeYEnabled = false;
                }

                //needle Positive
                if (posPresent)
                {
                    SharpDX.Vector3 nedleAreaStartPositive = new SharpDX.Vector3(-LineX1EcoStudentPos + offsetWidEco, -LineY1EcoStudentPos + offsetHeiEco, -3);
                    SharpDX.Vector3 nedleAreaEndPositive = new SharpDX.Vector3(-LineX2EcoStudentPos + offsetWidEco, -LineY2EcoStudentPos + offsetHeiEco, -3);
                    var builderNeedlePositive = new MeshBuilder(true);

                    SharpDX.Vector3 versorPositive = (nedleAreaEndPositive - nedleAreaStartPositive);
                    float needleLengthPositive = versorPositive.Length();
                    versorPositive.Normalize();

                    SharpDX.Vector3[] pointsNeedle = new SharpDX.Vector3[numPointsNeedleLength * numPointsNeedleWidth];
                    for (int i = 0; i < numPointsNeedleLength; ++i)
                    {
                        for (int j = 0; j < numPointsNeedleWidth; ++j)
                        {
                            SharpDX.Vector3 vec = new SharpDX.Vector3(
                                nedleAreaStartPositive.X + (float)i / (float)(numPointsNeedleLength - 1) * versorPositive.X * needleLengthPositive,
                                nedleAreaStartPositive.Y + (float)i / (float)(numPointsNeedleLength - 1) * versorPositive.Y * needleLengthPositive + j * pixelsNeedleWidth / numPointsNeedleWidth,
                                -3);
                            pointsNeedle[j * numPointsNeedleLength + i] = vec;
                        }
                    }
                    builderNeedlePositive.AddRectangularMesh(pointsNeedle, numPointsNeedleLength);
                    ModelNeedlePositive = builderNeedlePositive.ToMesh();

                    //imposto stripe tutta bianca
                    List<SharpDX.Color4> colors = new List<SharpDX.Color4>();
                    float valStart = Math.Max(1f - (dist1Pos / LimitZ), minValueAlpha);
                    float valEnd = Math.Max(1f - (dist2Pos / LimitZ), minValueAlpha);
                    for (int i = 0; i < numPointsNeedleLength; i++)
                    {
                        colors.Add(new SharpDX.Color4(1, 1, 1, valStart + (valEnd - valStart) / (float)(numPointsNeedleLength - 1) * (float)i));
                    }

                    ModelMaterialNeedlePositive.ColorStripeX = colors;
                    ModelMaterialNeedlePositive.ColorStripeYEnabled = false;
                }

                if (x2 >= 0 && x2 <= widthEcoTeacher && y2 >= 0 && y2 <= lengthEcoTeacher)
                {
                    return true;
                }
                else
                {
                    return false;
                }
            }
            else
            {
                DistanceNeedleToFascia = 1000;
                VisibleLine = Visibility.Hidden;
                VisibleIndicationLine = Visibility.Hidden;

                NeedleColor = System.Windows.Media.Color.FromArgb(0, 255, 255, 255);
                NeedleIndicationColor = System.Windows.Media.Color.FromArgb(0, 150, 150, 150);
                NeedleTipIndicationColor = System.Windows.Media.Color.FromArgb(0, 150, 150, 150);
                VisibleLineNegative = Visibility.Hidden;
                VisibleLinePositive = Visibility.Hidden;
                return false;
            }
        }

        internal void SetModelMaterialDeformableArea(bool colorOrBackground, bool backgroundVisible, bool backgroundLiquid)
        {
            if (ModelMaterialDeformableArea == null)
            {
                ModelMaterialDeformableArea = new HelixToolkit.Wpf.SharpDX.DiffuseMaterial();
            }
            if (colorOrBackground)
            {
                ModelMaterialDeformableArea.DiffuseColor = new SharpDX.Color4(0, 255, 255, ((ShowTargetPosition && TargetStructureAvailableInFrame && !CurrentPhase.MuscularBlock) ? 0.5f : 0));
            }
            else
            {
                if (backgroundVisible)
                {
                    ModelMaterialDeformableArea.DiffuseMap = LoadTexture(backgroundLiquid ? "filler.png" : "filler2.png");
                }
                else
                {
                    ModelMaterialDeformableArea.DiffuseColor = new SharpDX.Color4(255, 0, 0, 0);
                }
            }
        }

        internal void ShowNeedleIndication(object sender)
        {
            ShowIndicationNeedle = (bool)(sender as ToggleButton).IsChecked;
            Properties.Settings.Default.ShowNeedleTrajectory = ShowIndicationNeedle;
            Properties.Settings.Default.Save();
            VisibleNeedleTipIndication = ((bool)(sender as ToggleButton).IsChecked ? Visibility.Visible : Visibility.Hidden);
            NeedleIndicationColor = System.Windows.Media.Color.FromArgb((ShowIndicationNeedle ? (byte)255 : (byte)0), 150, 150, 150);
            if ((bool)(sender as ToggleButton).IsChecked)
            {
                // Code for Checked state
            }
            else
            {
                // Code for Un-Checked state
            }
        }

        internal void TbShowFasciaPosition(object sender)
        {
            ShowTargetPosition = (bool)(sender as ToggleButton).IsChecked;
            Properties.Settings.Default.ShowTargetPosition = ShowTargetPosition;
            Properties.Settings.Default.Save();
            if ((!EffectFasciaHitActivated) && (ModelMaterialDeformableArea != null))
            {
                ModelMaterialDeformableArea.DiffuseColor = new SharpDX.Color4(0, 255, 255, ((ShowTargetPosition && TargetStructureAvailableInFrame && !CurrentPhase.MuscularBlock) ? 0.5f : 0));
            }

            if ((bool)(sender as ToggleButton).IsChecked)
            {
                // Code for Checked state
            }
            else
            {
                // Code for Un-Checked state
            }

            WindowStudent.spLegenda.Visibility = (bool)(sender as ToggleButton).IsChecked ? Visibility.Visible : Visibility.Hidden;
        }

        internal void UpdateDeformableArea(float t)
        {
            if (deformableArea != null)
            {
                var builderDeformableArea = new MeshBuilder(true);
                deformableArea.tAppliedDeformation = t;
                deformableArea.Create();

                builderDeformableArea.AddRectangularMesh(deformableArea.GiveMeBorderPoints(DisplacementDeformableArea), DeformableArea.NUMPOINTS_SIDE);
                ModelDeformableArea = builderDeformableArea.ToMesh();
                modelDeformableArea.CalculateNormals();
                UpdatePointsFascia(false, false);
            }
        }

        internal void WindowStudentLoaded(object sender, RoutedEventArgs e)
        {
            VisibilityBorderArrowDown = Visibility.Hidden;
            VisibilityBorderArrowLeft = Visibility.Hidden;
            VisibilityBorderArrowRight = Visibility.Hidden;
            VisibilityBorderArrowRotation = Visibility.Hidden;
            VisibilityBorderArrowRotation2 = Visibility.Hidden;
            VisibilityBorderArrowUp = Visibility.Hidden;
        }

        protected virtual void Dispose(bool disposing)
        {
            if (!disposedValue)
            {
                if (disposing)
                {
                    // TODO: dispose managed state (managed objects).
                }

                // TODO: free unmanaged resources (unmanaged objects) and override a finalizer below.
                // TODO: set large fields to null.
                if (EffectsManager != null)
                {
                    var effectManager = EffectsManager as IDisposable;
                    Disposer.RemoveAndDispose(ref effectManager);
                }
                disposedValue = true;
                GC.SuppressFinalize(this);
            }
        }

        protected virtual void OnCameraModelChanged()
        {
            var eh = CameraModelChanged;
            if (eh != null)
            {
                eh(this, new EventArgs());
            }
        }

        protected void OnPropertyChanged([CallerMemberName] string info = "")
        {
            if (this.PropertyChanged != null)
            {
                this.PropertyChanged(this, new PropertyChangedEventArgs(info));
            }
        }

        protected bool SetValue<T>(ref T backingField, T value, [CallerMemberName] string propertyName = "")
        {
            if (object.Equals(backingField, value))
            {
                return false;
            }

            backingField = value;
            this.OnPropertyChanged(propertyName);
            return true;
        }

        private void AMessageArriveListener(string serial, byte type, byte[] message)
        {
            try
            {
                if (!WindowTeacher.Dispatcher.CheckAccess())
                {
                    WindowTeacher.Dispatcher.Invoke(new Action(() =>
                    {
                        if (type == (byte)Enum_SimulatorMessageType.FLUXGYRO)
                        {
                            OrientationBlockSim = (BlockSimController.Instance.Simulator).Orientation;
                            LastOrientationBlockSimArrived = DateTime.Now;
                        }

                        if ((WindowTeacher.PageContainer.Content is WorkingFrameTeacher))
                        {
                            WorkingFrameTeacher wft = (WorkingFrameTeacher)WindowTeacher.PageContainer.Content;
                            switch (type)
                            {
                                case (byte)Enum_SimulatorMessageType.FIRMWARE:
                                    wft.tbFirmware.Text = BlockSim.Globalization.Language.str_firmware + " " + (BlockSimController.Instance.Simulator).FirmwareVersion;
                                    break;

                                case (byte)Enum_SimulatorMessageType.SERIAL:
                                    wft.tbSerial.Text = BlockSim.Globalization.Language.str_serial + " " + (BlockSimController.Instance.Simulator).SerialNumber;
                                    break;

                                case (byte)Enum_SimulatorMessageType.FLUX:

                                    wft.tbFlux.Text = BlockSim.Globalization.Language.str_flux + " " + (BlockSimController.Instance.Simulator).Flux.ToString("00.00");
                                    wft.tbVolume.Text = BlockSim.Globalization.Language.str_volume + " " + (BlockSimController.Instance.Simulator).CurrentVolume.ToString("00.00");

                                    break;

                                case (byte)Enum_SimulatorMessageType.FLUXGYRO:
                                    wft.tbFlux.Text = BlockSim.Globalization.Language.str_flux + " " + (BlockSimController.Instance.Simulator).Flux.ToString("00.00");
                                    wft.tbVolume.Text = BlockSim.Globalization.Language.str_volume + " " + (BlockSimController.Instance.Simulator).CurrentVolume.ToString("00.00");
                                    wft.tbAcc.Text = BlockSim.Globalization.Language.str_x + " " + (BlockSimController.Instance.Simulator).AccX.ToString() + " " + BlockSim.Globalization.Language.str_y + " " + (BlockSimController.Instance.Simulator).AccY.ToString() + " " + BlockSim.Globalization.Language.str_z + " " + (BlockSimController.Instance.Simulator).AccZ.ToString();
                                    wft.tbOrientation.Text = BlockSim.Globalization.Language.str_orientation + " " + (BlockSimController.Instance.Simulator).Orientation;

                                    if ((BlockSimController.Instance.Simulator).Flux > 0.5f)
                                    {
                                        if (!CurrentPhase.NerveMultipleInjections)
                                        {
                                            if (!EffectFasciaHitActivated)
                                            {
                                                InjectAnesthetic();
                                            }
                                        }
                                        else
                                        {
                                            if ((DateTime.Now - LastTimeInjection).TotalMilliseconds > 1000)
                                            {
                                                LastTimeInjection = DateTime.Now;
                                                InjectAnesthetic();
                                            }
                                        }
                                    }
                                    break;

                                default:
                                    break;
                            }
                        }
                    }

                        ));
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine(ex.Message + ex.StackTrace);
            }
        }

        private void AnimationTick(object sender, EventArgs e)
        {
            UpdatePointsFascia(EffectFasciaHitActivated, !EffectFasciaHitActivated);
        }

        public void UpdatePointsNerve_FullImage(List<SmartGridPoint2> smartGridPointsNew)
        {
            try
            {
                foreach (SmartGridPoint2 sgp in smartGridPointsNew)
                {
                    Model.Positions[sgp.Index] = sgp.CurrentPosition;
                }
            }
            catch (Exception ex)
            {
            }
        }

        private void CalculateAndShowResults()
        {
            decimal offset = 0;
            DurationNeedlePhase = DateTime.Now - StartNeedlePhaseTime;
            MinutesNeedlePhase = DurationNeedlePhase.Minutes;
            TextTime = DurationNeedlePhase.Minutes.ToString() + ":" + DurationNeedlePhase.Seconds.ToString();
            TextNeedlePuntures = insertionNeedle.ToString();

            string comment = BlockSim.Globalization.Language.str_ok;
            if (insertionNeedle == 0)
            {
                comment = BlockSim.Globalization.Language.str_anomaly;
            }
            if (CurrentPhase.NerveMultipleInjections)
            {
                int totalCorrectTargets = CurrentPhase.TargetPointsNerve.Where(x => x.T == 0).Count();
                if (insertionNeedle > totalCorrectTargets)
                {
                    comment = BlockSim.Globalization.Language.str_too_many_ins + " " + (10 * (insertionNeedle - totalCorrectTargets)).ToString();
                }
            }
            else
            {
                if (insertionNeedle > 1)
                {
                    comment = BlockSim.Globalization.Language.str_too_many_ins + " " + (10 * (insertionNeedle-  1)).ToString();
                }
            }
        

            string comment2 = BlockSim.Globalization.Language.str_lt_3min;
            if (DurationNeedlePhase.Minutes > 2)
            {
                comment2 = BlockSim.Globalization.Language.str_too_lengthy + " " + (5 * (DurationNeedlePhase.Minutes - 2)).ToString();
            }


            TextNeedlePunturesExp = comment;
            TextTimeExp = comment2;

            TextNerveWrongIntro = "";
            TextNerveWrong = "";
            TextNerveWrongExp = "";
            TextVascularWrongIntro = "";
            TextVascularWrong = "";
            TextVascularWrongExp = "";

            if (CurrentPhase.NerveMultipleInjections)
            {
                int hitCorrectTarget = CurrentPhase.TargetPointsNerve.Where(x => ((x.Injections.Count > 0) && (x.T==0))).Count();
                int hitWrongNerve= CurrentPhase.TargetPointsNerve.Where(x => ((x.AreaEnteredFromNeedle > 0) && (x.T == 1))).Count();
                int hitWrongVascular = CurrentPhase.TargetPointsNerve.Where(x => ((x.AreaEnteredFromNeedle > 0) && (x.T == 2))).Count();

                int totalCorrectTargets = CurrentPhase.TargetPointsNerve.Where(x => x.T == 0).Count();
                
                TextNerveTarget = hitCorrectTarget.ToString() + " / " + totalCorrectTargets.ToString();
                TextWrongInjections = TargetMissedNerve_Injections.ToString();

                TextNerveTargetExp = "hit " + hitCorrectTarget.ToString() + " / " + totalCorrectTargets.ToString() + " targets";
                TextWrongInjectionsExp = TargetMissedNerve_Injections.ToString() + " injections. Score diminished by 10 for each wrong hit.";

                if (hitWrongNerve>0)
                {
                    TextNerveWrongIntro = "wrong nerve hits";
                    TextNerveWrong = hitWrongNerve.ToString();
                    TextNerveWrongExp = "hit " + hitWrongNerve.ToString() + " wrong nerve areas. Score dimished by 50 for each wrong hit.";
                }


                if (hitWrongVascular > 0)
                {
                    TextVascularWrongIntro = "wrong vascular hits";
                    TextVascularWrong = hitWrongVascular.ToString();
                    TextVascularWrongExp = "hit " + hitWrongVascular.ToString() + " vascular areas. Score set to 0.";
                }


                if (hitCorrectTarget < totalCorrectTargets)
                {
                    offset = offset - (100 * (decimal)(totalCorrectTargets - hitCorrectTarget) / (decimal)totalCorrectTargets);
                }

                if (TargetMissedNerve_Injections > 0)
                {
                    offset = offset - (10 * (TargetMissedNerve_Injections));
                }

                offset=offset-(50 * hitWrongNerve);
                offset = offset - (100 * hitWrongVascular);
                CurrentCaseScore = 100 + offset;
            }
            else
            {

                if (insertionNeedle > 1)
                {
                    offset = offset - (10 * (insertionNeedle - 1));
                }

                if (MinutesNeedlePhase > 2)
                {
                    offset = offset - (5 * ((int)MinutesNeedlePhase - 2));
                }
                CurrentCaseScore = NeedleTargetedFascia ? (100 + offset) : 0;

                TextFasciaTarget = NeedleTargetedFascia ? BlockSim.Globalization.Language.str_yes : BlockSim.Globalization.Language.str_no;

                TextFasciaTargetExp = NeedleTargetedFascia ? BlockSim.Globalization.Language.str_ok : BlockSim.Globalization.Language.str_score_set_to_zero;
            }
            if (CurrentCaseScore < 0)
            {
                CurrentCaseScore = 0;
            }
            TextScore = CurrentCaseScore.ToString("00.00");

            VisibilityResults = Visibility.Visible;

            if (imageRefresher != null)
            {
                imageRefresher.Stop();
                imageRefresher = null;
            }
        }

        public void StartPleuralAnimationTimer()
        {
            if (IsParavertebralCase())
            {
                if (imageRefresher != null)
                {
                    imageRefresher.Stop();
                    imageRefresher.Start();
                }
                else
                {
                    imageRefresher = new DispatcherTimer();
                    imageRefresher.Interval = new TimeSpan(0, 0, 0, 0, 100);
                    imageRefresher.IsEnabled = true;
                    imageRefresher.Tick += ImageRefresher_Tick;
                    imageRefresher.Start();
                }
            }
            else if (imageRefresher != null)
            {
                imageRefresher.Stop();
                imageRefresher = null;
            }
        }

        private float CalculateDistanceNeedleToFascia(SharpDX.Vector3 vector3, out float t, out bool upOrLow, out SharpDX.Vector3 vectorToCentral)
        {
            t = 0;
            upOrLow = false;
            vectorToCentral = new SharpDX.Vector3();
            if (deformableArea != null)
            {
                return deformableArea.GetMinimumDistance(vector3 - DisplacementDeformableArea, out t, out upOrLow, out vectorToCentral);
            }
            else
            {
                return 1000f;
            }
        }

        private bool CheckInSkin_WRS(VectorMath.Vector3 position, double histUp, double histDown, double histUpPadD, double histDownPadD, bool valuePreviousStep, bool imPadD)
        {
            if (!imPadD)
            {
                bool condition1 = (position.Z < (zmin - histUp));
                bool condition2 = (position.Z > (zmin + histDown));
                bool conditionBasic = (position.X > xmin) && (position.X < xmax) && (position.Y > ymin) && (position.Y < ymax) && (position.Z < zmax);

                if (!conditionBasic)
                {
                    return false;
                }
                else
                {
                    if (valuePreviousStep)
                    {
                        if (condition1)
                        {
                            return false;
                        }
                        else
                        {
                            return true;
                        }
                    }
                    else
                    {
                        if (condition2)
                        {
                            return true;
                        }
                        else
                        {
                            return false;
                        }
                    }
                }
            }
            else
            {
                if (NeedleHits)
                {
                    Vector3 diff = new Vector3((float)(CollidePointNeedle.X - needlePointFinish_WRS_real_adapted.X),
                        (float)(CollidePointNeedle.Y - needlePointFinish_WRS_real_adapted.Y),
                        (float)(CollidePointNeedle.Z - needlePointFinish_WRS_real_adapted.Z));

                    float c = -Vector3.Dot(diff, vecCollisionNeedle_WRS);
                    Debug.WriteLine("%%" + c.ToString());
                    bool condition1 = (c < -histUpPadD);
                    bool condition2 = (c > +histDownPadD);

                    if (valuePreviousStep)
                    {
                        if (condition1)
                        {
                            return false;
                        }
                        else
                        {
                            return true;
                        }
                    }
                    else
                    {
                        if (condition2)
                        {
                            return true;
                        }
                        else
                        {
                            return false;
                        }
                    }
                }
                else
                {
                    return false;
                }
            }
        }

        private bool CheckProbeOnSkin_WRS(VectorMath.Vector3 position, double histUp, double histDown, bool imPadD)
        {
            if (!imPadD)
            {
                bool condition1 = (position.Z < (zmin - histUp));
                bool condition2 = (position.Z > (zmin + histDown));
                bool conditionBasic = (position.X > xmin) && (position.X < xmax) && (position.Y > ymin) && (position.Y < ymax) && (position.Z < zmax);

                return condition1 && condition2 && conditionBasic;
            }
            else
            {
                bool condition1 = (distanceProbeHits < 20);
                return condition1;
            }
        }

        private int indexImageTime = 0;

        private bool CheckOnSkin_WRS(VectorMath.Vector3 position)
        {
            return ((position.X > xmin) && (position.X < xmax) && (position.Y > ymin) && (position.Y < ymax) && (position.Z > zmin) && (position.Z < zmax));
        }

        private float millisecondsTimeElapseForImageChange = 50f;

        private void EvaluateAndUpdateImage(VectorMath.Vector3 position, YPR orientatio)
        {
            try
            {
                Trace.WriteLine("R: "+ orientatio.RollDegree.ToString("00.00") + " P: " + orientatio.PitchDegree.ToString("00.00") + " Y: " + orientatio.YawDegree.ToString("00.00"));
                //Trace.WriteLine("X: " + position.X.ToString("00.00") + " Y: " + position.Y.ToString("00.00") + " Z: " + position.Z.ToString("00.00"));
                if ((WindowTeacher.PageContainer.Content is WorkingFrameTeacher))
                {
                    WorkingFrameTeacher wft = (WorkingFrameTeacher)WindowTeacher.PageContainer.Content;
                    StudentFrame sf = (StudentFrame)WindowStudent.PageContainer.Content;
                    Enum_VariableTypeLimit guidingVariable = CurrentPhase.GuidingVariable;
                    millisecondsTimeElapseForImageChange = CurrentPhase.GuidingVariableTimeSwitchMilliseconds;
                    LimitDefinition largestLimitToCorrect = null;
                    float largestError = float.MinValue;
                    int index = -1;
                    foreach (LimitDefinition l in CurrentPhase.Limits)
                    {
                        switch (l.variableTypeLimit)
                        {
                            case Enum_VariableTypeLimit.X:
                                l.Evaluate(position.X, l.variableTypeLimit == guidingVariable, CurrentPhase.OffsetGuidingVariableOverImages, false, false);
                                break;

                            case Enum_VariableTypeLimit.Y:
                                l.Evaluate(position.Y, l.variableTypeLimit == guidingVariable, CurrentPhase.OffsetGuidingVariableOverImages, false, false);
                                break;

                            case Enum_VariableTypeLimit.Z:
                                l.Evaluate(position.Z, l.variableTypeLimit == guidingVariable, CurrentPhase.OffsetGuidingVariableOverImages, false, false);
                                break;

                            case Enum_VariableTypeLimit.YZ:
                                l.Evaluate(position.Y, position.Z, l.variableTypeLimit == guidingVariable, CurrentPhase.OffsetGuidingVariableOverImages, CurrentPhase.PointStart_HRS, CurrentPhase.PointEnd_HRS, false);
                                break;

                            case Enum_VariableTypeLimit.YAW:
                                l.Evaluate((float)orientatio.YawDegree, l.variableTypeLimit == guidingVariable, CurrentPhase.OffsetGuidingVariableOverImages, false, false);
                                break;

                            case Enum_VariableTypeLimit.PITCH:
                                l.Evaluate((float)orientatio.PitchDegree, l.variableTypeLimit == guidingVariable, CurrentPhase.OffsetGuidingVariableOverImages, false, false);
                                break;

                            case Enum_VariableTypeLimit.ROLL:
                                l.Evaluate((float)orientatio.RollDegree, l.variableTypeLimit == guidingVariable, CurrentPhase.OffsetGuidingVariableOverImages, false, true);
                                break;


                            case Enum_VariableTypeLimit.ROLL_OFFSET180:
                                l.Evaluate((float)orientatio.RollDegree - 180, l.variableTypeLimit == guidingVariable, CurrentPhase.OffsetGuidingVariableOverImages, false, true);
                                break;

                            case Enum_VariableTypeLimit.ROLLABS:
                                l.Evaluate((float)orientatio.RollDegree, l.variableTypeLimit == guidingVariable, CurrentPhase.OffsetGuidingVariableOverImages, true, false);
                                break;

                            default:
                                break;
                        }
                        if (guidingVariable == Enum_VariableTypeLimit.TIME)
                        {
                            if ((DateTime.Now - TimeElapseForImageChange).TotalMilliseconds > millisecondsTimeElapseForImageChange)
                            {
                                TimeElapseForImageChange = DateTime.Now;
                                indexImageTime = indexImageTime + 1;

                                if (indexImageTime >= CurrentPhase.ImagesEco.Count)
                                {
                                    indexImageTime = 0;
                                }
                                toPass = GetImageToPass(indexImageTime);
                                toPass2 = toPass;
                            }

                            if (l.PercError > largestError)
                            {
                                largestError = l.PercError;
                                largestLimitToCorrect = l;
                            }
                        }
                        else
                        {
                            if (l.variableTypeLimit == guidingVariable)
                            {
                                index = l.GiveMeIndexImage(1, CurrentPhase.ImagesEco.Count);

                                if (index >= 0)
                                {
                                    toPass = GetImageToPass(index);
                                    toPass2 = toPass;
                                    if ((l.ExceededMax) || (l.ExceededMin))
                                    {
                                        largestError = l.PercError;
                                        largestLimitToCorrect = l;
                                    }
                                }
                                else
                                {
                                    largestError = l.PercError;
                                    largestLimitToCorrect = l;
                                    break;
                                }
                            }
                            else
                            {
                                if (l.PercError > largestError)
                                {
                                    largestError = l.PercError;
                                    largestLimitToCorrect = l;
                                }
                            }
                        }
                    }
                    int indexToTake = guidingVariable == Enum_VariableTypeLimit.TIME ? indexImageTime : index;
                    if (toPass == null)
                    {
                        toPass = Convert(CurrentPhase.ImagesEco[0].GetDecompressedImage());
                    }
                    if (toPass2 == null)
                    {
                        toPass2 = Convert(CurrentPhase.ImagesEco[0].GetDecompressedImage());
                    }
                    bool targetMuscularIndicationColorVisible = false;
                    bool targetNerveIndicationColorVisible = false;
                    SetImage(largestError, toPass, toPass2, largestLimitToCorrect, false, indexToTake);
                    SetText(wft.lIndexImage, indexToTake.ToString());

                    int indexToUse = indexToTake;
                    int indexStopFrame = CurrentPhase.EffectStopFrame;
                    int indexStartFrame = CurrentPhase.EffectStartFrame;
                    if (CurrentPhase.RevertImages)
                    {
                        indexToUse = CurrentPhase.NumberOfImages - indexToTake - 1;
                        indexStopFrame = CurrentPhase.NumberOfImages - indexStopFrame - 1;
                        indexStartFrame = CurrentPhase.NumberOfImages - indexStartFrame - 1;
                    }
                    if ((CurrentPhase.PhaseType == Enum_Phases.INVESTIGATE_HOTSPOT_NEEDLE) || ((CurrentPhase.PhaseType == Enum_Phases.INVESTIGATE_TRAJECTORY_NEEDLE)))
                    {
                        if (!CurrentPhase.NerveMultipleInjections)
                        {
                            if ((indexToTake >= Math.Min(indexStartFrame, indexStopFrame)) && (indexToTake <= Math.Max(indexStopFrame, indexStartFrame)))
                            {
                                TargetStructureAvailableInFrame = true;
                                if (!EffectFasciaHitActivated)
                                {
                                    DisplacementDeformableArea = new SharpDX.Vector3(framesDefinition.Items[indexToUse].PosX * (float)wScaled, framesDefinition.Items[indexToUse].PosY * (float)hScaled, 0f);
                                    //Show TargetIndication

                                    dispCenterCircularBlockMuscular = new SharpDX.Vector3(
                                       ((CurrentPhase.PointsEffect[1].X - CurrentPhase.PointsEffect[0].X) / 2f) * (float)wScaled,
                                       ((CurrentPhase.PointsEffect[1].Y - CurrentPhase.PointsEffect[0].Y) / 2f) * (float)hScaled,
                                       -5) + DisplacementDeformableArea;

                                    if (TargetMuscularIndication != null)
                                    {
                                        for (int kk = 0; kk < TargetMuscularIndication.Positions.Count; kk++)
                                        {
                                            TargetMuscularIndication.Positions[kk] = pointsCircle[kk] + dispCenterCircularBlockMuscular;
                                        }

                                        ////TargetMuscularIndication.Positions[1] = nedleAreaIndicationEnd;
                                        TargetMuscularIndication.UpdateVertices();
                                    }

                                    UpdatePointsFascia(EffectFasciaHitActivated, !EffectFasciaHitActivated);
                                    targetMuscularIndicationColorVisible = CurrentPhase.MuscularBlock && ShowTargetPosition;
                                    
                                }
                            }
                            else
                            {
                                TargetStructureAvailableInFrame = false;
                            }
                            TargetMuscularIndicationColor = System.Windows.Media.Color.FromArgb((targetMuscularIndicationColorVisible ? (byte)255 : (byte)0), 0, 255, 255);
                        }
                        else
                        {
                            TargetStructureAvailableInFrame = true;

                            dispCentersCircularNerve = new List<SharpDX.Vector3>();

                            dispCentersCircularNerve.Clear();
                            for (int ww = 0; ww < CurrentPhase.TargetPointsNerve.Count; ww++)
                            {
                                dispCentersCircularNerve.Add(new SharpDX.Vector3(
(float)CurrentPhase.TargetPointsNerve[ww].X * (float)wScaled,
(float)CurrentPhase.TargetPointsNerve[ww].Y * (float)hScaled,
-5));
                            }

                            targetNerveIndicationColorVisible = ShowTargetPosition;

                            if (TargetsNerveIndication != null)
                            {
                                if (TargetsNerveIndication.Count > 0)
                                {
                                    for (int vv = 0; vv < TargetsNerveIndication.Count; vv++)
                                    {
                                        for (int kk = 0; kk < TargetsNerveIndication[vv].Positions.Count; kk++)
                                        {
                                            TargetsNerveIndication[vv].Positions[kk] = pointsNerve[vv][kk] + dispCentersCircularNerve[vv];
                                        }
                                        TargetsNerveIndication[vv].UpdateVertices();
                                        if (vv == 0)
                                        {
                                            TargetNerveIndication1 = TargetsNerveIndication[0];
                                            TargetNerveIndicationColor1 = GiveMeColor(targetNerveIndicationColorVisible, CurrentPhase.TargetPointsNerve[vv]);
                                        }
                                        if (vv == 1)
                                        {
                                            TargetNerveIndication2 = TargetsNerveIndication[1];
                                            TargetNerveIndicationColor2 = GiveMeColor(targetNerveIndicationColorVisible, CurrentPhase.TargetPointsNerve[vv]);
                                        }
                                        if (vv == 2)
                                        {
                                            TargetNerveIndication3 = TargetsNerveIndication[2];
                                            TargetNerveIndicationColor3 = GiveMeColor(targetNerveIndicationColorVisible, CurrentPhase.TargetPointsNerve[vv]);
                                        }
                                        if (vv == 3)
                                        {
                                            TargetNerveIndication4 = TargetsNerveIndication[3];
                                            TargetNerveIndicationColor4 = GiveMeColor(targetNerveIndicationColorVisible, CurrentPhase.TargetPointsNerve[vv]);
                                        }
                                        if (vv == 4)
                                        {
                                            TargetNerveIndication5 = TargetsNerveIndication[4];
                                            TargetNerveIndicationColor5 = GiveMeColor(targetNerveIndicationColorVisible, CurrentPhase.TargetPointsNerve[vv]);
                                        }
                                        if (vv == 5)
                                        {
                                            TargetNerveIndication6 = TargetsNerveIndication[5];
                                            TargetNerveIndicationColor6 = GiveMeColor(targetNerveIndicationColorVisible, CurrentPhase.TargetPointsNerve[vv]);
                                        }
                                        if (vv == 6)
                                        {
                                            TargetNerveIndication7 = TargetsNerveIndication[6];
                                            TargetNerveIndicationColor7 = GiveMeColor(targetNerveIndicationColorVisible, CurrentPhase.TargetPointsNerve[vv]);
                                        }
                                        if (vv == 7)
                                        {
                                            TargetNerveIndication8 = TargetsNerveIndication[7];
                                            TargetNerveIndicationColor8 = GiveMeColor(targetNerveIndicationColorVisible, CurrentPhase.TargetPointsNerve[vv]);
                                        }
                                        if (vv == 8)
                                        {
                                            TargetNerveIndication9 = TargetsNerveIndication[8];
                                            TargetNerveIndicationColor9 = GiveMeColor(targetNerveIndicationColorVisible, CurrentPhase.TargetPointsNerve[vv]);
                                        }
                                        if (vv == 9)
                                        {
                                            TargetNerveIndication10 = TargetsNerveIndication[9];
                                            TargetNerveIndicationColor10 = GiveMeColor(targetNerveIndicationColorVisible, CurrentPhase.TargetPointsNerve[vv]);
                                        }
                                        if (vv == 10)
                                        {
                                            TargetNerveIndication11 = TargetsNerveIndication[10];
                                            TargetNerveIndicationColor11 = GiveMeColor(targetNerveIndicationColorVisible, CurrentPhase.TargetPointsNerve[vv]);
                                        }
                                    }
                                }
                            }

                            Color f = new Color();
                            TargetNerveIndicationColor = System.Windows.Media.Color.FromArgb((targetNerveIndicationColorVisible ? (byte)255 : (byte)0), 0, 255, 255);
                        }
                        SetIndicator(sf.elFasciaPresent, TargetStructureAvailableInFrame);
                        SetIndicator(wft.elFasciaPresent, TargetStructureAvailableInFrame);
                        if (!needleInSkin)
                        {
                            if (!EffectFasciaHitActivated)
                            {
                                SetText(sf.tbIndicationsStudent, (TargetStructureAvailableInFrame ? StringNeedleInjTakeAim : StringNeedleInjFindFrame));
                            }
                        }
                        WindowTeacher.Dispatcher.Invoke(() =>
                        {
                            if (!CurrentPhase.NerveMultipleInjections)
                            {
                                if (!EffectFasciaHitActivated)
                                {
                                    SetModelMaterialDeformableArea(true, false, false);
                                }
                            }
                        });
                    }

                    if (!plottedCircles)
                    {
                        plottedCircles = true;
                    }
                }
            }
            catch (Exception ex)
            {
            }
        }

        private Color GiveMeColor(bool targetNerveIndicationColorVisible, TargetPointNerve t)
        {
            int k = t.T;
            bool alreadyFound = ((k == 0) && (t.Injections.Count > 0));

            switch (k)
            {
                case 0:
                    return System.Windows.Media.Color.FromArgb(((targetNerveIndicationColorVisible && !alreadyFound) ? (byte)255 : (byte)0), 0, 255, 255);

                    break;
                case 1:
                    return System.Windows.Media.Color.FromArgb((targetNerveIndicationColorVisible ? (byte)255 : (byte)0), 250, 250, 51);

                    break;
                case 2:
                    return System.Windows.Media.Color.FromArgb((targetNerveIndicationColorVisible ? (byte)255 : (byte)0), 255, 0, 0);

                    break;
                default:
                    return System.Windows.Media.Color.FromArgb((targetNerveIndicationColorVisible ? (byte)255 : (byte)0), 0, 255, 255);
                    break;
            }
            
        }

        private BitmapSource GetImageToPass(int currentIndex)
        {
            BitmapImage bitmapImg = Convert(CurrentPhase.ImagesEco[currentIndex].GetDecompressedImage());

            if (CurrentPhase.RequireAnimation())
                return animator1.GetAnimationFrame(new PleuralAnimationParameters(CurrentPhase, currentIndex, bitmapImg, false));
            else
                return bitmapImg;
        }

        private void EvaluateAvailableSimulators()
        {
            try
            {
                BKSSimulatorConnected = BlockSimController.Instance.Simulator != null;

                SetIndicator(WindowTeacher.elBlockSim, BlockSimController.Instance.Simulator != null);
            }
            catch (Exception ex)
            {
                Debug.WriteLine(ex.Message + ex.StackTrace);
            }
        }

        private VectorMath.Vector3 GiveMeRotationRelativeAntenna(System.Windows.Media.Media3D.Quaternion rotationOperableEnsamble)
        {
            VectorMath.Quaternion q = new VectorMath.Quaternion((float)RotationOperableEnsamble.X, (float)RotationOperableEnsamble.Y, (float)RotationOperableEnsamble.Z, (float)RotationOperableEnsamble.W);

            VectorMath.Matrix m = VectorMath.Matrix.RotationQuaternion(q);

            VectorMath.Vector3 rotTrasl = Calculator.Instance.RototraslatePoint(new VectorMath.Vector3((float)(originalPositionSkinBlockCenter_WRS.X), (float)(originalPositionSkinBlockCenter_WRS.Y), (float)(originalPositionSkinBlockCenter_WRS.Z)), Calculator.Instance.TrasposeMatrix(Calculator.Instance.GetRotationMatrix(m)), new VectorMath.Vector3(0, 0, 0));
            return rotTrasl;
        }

        private void PDIClass_OnConnectionStatusChanged(Device.Motion.CONNECTIONSTATUS status)
        {
            SetIndicator(WindowTeacher.elSensors, status == Device.Motion.CONNECTIONSTATUS.ACQUIRING);
        }

        private void PDIClass_OnNewFrameAvailable(List<Device.Motion.FRAME> frames)
        {
            try
            {
                WindowTeacher.Dispatcher.Invoke((Action)(() =>
                {
                    if (!alreadyConnectedPolhemus)
                    {
                        alreadyConnectedPolhemus = true;
                        SetIndicator(WindowTeacher.elSensors, alreadyConnectedPolhemus);
                    }
                    LineColorPositive = System.Windows.Media.Brushes.White;
                    LineColorNegative = System.Windows.Media.Brushes.White;
                    if ((WindowTeacher.PageContainer.Content is WorkingFrameTeacher) && (WindowStudent.PageContainer.Content is StudentFrame))
                    {
                        if (ToElaborateData)
                        {
                            StudentFrame sf = (StudentFrame)WindowStudent.PageContainer.Content;
                            WorkingFrameTeacher wft = (WorkingFrameTeacher)WindowTeacher.PageContainer.Content;
                            lastArrivedInput = DateTime.Now;
                            counter++;
                            int divider = 5;
                            int resPlot = 0; Math.DivRem(counter, divider, out resPlot);
                            int resControls = 0; Math.DivRem(counter, divider, out resControls);

                            toPlot = resPlot == 0;
                            toUpdateControls = resControls == 0;

                            if (toPlot && frames.Count > 0)
                            {
                                //Get frame 1
                                f1 = frames[0];
                                positionSensor01_WRS = new VectorMath.Vector3(f1.Pos.X * 10, f1.Pos.Y * 10, f1.Pos.Z * 10);
                                rotationSensor01_WRS = f1.Ori;
                                rotationProbe_WRS = VectorMath.Quaternion.Multiply(rotationFromSensor01ToProbe, rotationSensor01_WRS);

                                rotationMatrixTrasposed_Probe_WRS = Calculator.Instance.TrasposeMatrix(Calculator.Instance.GetRotationMatrix(VectorMath.Matrix.RotationQuaternion(rotationProbe_WRS)));

                                positionProbeCenter_WRS = Calculator.Instance.RototraslatePoint(D_S01Center_PCenter, rotationMatrixTrasposed_Probe_WRS, positionSensor01_WRS);
                                positionProbeEdge_WRS = Calculator.Instance.RototraslatePoint(D_S01Center_PCenter + D_PCenter_PEdge, rotationMatrixTrasposed_Probe_WRS, positionSensor01_WRS);
                                positionProbeEdge_WRS_ForCollisionPadD = Calculator.Instance.RototraslatePoint(D_S01Center_PCenter + D_PCenter_PEdge + D_COLLISION, rotationMatrixTrasposed_Probe_WRS, positionSensor01_WRS);
                                positionProbeEdge_WRS_ForAntiCollisionPadD = Calculator.Instance.RototraslatePoint(D_S01Center_PCenter + D_PCenter_PEdge + D_ANTICOLLISION, rotationMatrixTrasposed_Probe_WRS, positionSensor01_WRS);

                                vecCollisionProbe_WRS = Vector3.Subtract(positionProbeEdge_WRS, positionProbeEdge_WRS_ForAntiCollisionPadD);

                                //positionProbe_WRS = Calculator.Instance.CopyVector3(positionSensor01_WRS);
                                positionProbeEdge_HRS = Calculator.Instance.ChangeCoordinatesOfAPoint(positionProbeEdge_WRS, originalPositionSkinBlockCenter_WRS, rotationMatrix_WRS_TO_HRS);

                                XPosSensor01 = positionSensor01_WRS.X;
                                YPosSensor01 = positionSensor01_WRS.Y;
                                ZPosSensor01 = positionSensor01_WRS.Z;

                                XPosProbeCenter = positionProbeCenter_WRS.X;
                                YPosProbeCenter = positionProbeCenter_WRS.Y;
                                ZPosProbeCenter = positionProbeCenter_WRS.Z;

                                XPosProbeEdge = positionProbeEdge_WRS.X;
                                YPosProbeEdge = positionProbeEdge_WRS.Y;
                                ZPosProbeEdge = positionProbeEdge_WRS.Z;

                                rotationSensor01_HRS = VectorMath.Quaternion.Multiply(rotationSensor01_WRS, rotationQuaternion_WRS_TO_HRS_VectorMath);
                                VectorMath.Vector3 s1_WRS = EulerUtils.DCMtoEA(VectorMath.Matrix.RotationQuaternion(rotationSensor01_WRS), EULER_CALC_MODE.ZYX);
                                VectorMath.Vector3 s1_HRS = EulerUtils.DCMtoEA(VectorMath.Matrix.RotationQuaternion(rotationSensor01_HRS), EULER_CALC_MODE.ZYX);
                                sensor01ypr_WRS = new YPR() { Yaw = s1_WRS.Z, Pitch = s1_WRS.Y, Roll = s1_WRS.X };
                                sensor01ypr_HRS = new YPR() { Yaw = s1_HRS.Z, Pitch = s1_HRS.Y, Roll = s1_HRS.X };

                                rotationProbe_HRS = VectorMath.Quaternion.Multiply(rotationProbe_WRS, rotationQuaternion_WRS_TO_HRS_VectorMath);
                                VectorMath.Vector3 probe_WRS = EulerUtils.DCMtoEA(VectorMath.Matrix.RotationQuaternion(rotationProbe_WRS), EULER_CALC_MODE.ZYX);
                                VectorMath.Vector3 probe_HRS = EulerUtils.DCMtoEA(VectorMath.Matrix.RotationQuaternion(rotationProbe_HRS), EULER_CALC_MODE.ZYX);
                                probeYPR_WRS = new YPR() { Yaw = probe_WRS.Z, Pitch = probe_WRS.Y, Roll = probe_WRS.X };
                                probeYPR_HRS = new YPR() { Yaw = probe_HRS.Z, Pitch = probe_HRS.Y, Roll = probe_HRS.X };

                                RotationSensor01_WRS = Calculator.Instance.GetQuatFromVectorMat(rotationSensor01_WRS);
                                RotationProbe_WRS = Calculator.Instance.GetQuatFromVectorMat(rotationProbe_WRS);

                                VectorMath.Vector3 axisX = Calculator.Instance.RototraslatePoint(new VectorMath.Vector3(1, 0, 0), rotationMatrixTrasposed_Probe_WRS, new VectorMath.Vector3(0, 0, 0));
                                VectorMath.Vector3 axisY = Calculator.Instance.RototraslatePoint(new VectorMath.Vector3(0, 1, 0), rotationMatrixTrasposed_Probe_WRS, new VectorMath.Vector3(0, 0, 0));
                                VectorMath.Vector3 axisZ = Calculator.Instance.RototraslatePoint(new VectorMath.Vector3(0, 0, 1), rotationMatrixTrasposed_Probe_WRS, new VectorMath.Vector3(0, 0, 0)); //the normal

                                // plane equation(Normal: n; passing by q) =>
                                //          n[0]*(x-q.x) + n[1]*(y-q.y) + n[2]*(z-q[2]) = 0 =>
                                //          AxisZ[0]*(x-position.X) + AxisZ[1]*(y-position.Y) + AxisZ[2]*(<-position.Z) = 0;
                                // Ax+By+Cz+D=0 =>
                                //          D =-AxisZ[0]*position.X-AxisZ[1]*position.Y-AxisZ[2]*position.Z;
                                //          A =axisZ[0];
                                //          B =axisZ[1];
                                //          C =axisZ[2]
                                // distance d of point P1 from Plane
                                //          d = abs(A*x1 + B*y1 + C*z1 + D)/Math.Sqrt(A*A+B*B+C*C);

                                double D = -axisZ[0] * positionProbeEdge_WRS.X - axisZ[1] * positionProbeEdge_WRS.Y - axisZ[2] * positionProbeEdge_WRS.Z;
                                double A = axisZ[0];
                                double B = axisZ[1];
                                double C = axisZ[2];
                                double distance = 0;

                                probeOnSkin = CheckProbeOnSkin_WRS(positionProbeEdge_WRS, -35, -20, AppControl.Instance.CurrentModel == "neck");
                                needleTipOnPlane = false;
                                float zProbe = 0;
                                if (probeOnSkin)
                                {
                                    zProbe = zPadSurface;
                                }
                                else
                                {
                                    zProbe = positionProbeEdge_WRS.Z;
                                }
                                if (frames.Count > 1)
                                {
                                    //GET FRAME NEEDLE
                                    f2 = frames[1];
                                    positionSensor02_WRS_real = new VectorMath.Vector3(f2.Pos.X * 10, f2.Pos.Y * 10, f2.Pos.Z * 10);

                                    //Position sensors in world reference system
                                    XPosSensor02 = positionSensor02_WRS_real.X;
                                    YPosSensor02 = positionSensor02_WRS_real.Y;
                                    ZPosSensor02 = positionSensor02_WRS_real.Z;

                                    rotationSensor02_WRS_real = f2.Ori;
                                    rotationNeedle_WRS_real = VectorMath.Quaternion.Multiply(rotationFromSensor02ToNeedle, rotationSensor02_WRS_real);
                                    RotationNeedle_WRS_real = Calculator.Instance.GetQuatFromVectorMat(rotationNeedle_WRS_real);
                                    rotationMatrixTrasposed_Needle_WRS_real = Calculator.Instance.TrasposeMatrix(Calculator.Instance.GetRotationMatrix(VectorMath.Matrix.RotationQuaternion(rotationNeedle_WRS_real)));

                                    needlePointStart_WRS_real = (Calculator.Instance.RototraslatePoint(needlePoints_NRS.First(), rotationMatrixTrasposed_Needle_WRS_real, positionSensor02_WRS_real));
                                    needlePointFinish_WRS_real = (Calculator.Instance.RototraslatePoint(needlePoints_NRS[Math.Max(needlePoints_NRS.Count - 1, IndexRealFinishNeedle - 1)], rotationMatrixTrasposed_Needle_WRS_real, positionSensor02_WRS_real));
                                    needlePointFinish_WRS_realHalf = (Calculator.Instance.RototraslatePoint(needlePoints_NRS[Math.Max(needlePoints_NRS.Count - 1, IndexRealFinishNeedle - 1) / 2], rotationMatrixTrasposed_Needle_WRS_real, positionSensor02_WRS_real));

                                    bool needleInSkinNew = false;
                                    needlePointFinish_WRS_real_adapted = new VectorMath.Vector3(needlePointFinish_WRS_real.X, needlePointFinish_WRS_real.Y, needlePointFinish_WRS_real.Z + additionalLengthZForPunctureOnCurve);
                                    //needlePointFinish_WRS_real_ForCollisionPadD = (Calculator.Instance.RototraslatePoint(needlePoints_NRS[Math.Max(needlePoints_NRS.Count - 1, IndexRealFinishNeedle - 1)] + D_COLLISION_NEEDLE, rotationMatrixTrasposed_Needle_WRS_real, positionSensor02_WRS_real));
                                    needlePointFinish_WRS_real_ForAntiCollisionPadD = (Calculator.Instance.RototraslatePoint(needlePoints_NRS[Math.Max(needlePoints_NRS.Count - 1, IndexRealFinishNeedle - 1)] + D_ANTICOLLISION_NEEDLE, rotationMatrixTrasposed_Needle_WRS_real, positionSensor02_WRS_real));
                                    //needlePointFinish_WRS_real_ForAntiCollisionPadD = new VectorMath.Vector3(needlePointFinish_WRS_realHalf.X, needlePointFinish_WRS_realHalf.Y, needlePointFinish_WRS_realHalf.Z);
                                    vecCollisionNeedle_WRS = Vector3.Subtract(needlePointFinish_WRS_real_adapted, needlePointFinish_WRS_real_ForAntiCollisionPadD);
                                    vecCollisionNeedle_WRS.Normalize();
                                    //vecCollisionNeedle_WRS = Vector3.Subtract(needlePointFinish_WRS_real_ForAntiCollisionPadD, needlePointFinish_WRS_real_ForCollisionPadD);
                                    //vecCollisionNeedle_WRS.Normalize();

                                    needleInSkinNew = CheckInSkin_WRS(needlePointFinish_WRS_real_adapted, Properties.Settings.Default.ExitThresholdNeedle, Properties.Settings.Default.EntranceThresholdNeedle, Properties.Settings.Default.ExitThresholdNeedlePadD, Properties.Settings.Default.EntranceThresholdNeedlePadD, needleInSkin, AppControl.Instance.CurrentModel == "neck");
                                    bool entered = false;
                                    if (!needleInSkin)
                                    {
                                        //if outside --> just check presence of needle tip in skin assuming that the needle is perfletly straight
                                        if (needleInSkinNew && !EffectFasciaHitActivated)
                                        {
                                            InsertionNeedle++;

                                            //save insertion point and configuration of needle orientation

                                            //veror To change here?
                                            InsertionPointNeedle_WRS = new VectorMath.Vector3(needlePointFinish_WRS_real.X, needlePointFinish_WRS_real.Y, needlePointFinish_WRS_real.Z);
                                            versorNeedle_WhenInsertion = (needlePointFinish_WRS_real - needlePointStart_WRS_real); versorNeedle_WhenInsertion.Normalize();

                                            rotationSensor02_WRS_WhenInsertion = new VectorMath.Quaternion(f2.Ori.X, f2.Ori.Y, f2.Ori.Z, f2.Ori.W);
                                            rotationNeedle_WRS_WhenInsertion = VectorMath.Quaternion.Multiply(rotationFromSensor02ToNeedle, rotationSensor02_WRS_WhenInsertion);
                                            RotationNeedle_WRS_WhenInsertion = Calculator.Instance.GetQuatFromVectorMat(rotationNeedle_WRS_WhenInsertion);
                                            rotationMatrixTrasposed_Needle_WRS_WhenInsertion = Calculator.Instance.TrasposeMatrix(Calculator.Instance.GetRotationMatrix(VectorMath.Matrix.RotationQuaternion(rotationNeedle_WRS_WhenInsertion)));
                                            entered = true;
                                        }
                                    }

                                    needleInSkin = needleInSkinNew;
                                    bool enableInflate = false;
                                    if (CurrentPhase != null)
                                    {
                                        enableInflate = needleInSkin && ((CurrentPhase.PhaseType == Enum_Phases.INVESTIGATE_HOTSPOT_NEEDLE) || (CurrentPhase.PhaseType == Enum_Phases.INVESTIGATE_TRAJECTORY_NEEDLE));
                                    }
                                    WindowTeacher.Dispatcher.Invoke(() =>
                                    {
                                        if (wft.bDebugInflate.IsEnabled != enableInflate)
                                        {
                                            wft.bDebugInflate.IsEnabled = enableInflate;
                                        }
                                    });

                                    if (needleInSkin)
                                    {
                                        //Calculate where the needle starts
                                        float distanceOut = (InsertionPointNeedle_WRS - needlePointStart_WRS_real).Length;
                                        float distanceIn = LengthNeedle - distanceOut;
                                        positionSensor02_WRS_fake = InsertionPointNeedle_WRS - versorNeedle_WhenInsertion * distanceOut;
                                        positionSensor02_WRS_toBeUsed = new VectorMath.Vector3(positionSensor02_WRS_fake.X, positionSensor02_WRS_fake.Y, positionSensor02_WRS_fake.Z);
                                        rotationMatrixTrasposed_Needle_WRS_toBeUsed = rotationMatrixTrasposed_Needle_WRS_WhenInsertion;
                                    }
                                    else
                                    {
                                        positionSensor02_WRS_toBeUsed = new VectorMath.Vector3(positionSensor02_WRS_real.X, positionSensor02_WRS_real.Y, positionSensor02_WRS_real.Z);
                                        rotationMatrixTrasposed_Needle_WRS_toBeUsed = rotationMatrixTrasposed_Needle_WRS_real;
                                    }

                                    //Adapt position needle to specific cases
                                    if ((CurrentCase.TypeBlock == Enum_Configuration.QLB))
                                    {
                                        positionSensor02_WRS_toBeUsed.X = positionSensor02_WRS_toBeUsed.X + Properties.Settings.Default.XOffsetForQLBCases;
                                        positionSensor02_WRS_toBeUsed.Z = positionSensor02_WRS_toBeUsed.Z + Properties.Settings.Default.ZOffsetForQLBCases;
                                    }

                                    if ((CurrentCase.TypeBlock == Enum_Configuration.LUMBAR))
                                    {
                                        positionSensor02_WRS_toBeUsed.X = positionSensor02_WRS_toBeUsed.X + Properties.Settings.Default.XOffsetForLumbarCases;
                                        positionSensor02_WRS_toBeUsed.Z = positionSensor02_WRS_toBeUsed.Z + Properties.Settings.Default.ZOffsetForLumbarCases;
                                    }

                                    //needle points World Reference System
                                    for (int l = 0; l < numPointsNeedle; l++)
                                    {
                                        needlePoints_WRS[l] = (Calculator.Instance.RototraslatePoint(needlePoints_NRS[l], rotationMatrixTrasposed_Needle_WRS_toBeUsed, positionSensor02_WRS_toBeUsed));
                                    }
                                    needlePointStart_WRS_toBeUsed = needlePoints_WRS.First();
                                    needlePointFinish_WRS_toBeUsed = needlePoints_WRS.Last();

                                    XTipNeedle = needlePointFinish_WRS_toBeUsed.X;
                                    YTipNeedle = needlePointFinish_WRS_toBeUsed.Y;
                                    ZTipNeedle = needlePointFinish_WRS_toBeUsed.Z;

                                    VectorMath.Vector3 lineNeedle = needlePointFinish_WRS_toBeUsed - needlePointStart_WRS_toBeUsed;
                                    VectorMath.Vector3 lineNeedleVersor = lineNeedle / lineNeedle.Length;

                                    needlePointFinish_HRS = Calculator.Instance.ChangeCoordinatesOfAPoint(needlePointFinish_WRS_toBeUsed, originalPositionSkinBlockCenter_WRS, rotationMatrix_WRS_TO_HRS);

                                    //distance needletip to plane
                                    distance = Math.Abs(A * needlePointFinish_WRS_toBeUsed.X + B * needlePointFinish_WRS_toBeUsed.Y + C * needlePointFinish_WRS_toBeUsed.Z + D) / Math.Sqrt(A * A + B * B + C * C);
                                    bool needleVisible = true;
                                    if (entered)
                                    {
                                        if (distance < 8)
                                        {
                                            visibleNeedleDefinedAtEntrance = true;
                                        }
                                        else
                                        {
                                            visibleNeedleDefinedAtEntrance = false;
                                        }
                                    }
                                    if (Properties.Settings.Default.HideNeedleInsertionOffPlane)
                                    {
                                        if (!visibleNeedleDefinedAtEntrance)
                                        {
                                            needleVisible = false;
                                        }
                                    }

                                    // angle alpha between line with versor u=(u1,U2,u3) and plane with normal n=(A,B,C) =>
                                    //      alpha = Math.Asin(Math.Abs(A*u1+B*u2+C*u3)/Math.Sqrt(A*A + B*B + C*C))
                                    alpha = Math.Asin((A * lineNeedleVersor.X + B * lineNeedleVersor.Y + C * lineNeedleVersor.Z) / Math.Sqrt(A * A + B * B + C * C));
                                    angleDeg = alpha * 180.0 / Math.PI;

                                    //Express needle points on probe reference system and identify those crossing the probe plane
                                    Vector3 positionProbeEdge_WRS_toUse;

                                    if (Properties.Settings.Default.FixProbeEdge)
                                    {
                                        if ((CurrentCase.TypeBlock == Enum_Configuration.LUMBAR) || (CurrentCase.TypeBlock == Enum_Configuration.QLB))
                                        {
                                            //for some cases we cannot assume that the probe is on placed over the flat side of the insert
                                            positionProbeEdge_WRS_toUse = new Vector3(positionProbeEdge_WRS.X, positionProbeEdge_WRS.Y, positionProbeEdge_WRS.Z);
                                        }
                                        else
                                        {
                                            //we may assume a fixes, precise quote for the zposition of the probe, based on the geomtery of the specific pad
                                            positionProbeEdge_WRS_toUse = new Vector3(positionProbeEdge_WRS.X, positionProbeEdge_WRS.Y, zProbe);
                                        }
                                    }
                                    else
                                    {
                                        positionProbeEdge_WRS_toUse = new Vector3(positionProbeEdge_WRS.X, positionProbeEdge_WRS.Y, positionProbeEdge_WRS.Z);
                                    }

                                    for (int l = 0; l < numPointsNeedle; l++)
                                    {
                                        needlePoints_PRS[l] = Calculator.Instance.ChangeCoordinatesOfAPoint(needlePoints_WRS[l], positionProbeEdge_WRS_toUse, rotationMatrixTrasposed_Probe_WRS);
                                    }
                                    //Trace.WriteLine("X: " + needlePoints_PRS.Last().X.ToString("00.00") + " Y: " + needlePoints_PRS.Last().Y.ToString("00.00") + " Z: " + needlePoints_PRS.Last().Z.ToString("00.00"));
                                    int startIndex = -1;
                                    int endIndex = -1;
                                    int indexStartNegative = -1;
                                    int indexEndNegative = -1;
                                    int indexStartPositive = -1;
                                    int indexEndPositive = -1;

                                    float distStartPositive = -1;
                                    float distEndPositive = -1;
                                    float distStartNegative = -1;
                                    float distEndNegative = -1;
                                    bool negativePresent = false;
                                    bool positivePresent = false;
                                    bool allPresent = false;

                                    float dist = -1;

                                    int indexSNeg = -1;
                                    int indexENeg = -1;
                                    int indexSPos = -1;
                                    int indexEPos = -1;

                                    //Find interval where distance is negative
                                    for (int l = 0; l < numPointsNeedle; l++)
                                    {
                                        if (needlePoints_PRS[l].Z < 0)
                                        {
                                            if (indexSNeg == -1)
                                            {
                                                indexSNeg = l;
                                            }
                                        }
                                        else
                                        {
                                            if (indexSNeg != -1)
                                            {
                                                indexENeg = l;
                                                break;
                                            }
                                        }
                                    }
                                    if ((indexSNeg != -1) && (indexENeg == -1))
                                    {
                                        indexENeg = numPointsNeedle - 1;
                                    }

                                    //Find Interval where distance is positive
                                    for (int l = 0; l < numPointsNeedle; l++)
                                    {
                                        if (needlePoints_PRS[l].Z >= 0)
                                        {
                                            if (indexSPos == -1)
                                            {
                                                indexSPos = l;
                                            }
                                        }
                                        else
                                        {
                                            if (indexSPos != -1)
                                            {
                                                indexENeg = l;
                                                break;
                                            }
                                        }
                                    }
                                    if ((indexSPos != -1) && (indexEPos == -1))
                                    {
                                        indexEPos = numPointsNeedle - 1;
                                    }

                                    //Find interval where distance is negative and within range
                                    if ((indexENeg != -1) && (indexSNeg != -1))
                                    {
                                        for (int l = indexSNeg; l <= indexENeg; l++)
                                        {
                                            dist = Math.Abs(needlePoints_PRS[l].Z);

                                            if (dist < LimitZ)
                                            {
                                                if (indexStartNegative == -1)
                                                {
                                                    indexStartNegative = l;
                                                    distStartNegative = dist;
                                                }
                                            }
                                            else
                                            {
                                                if (indexStartNegative != -1)
                                                {
                                                    indexEndNegative = l - 1;
                                                    distEndNegative = dist;
                                                    break;
                                                }
                                            }
                                        }
                                        if ((indexStartNegative != -1) && (indexEndNegative == -1))
                                        {
                                            indexEndNegative = indexENeg;
                                            distEndNegative = dist;
                                        }
                                    }

                                    //Find interval where distance is positive and within range
                                    if ((indexEPos != -1) && (indexSPos != -1))
                                    {
                                        for (int l = indexSPos; l <= indexEPos; l++)
                                        {
                                            dist = Math.Abs(needlePoints_PRS[l].Z);

                                            if (dist < LimitZ)
                                            {
                                                if (indexStartPositive == -1)
                                                {
                                                    indexStartPositive = l;
                                                    distStartPositive = dist;
                                                }
                                            }
                                            else
                                            {
                                                if (indexStartPositive != -1)
                                                {
                                                    indexEndPositive = l - 1;
                                                    distEndPositive = dist;
                                                    break;
                                                }
                                            }
                                        }
                                        if ((indexStartPositive != -1) && (indexEndPositive == -1))
                                        {
                                            indexEndPositive = indexEPos;
                                            distEndPositive = dist;
                                        }
                                    }
                                    //Trace.WriteLine(startIndex.ToString());
                                    //find interval where distance is within range
                                    for (int l = 0; l < numPointsNeedle; l++)
                                    {
                                        dist = Math.Abs(needlePoints_PRS[l].Z);

                                        if (dist < LimitZ)
                                        {
                                            if (startIndex == -1)
                                            {
                                                startIndex = l;
                                            }
                                        }
                                        else
                                        {
                                            if (startIndex != -1)
                                            {
                                                endIndex = l - 1;
                                            }
                                        }
                                    }
                                    if ((startIndex != -1) && (endIndex == -1))
                                    {
                                        endIndex = numPointsNeedle - 1;
                                    }

                                    //Define the Needle lines for Teacher and Student eco visualization: starting and ending point, crossing of probe quad plane
                                    if (!EffectFasciaHitActivated)
                                    {
                                        positivePresent = ((indexStartPositive != -1) && (indexEndPositive != -1));
                                        negativePresent = ((indexStartNegative != -1) && (indexEndNegative != -1));
                                        allPresent = ((endIndex != -1) && (startIndex != -1));
                                        if (allPresent)
                                        {
                                            tipInVisiblePlane = SetLine(
                                                needlePoints_PRS[startIndex], needlePoints_PRS[endIndex],
                                                needlePoints_PRS[positivePresent ? indexStartPositive : 0], needlePoints_PRS[positivePresent ? indexEndPositive : 0],
                                                needlePoints_PRS[negativePresent ? indexStartNegative : 0], needlePoints_PRS[negativePresent ? indexEndNegative : 0],
                                                distStartPositive, distEndPositive, distStartNegative, distEndNegative,
                                                true, positivePresent, negativePresent,
                                                needleVisible);
                                            if (endIndex == numPointsNeedle - 1)
                                            {
                                                needleTipOnPlane = true;
                                            }
                                            else
                                            {
                                                needleTipOnPlane = false;
                                            }
                                            //LineColor = (needleTipOnPlane ? (tipInVisiblePlane ? System.Windows.Media.Brushes.White : System.Windows.Media.Brushes.Yellow) : System.Windows.Media.Brushes.Red);
                                            //LineColorEco = (needleTipOnPlane ? (tipInVisiblePlane ? System.Windows.Media.Brushes.White : System.Windows.Media.Brushes.Yellow) : System.Windows.Media.Brushes.Red);
                                        }
                                        else
                                        {
                                            SetLine(new VectorMath.Vector3(0, 0, 0), new VectorMath.Vector3(0, 0, 0), new VectorMath.Vector3(0, 0, 0), new VectorMath.Vector3(0, 0, 0), new VectorMath.Vector3(0, 0, 0), new VectorMath.Vector3(0, 0, 0), -1, -1, -1, -1, false, false, false, needleVisible);
                                            needleTipOnPlane = false;
                                            tipInVisiblePlane = false;
                                            VisibleLineNegative = Visibility.Hidden;
                                            VisibleLinePositive = Visibility.Hidden;
                                        }

                                        NeedleAngleOk = Math.Abs(angleDeg) < LimitAngleDeg;
                                        NeedleTipOnPlane = needleTipOnPlane;
                                        NeedleAlignedCorrectly = NeedleAngleOk & NeedleTipOnPlane;
                                        TipInVisiblePlane = tipInVisiblePlane && (Math.Abs(distance) < LimitZ);
                                    }
                                }

                                if ((toUpdateControls) && (!EffectFasciaHitActivated))
                                {
                                    SetText(sf.tbDistanceNeedle, DistanceNeedleToFascia > 500 ? "" : (DistanceNeedleToFascia * RatioVisualizationMMperPixel).ToString("000"));
                                    SetText(sf.tbIntervalNeedleToFascia, IntervalNeedleToFascia.ToString("000.00"));
                                    SetIndicator(sf.elProbeOnSkin, probeOnSkin);
                                    SetIndicator(sf.elNeedleAligned, NeedleAlignedCorrectly);
                                    SetIndicator(sf.elNeedleTipPresentInPlane, TipInVisiblePlane);
                                    SetText(sf.tbInsertionsCounter, InsertionNeedle.ToString());

                                    SetText(wft.tbDistanceNeedle, DistanceNeedleToFascia > 500 ? "" : (DistanceNeedleToFascia * RatioVisualizationMMperPixel).ToString("000"));
                                    SetText(wft.tbIntervalNeedleToFascia, IntervalNeedleToFascia.ToString("000.00"));
                                    SetIndicator(wft.elNeedleInSkin, needleInSkin);
                                    SetIndicator(wft.elProbeOnSkin, probeOnSkin);
                                    SetIndicator(wft.elNeedleAligned, NeedleAlignedCorrectly);
                                    SetIndicator(wft.elNeedleTipPresentInPlane, TipInVisiblePlane);
                                    SetText(wft.tbInsertionsCounter, InsertionNeedle.ToString());

                                    if (CurrentPhase != null)
                                    {
                                        if ((CurrentPhase.PhaseType == Enum_Phases.INVESTIGATE_HOTSPOT_NEEDLE) || (CurrentPhase.PhaseType == Enum_Phases.INVESTIGATE_TRAJECTORY_NEEDLE))
                                        {
                                            WindowTeacher.Dispatcher.Invoke(() =>
                                            {
                                                if (!EffectFasciaHitActivated)
                                                {
                                                    SetText(sf.tbIndicationsStudent, (needleInSkin ? StringNeedleInjInsertAnesthetic : sf.tbIndicationsStudent.Text));
                                                }
                                            });
                                        }
                                    }

                                    if (!IsParavertebralCase() && CurrentCase != null && CurrentPhase != null && CurrentPhase.ImEcoPhase && !LoadingCase)
                                    {
                                        EvaluateAndUpdateImage(positionProbeEdge_HRS, probeYPR_HRS);
                                    }

                                    if (wft.exGlobal.IsExpanded == true)
                                    {
                                        rotationSensor02_HRS_real = VectorMath.Quaternion.Multiply(rotationSensor02_WRS_real, rotationQuaternion_WRS_TO_HRS_VectorMath);
                                        VectorMath.Vector3 s2_WRS = EulerUtils.DCMtoEA(VectorMath.Matrix.RotationQuaternion(rotationSensor02_WRS_real), EULER_CALC_MODE.ZYX);
                                        VectorMath.Vector3 s2_HRS = EulerUtils.DCMtoEA(VectorMath.Matrix.RotationQuaternion(rotationSensor02_HRS_real), EULER_CALC_MODE.ZYX);
                                        sensor02ypr_WRS_real = new YPR() { Yaw = s2_WRS.Z, Pitch = s2_WRS.Y, Roll = s2_WRS.X };
                                        sensor02ypr_HRS_real = new YPR() { Yaw = s2_HRS.Z, Pitch = s2_HRS.Y, Roll = s2_HRS.X };

                                        rotationNeedle_HRS_real = VectorMath.Quaternion.Multiply(rotationNeedle_WRS_real, rotationQuaternion_WRS_TO_HRS_VectorMath);
                                        VectorMath.Vector3 needle_WRS = EulerUtils.DCMtoEA(VectorMath.Matrix.RotationQuaternion(rotationNeedle_WRS_real), EULER_CALC_MODE.ZYX);
                                        VectorMath.Vector3 needle_HRS = EulerUtils.DCMtoEA(VectorMath.Matrix.RotationQuaternion(rotationNeedle_HRS_real), EULER_CALC_MODE.ZYX);
                                        needleYPR_WRS_real = new YPR() { Yaw = needle_WRS.Z, Pitch = needle_WRS.Y, Roll = needle_WRS.X };
                                        needleYPR_HRS_real = new YPR() { Yaw = needle_HRS.Z, Pitch = needle_HRS.Y, Roll = needle_HRS.X };

                                        SetText(wft.lblSensor2, $"{BlockSim.Globalization.Language.str_sensor_abbr}{f2.Sensor}: {BlockSim.Globalization.Language.str_fc}{f2.FrameCount * 10:0000} {BlockSim.Globalization.Language.str_pos}{positionSensor02_WRS_real.X:0.00} {positionSensor02_WRS_real.Y:0.00} {positionSensor02_WRS_real.Z:0.00} ");
                                        SetText(wft.lblNumberOfSensors, BlockSim.Globalization.Language.str_num_sens + " " + frames.Count.ToString());
                                        SetText(wft.lblSensor1, $"{BlockSim.Globalization.Language.str_sensor_abbr}{f1.Sensor}: {BlockSim.Globalization.Language.str_fc}{f1.FrameCount * 10:0000} {BlockSim.Globalization.Language.str_pos}{positionSensor01_WRS.X:0.00} {positionSensor01_WRS.Y:0.00} {positionSensor01_WRS.Z:0.00} {BlockSim.Globalization.Language.str_ori} {BlockSim.Globalization.Language.str_yaw}{sensor01ypr_WRS.YawDegree:0.00} {BlockSim.Globalization.Language.str_pitch}{sensor01ypr_WRS.PitchDegree:0.00} {BlockSim.Globalization.Language.str_roll}{sensor01ypr_WRS.RollDegree:0.00} ");
                                        SetIndicator(wft.bNeedleInSkin, needleInSkin);
                                        SetIndicator(wft.bProbeOnSkin, probeOnSkin);
                                        SetText(wft.lblDistance, BlockSim.Globalization.Language.str_dist_tip_plane + " " + distance.ToString("00.00"));
                                        SetIndicator(wft.bDistanceTipToPlaneOK, Math.Abs(distance) < LimitZ);
                                        SetText(wft.lblAngle, BlockSim.Globalization.Language.str_ang_needle_plane + " " + (angleDeg).ToString("00.00"));
                                        SetIndicator(wft.bNeedleAngleOk, NeedleAlignedCorrectly);
                                        SetIndicator(wft.bNeedlePointOnPlane, TipInVisiblePlane);
                                        SetText(wft.lXYZProbe, $"{BlockSim.Globalization.Language.str_pos}{positionProbeEdge_HRS.X:00.00} {positionProbeEdge_HRS.Y:00.00} {positionProbeEdge_HRS.Z:00.00} ");
                                        SetText(wft.lYPRProbe, $"{BlockSim.Globalization.Language.str_yaw}{sensor01ypr_HRS.YawDegree:000.00} {BlockSim.Globalization.Language.str_pitch}{sensor01ypr_HRS.PitchDegree:000.00} {BlockSim.Globalization.Language.str_roll}{sensor01ypr_HRS.RollDegree:000.00} ");
                                        SetText(wft.lXYZNeedlePoint, $"{BlockSim.Globalization.Language.str_pos}{needlePointFinish_HRS.X:00.00} {needlePointFinish_HRS.Y:00.00} {needlePointFinish_HRS.Z:00.00} ");
                                        SetText(wft.lYPRNeedlePoint, $"{BlockSim.Globalization.Language.str_yaw}{needleYPR_HRS_real.YawDegree:000.00} {BlockSim.Globalization.Language.str_pitch}{needleYPR_HRS_real.PitchDegree:000.00} {BlockSim.Globalization.Language.str_roll}{needleYPR_HRS_real.RollDegree:000.00} ");
                                        SetText(wft.lXYZProbe_WRS, $"{BlockSim.Globalization.Language.str_pos}{positionProbeEdge_WRS.X:00.00} {positionProbeEdge_WRS.Y:00.00} {positionProbeEdge_WRS.Z:00.00} ");
                                    }
                                }
                            }

                            if (AppControl.Instance.CurrentModel == "neck")
                            {
                                if ((DateTime.Now - lastCollisioneCheck).TotalMilliseconds > limitTimeColliderControlMilliseconds)
                                {
                                    counterCollider++;
                                    if (counterCollider > 50)
                                    {
                                        counterCollider = 0;
                                    }

                                    probeEdgeCollider = new Point3D(positionProbeEdge_WRS.X, positionProbeEdge_WRS.Y, positionProbeEdge_WRS.Z);

                                    Vector3D directionProbe = new Vector3D(vecCollisionProbe_WRS.X, vecCollisionProbe_WRS.Y, vecCollisionProbe_WRS.Z);

                                    RayHitTestParameters hitParamsProbe = new RayHitTestParameters(probeEdgeCollider, directionProbe);
                                    VisualTreeHelper.HitTest(wft.modelSkinBlock, null, ResultCallbackProbe, hitParamsProbe);

                                    needleEdgeCollider = new Point3D(needlePointFinish_WRS_real_ForAntiCollisionPadD.X, needlePointFinish_WRS_real_ForAntiCollisionPadD.Y, needlePointFinish_WRS_real_ForAntiCollisionPadD.Z);
                                    //needleEdgeCollider_Before = new Point3D(needlePointFinish_WRS_real_ForAntiCollisionPadD.X, needlePointFinish_WRS_real_ForAntiCollisionPadD.Y, needlePointFinish_WRS_real_ForAntiCollisionPadD.Z);
                                    // needleEdgeColliderRot = wft.modelSkinBlockInverseTrasform.Transform(needleEdgeCollider);
                                    //needleEdgeColliderRot_Before = wft.modelSkinBlockInverseTrasform.Transform(needleEdgeCollider_Before);
                                    //Point3D directionNeedle = wft.modelSkinBlockInverseTrasform.Transform(new Point3D(vecCollisionNeedle_WRS.X, vecCollisionNeedle_WRS.Y, vecCollisionNeedle_WRS.Z));
                                    Vector3D directionNeedle = new Vector3D(vecCollisionNeedle_WRS.X, vecCollisionNeedle_WRS.Y, vecCollisionNeedle_WRS.Z);

                                    RayHitTestParameters hitParamsNeedle = new RayHitTestParameters(needleEdgeCollider, directionNeedle);
                                    VisualTreeHelper.HitTest(wft.modelSkinBlock, null, ResultCallbackNeedle, hitParamsNeedle);

                                    if ((DateTime.Now - LastCollisionNeedleDetected).TotalMilliseconds > 100)
                                    {
                                        VisibilityNeedleCollisionCheck = false;
                                        NeedleHits = false;
                                    }
                                    if ((DateTime.Now - LastCollisionProbeDetected).TotalMilliseconds > 100)
                                    {
                                        VisibilityProbeCollisionCheck = false;
                                        ProbeHits = false;
                                    }
                                    lastCollisioneCheck = DateTime.Now;
                                }
                            }
                        }
                    }
                }));
            }
            catch (Exception)
            {
            }
        }

        public bool CheckCollisions = false;

        public HitTestFilterBehavior MyHitTestFilter(DependencyObject o)
        {
            string gg = AutomationProperties.GetName(o);

            if ((o.GetType() == typeof(ModelVisual3D)))
            {
                if ((gg == "modelHumanBlock") || (gg == "modelProbePlane") || (gg == "modelProbeBlock") || (gg == "modelAntenna") || (gg == "modelNeedle") || (gg == "modelStartCircle") || (gg == "modelendCircle") || (gg == "modelHitTestProbe") || (gg == "modelHitTestNeedle"))
                {
                    return HitTestFilterBehavior.ContinueSkipSelfAndChildren;
                }
                else
                {
                    return HitTestFilterBehavior.Continue;
                }
            }
            return HitTestFilterBehavior.Continue;
        }

        public System.Windows.Point ritmicPoint = new System.Windows.Point(200, 200);
        public double deformationTotalTimeSeconds = 2.5;
        private List<Deformation> deformationsForNerveContinuousInjections = new List<Deformation>();
        //private float maximumDisplacement = 50;
        //private float sizeEffect = 150;

        private float maximumDisplacement = 30;
        private float sizeEffect = 90;
        private DispatcherTimer timerDeformation;

        public HitTestResultBehavior ResultCallbackProbe(System.Windows.Media.HitTestResult result)
        {
            // Did we hit 3D?
            RayHitTestResult rayResult = result as RayHitTestResult;
            if (rayResult != null)
            {
                VisibilityProbeCollisionCheck = false;//true;
                // Did we hit a MeshGeometry3D?
                RayMeshGeometry3DHitTestResult rayMeshResult = rayResult as RayMeshGeometry3DHitTestResult;
                if (rayMeshResult != null)
                {
                    Point3D ptl_Collider = new Point3D(rayResult.PointHit.X, rayResult.PointHit.Y, rayResult.PointHit.Z);
                    PointCollideProbe3Ds.Add(new OrderedPoint(counterCollider, ptl_Collider));
                    if (PointCollideProbe3Ds.Count > 1)
                    {
                        if (PointCollideProbe3Ds[0].Cluster != counterCollider)
                        {
                            distancesProbeCollision.Clear();
                            for (int oo = 0; oo < PointCollideProbe3Ds.Count - 1; oo++)
                            {
                                distancesProbeCollision.Add(DistanceBetween(PointCollideProbe3Ds[oo].P3D, probeEdgeCollider));
                            }
                            distanceProbeHits = distancesProbeCollision.Min();
                            int indexMin = distancesProbeCollision.IndexOf(distanceProbeHits);
                            Vector3 ptl_ClliderOptimal = new Vector3((float)PointCollideProbe3Ds[indexMin].P3D.X, (float)PointCollideProbe3Ds[indexMin].P3D.Y, (float)PointCollideProbe3Ds[indexMin].P3D.Z);
                            CollidePointProbe = new Point3D(ptl_ClliderOptimal.X, ptl_ClliderOptimal.Y, ptl_ClliderOptimal.Z);
                            ProbeHits = true;
                            LastCollisionProbeDetected = DateTime.Now;
                            PointCollideProbe3Ds.RemoveRange(0, PointCollideProbe3Ds.Count - 1);
                        }
                    }
                }
            }
            else
            {
                VisibilityProbeCollisionCheck = false;
                ProbeHits = false;
            }
            return HitTestResultBehavior.Continue;
        }

        public HitTestResultBehavior ResultCallbackNeedle(System.Windows.Media.HitTestResult result)
        {
            // Did we hit 3D?
            RayHitTestResult rayResult = result as RayHitTestResult;
            if (rayResult != null)
            {
                VisibilityNeedleCollisionCheck = false;//true;
                // Did we hit a MeshGeometry3D?
                RayMeshGeometry3DHitTestResult rayMeshResult = rayResult as RayMeshGeometry3DHitTestResult;
                if (rayMeshResult != null)
                {
                    Point3D ptl_Collider = new Point3D(rayResult.PointHit.X, rayResult.PointHit.Y, rayResult.PointHit.Z);
                    PointCollideNeedle3Ds.Add(new OrderedPoint(counterCollider, ptl_Collider));
                    if (PointCollideNeedle3Ds.Count > 1)
                    {
                        if (PointCollideNeedle3Ds[0].Cluster != counterCollider)
                        {
                            distancesNeedleCollision.Clear();
                            for (int oo = 0; oo < PointCollideNeedle3Ds.Count - 1; oo++)
                            {
                                distancesNeedleCollision.Add(DistanceBetween(PointCollideNeedle3Ds[oo].P3D, needleEdgeCollider));
                            }
                            distanceNeedleHits = distancesNeedleCollision.Min();
                            int indexMin = distancesNeedleCollision.IndexOf(distanceNeedleHits);
                            Vector3 ptl_ClliderOptimal = new Vector3((float)PointCollideNeedle3Ds[indexMin].P3D.X, (float)PointCollideNeedle3Ds[indexMin].P3D.Y, (float)PointCollideNeedle3Ds[indexMin].P3D.Z);
                            CollidePointNeedle = new Point3D(ptl_ClliderOptimal.X, ptl_ClliderOptimal.Y, ptl_ClliderOptimal.Z);
                            WorkingFrameTeacher wft = (WorkingFrameTeacher)WindowTeacher.PageContainer.Content;
                            LastCollisionNeedleDetected = DateTime.Now;
                            NeedleHits = true;
                            PointCollideNeedle3Ds.RemoveRange(0, PointCollideNeedle3Ds.Count - 1);
                        }
                    }
                }
            }
            else
            {
                VisibilityNeedleCollisionCheck = false;
                NeedleHits = false;
            }

            return HitTestResultBehavior.Continue;
        }

        private List<double> distancesProbeCollision = new List<double>();

        private List<double> distancesNeedleCollision = new List<double>();

        public static double DistanceBetween(Point3D a, Point3D b)
        {
            Point3D direction = new Point3D();
            direction.X = b.X - a.X;
            direction.Y = b.Y - a.Y;
            direction.Z = b.Z - a.Z;

            return Math.Sqrt(direction.X * direction.X +
                             direction.Y * direction.Y +
                             direction.Z * direction.Z);
        }

        private List<OrderedPoint> PointCollideProbe3Ds = new List<OrderedPoint>();

        private List<OrderedPoint> PointCollideNeedle3Ds = new List<OrderedPoint>();
        private int counterCollider;

        private double limitTimeColliderControlMilliseconds = 50;
        private Vector3 needlePointFinish_WRS_real_adapted;
        private Vector3 needlePointFinish_WRS_real_ForCollisionPadD;
        private Vector3 needlePointFinish_WRS_real_ForAntiCollisionPadD;
        private Point3D needleEdgeCollider;

        private Point3D collidePointProbe;
        private double distanceNeedleHits;
        private double distanceProbeHits;
        private Point3D probeEdgeColliderForward;

        private Point3D probeEdgeCollider;
        private bool isFasciaOrNerve;
        private List<LineGeometry3D> targetsNerveIndication;
        private List<List<SharpDX.Vector3>> pointsNerve;
        private List<SharpDX.Vector3> dispCentersCircularNerve;
        private LineGeometry3D targetNerveIndication2;
        private LineGeometry3D targetNerveIndication1;
        private LineGeometry3D targetNerveIndication3;
        private LineGeometry3D targetNerveIndication4;
        private LineGeometry3D targetNerveIndication5;
        private LineGeometry3D targetNerveIndication6;
        private LineGeometry3D targetNerveIndication7;
        private LineGeometry3D targetNerveIndication8;
        private LineGeometry3D targetNerveIndication9;
        private LineGeometry3D targetNerveIndication10;
        private LineGeometry3D targetNerveIndication11;

        private Color targetNerveIndicationColor;
        private string textNerveTarget;
        private string textWrongInjections;
        private string textWrongInjectionsExp;
        private DateTime lastDeformationRunTimer;
        public bool DemoMode = true;
        private string textNerveWrongExp;
        private string textVascularWrongExp;
        private string textNerveWrong;
        private string textVascularWrong;
        private string textNerveWrongIntro;
        private string textVascularWrongIntro;
        private Color targetNerveIndicationColor2;
        private Color targetNerveIndicationColor1;
        private Color targetNerveIndicationColor4;
        private Color targetNerveIndicationColor3;
        private Color targetNerveIndicationColor5;
        private Color targetNerveIndicationColor6;
        private Color targetNerveIndicationColor7;
        private Color targetNerveIndicationColor8;
        private Color targetNerveIndicationColor11;
        private Color targetNerveIndicationColor9;
        private Color targetNerveIndicationColor10;

        private bool IsParavertebralCase()
        {
            if (CurrentCase != null && CurrentCase.Name == BlockSim.Globalization.Language.str_parav_name)
                return true;

            return false;
        }

        private void SaveResult()
        {
            Results result = new Results();
            result.IdCase = 0;
            result.CaseName = CurrentCase.Name;

            DateTime now = DateTime.Now;
            result.Date = DateTime.Now.ToString(new CultureInfo(16));

            result.Score = CurrentCaseScore;
            result.IdEvent = (CurrentEvent == null ? -1 : CurrentEvent.Id);
            result.IdStudent = (CurrentStudent == null ? -1 : CurrentStudent.Id);
            result.IdTeacher = (CurrentTeacher == null ? -1 : CurrentTeacher.Id);

            DateTime tt = DateTime.Now;
            string baseFolder = "C:\\BlockSim\\DataBase\\Results\\" + result.CaseName + "_" +
                tt.Year.ToString() + tt.Month.ToString() + tt.Day.ToString() + "_" +
                tt.Hour.ToString() + tt.Minute.ToString() + tt.Second.ToString();

            if (!Directory.Exists(baseFolder))
            {
                Directory.CreateDirectory(baseFolder);
            }

            string filePath = baseFolder + "\\CaseSaved.xml";
            ResultToSave resToSave = new ResultToSave();
            resToSave.NumberOfNeedleInsertions = InsertionNeedle;
            resToSave.TimeNeedlePhase = DurationNeedlePhase.TotalSeconds;

            if (CurrentPhase.NerveMultipleInjections)
            {
                resToSave.IsMultipleNeedleInjections = true;
                resToSave.WrongInjections = TargetMissedNerve_Injections;
                resToSave.TotalTargetNerves = CurrentPhase.TargetPointsNerve.Where(c => c.T== 0).Count();
                resToSave.TotalTargetInjected = CurrentPhase.TargetPointsNerve.Where(c => ((c.Injections.Count > 0) && (c.T==0))).Count();
                resToSave.TotalNervesWrong = CurrentPhase.TargetPointsNerve.Where(c => c.T == 1).Count();
                resToSave.TotalNervesWrongHits = CurrentPhase.TargetPointsNerve.Where(c => ((c.AreaEnteredFromNeedle > 0) && (c.T == 1))).Count();
                resToSave.TotalVascular = CurrentPhase.TargetPointsNerve.Where(c => c.T == 2).Count();
                resToSave.TotalVascularHits = CurrentPhase.TargetPointsNerve.Where(c => ((c.AreaEnteredFromNeedle > 0) && (c.T == 2))).Count();
            }
            else
            {
                resToSave.IsMultipleNeedleInjections = false;
                resToSave.FasciaPuntured = NeedleTargetedFascia;
                resToSave.VerticalDistanceNeedleToFascia = DistanceNeedleToFasciaAtPuntureMM;
                resToSave.VerticalDistanceNeedleToFasciaUpper = DistanceNeedleToFasciaAtPuntureMMUpperLimit;
                resToSave.VerticalDistanceNeedleToFasciaLower = DistanceNeedleToFasciaAtPuntureMMLowerLimit;
                resToSave.HorizontalTargetingNeedleToFascia = IntervalNeedleToFasciaAtPunture;
            }

            resToSave.Save<ResultToSave>(filePath);
            result.FilePath = filePath;
            DBConnector.Instance.InsertRow<Results>(result);
        }

        private void ScannedSimulatorListener()
        {
            try
            {
                EvaluateAvailableSimulators();
            }
            catch (Exception ex)
            {
                Debug.WriteLine(ex.Message + ex.StackTrace);
                MessageBox.Show(ex.StackTrace + ex.Message);
            }
        }

        private bool SetLine(VectorMath.Vector3 v1, VectorMath.Vector3 v2,
            VectorMath.Vector3 v1Pos, VectorMath.Vector3 v2Pos,
            VectorMath.Vector3 v1Neg, VectorMath.Vector3 v2Neg,
            float dist1Pos, float dist2Pos, float dist1Neg, float dist2Neg,
            bool allPresent, bool posPresent, bool negPresent,
            bool needleVisible)
        {
            if ((WindowTeacher.PageContainer.Content is WorkingFrameTeacher))
            {
                WorkingFrameTeacher wft = (WorkingFrameTeacher)WindowTeacher.PageContainer.Content;
                StudentFrame sf = (StudentFrame)WindowStudent.PageContainer.Content;
                if (!WindowTeacher.Dispatcher.CheckAccess())
                {
                    SetLineDelegate d = new SetLineDelegate(SetLine);
                    return (bool)WindowTeacher.Dispatcher.Invoke(d, new object[] { v1, v2, allPresent });
                }
                else
                {
                    double h = wft.bCanvasEco.Height;// * CurrentPhase.FormFactorVisualization;
                    double w = wft.bCanvasEco.Width;// * CurrentPhase.FormFactorVisualization;
                    double hEco = sf.bCanvasEco.Height;// * CurrentPhase.FormFactorVisualization;
                    double wEco = sf.bCanvasEco.Width;// * CurrentPhase.FormFactorVisualization;
                    return SetLine(

                        new VectorMath.Vector3(v1.X * 1, v1.Y, v1.Z),
                        new VectorMath.Vector3(v2.X * 1, v2.Y, v2.Z),
                        new VectorMath.Vector3(v1Pos.X * 1, v1Pos.Y, v1Pos.Z),
                        new VectorMath.Vector3(v2Pos.X * 1, v2Pos.Y, v2Pos.Z),
                        new VectorMath.Vector3(v1Neg.X * 1, v1Neg.Y, v1Neg.Z),
                        new VectorMath.Vector3(v2Neg.X * 1, v2Neg.Y, v2Neg.Z),

                        dist1Pos, dist2Pos, dist1Neg, dist2Neg,
                        allPresent, posPresent, negPresent,
                        h, w, hEco, wEco,
                        needleVisible);
                }
            }
            else
            {
                return false;
            }
        }

        //private void SetupModel(bool effectPresent, Enum_DeformableAreaType defType, int hei, int wid, float ratioDeformUp, float ratioDeformDown, Enum_StartingSurface startingSurface, List<SharpDX.Vector3> pointsStartingSurface, float originDeformation, float effectSize)
        //{
        //    SetUpModel(effectPresent, defType, hei, wid, ratioDeformUp, ratioDeformDown, startingSurface, pointsStartingSurface, originDeformation, effectSize);

        //}

        private void TimerCheckPolhemusTick_Listener(object sender, EventArgs e)
        {
            if ((DateTime.Now - lastArrivedInput).TotalSeconds > 0.5)
            {
                alreadyConnectedPolhemus = false;
                SetIndicator(WindowTeacher.elSensors, alreadyConnectedPolhemus);
            }
        }

        private void ImageRefresher_Tick(object sender, EventArgs e)
        {
            if (CurrentCase != null && CurrentPhase != null && CurrentPhase.ImEcoPhase && !LoadingCase)
                EvaluateAndUpdateImage(positionProbeEdge_HRS, probeYPR_HRS);
        }

        //PIRINI UNCOMMENT HERE FOR LICENSE CHECK
        public void CheckModulesActivation()
        {
<<<<<<< HEAD
            bool checkLicense = false;
            if (!ModulesChecked)
=======
            if (!ModulesChecked && BlockSimController.Instance.Simulator != null)
>>>>>>> 632b0155f3fcc50734b075ea81ee2017bc2f167c
            {
                ModulesLicence licence = new ModulesLicence();
                if (checkLicense)
                {
                    licence.UpdateModulesLicence(BKSSimulatorConnected, BlockSimController.Instance.Simulator.SerialNumber);
                }
                string[] modulesNames = Enum.GetNames(typeof(Enum_Modules));
                Modules = new ObservableCollection<string>();
                ModulesNames = new ObservableCollection<string>();
                if (checkLicense)
                {
                    for (int i = 0; i < Instance.ModulesActivation.Length; i++)
                    {
                        ModulesActivation[i] = licence.CheckModuleOnRegistry(BKSSimulatorConnected, BlockSimController.Instance.Simulator.SerialNumber, modulesNames[i]);
                        if (ModulesActivation[i])
                        {
                            Modules.Add(modulesNames[i]);
                        }
                    }
                }
                else
                {
                    foreach (string s in modulesNames)
                    {
                        Modules.Add(s);
                    }
                }

                foreach (string s in Modules)
                {
                    switch (s)
                    {
                        case "FasciaBlocks":
                            ModulesNames.Add(BlockSim.Globalization.Language.str_title_fascia_blocks); 
                            break;
                        case "NerveBlocks":
                            ModulesNames.Add(BlockSim.Globalization.Language.str_title_nerve_blocks); 
                            break;
                        case "Hip":
                            ModulesNames.Add(BlockSim.Globalization.Language.str_title_hip_blocks); 
                            break;

                        default:
                            break;
                    }
                }
                ModulesChecked = true;

                for (int i = Cases.Count - 1; i >= 0; i--)
                {
                    Cases[i].LoadCaseDescriptor();
                    if (checkLicense)
                    {
                        if (!ModulesActivation[(int)Cases[i].Module])
                        {
                            Cases.Remove(Cases[i]);
                        }
                    }
                }


                Cases.OrderBy(p => p.Module).ThenBy(p => p.Name);
            }
        }
    }
}